
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>nolds.measures &#8212; Nolds 0.5.0 documentation</title>
    <link rel="stylesheet" href="../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '0.5.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head>
  <body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for nolds.measures</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="p">(</span><span class="n">absolute_import</span><span class="p">,</span> <span class="n">division</span><span class="p">,</span>
                        <span class="n">print_function</span><span class="p">,</span> <span class="n">unicode_literals</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">builtins</span> <span class="k">import</span> <span class="o">*</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">math</span>

<span class="k">def</span> <span class="nf">rowwise_chebyshev</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
  <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">y</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">rowwise_euclidean</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
  <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">x</span> <span class="o">-</span> <span class="n">y</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">poly_fit</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">degree</span><span class="p">,</span> <span class="n">fit</span><span class="o">=</span><span class="s2">&quot;RANSAC&quot;</span><span class="p">):</span>
  <span class="c1"># check if we can use RANSAC</span>
  <span class="k">if</span> <span class="n">fit</span> <span class="o">==</span> <span class="s2">&quot;RANSAC&quot;</span><span class="p">:</span>
    <span class="k">try</span><span class="p">:</span>
      <span class="c1"># ignore ImportWarnings in sklearn</span>
      <span class="k">with</span> <span class="n">warnings</span><span class="o">.</span><span class="n">catch_warnings</span><span class="p">():</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">simplefilter</span><span class="p">(</span><span class="s2">&quot;ignore&quot;</span><span class="p">,</span> <span class="ne">ImportWarning</span><span class="p">)</span>
        <span class="kn">import</span> <span class="nn">sklearn.linear_model</span> <span class="k">as</span> <span class="nn">sklin</span>
        <span class="kn">import</span> <span class="nn">sklearn.preprocessing</span> <span class="k">as</span> <span class="nn">skpre</span>
    <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
      <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
        <span class="s2">&quot;fitting mode &#39;RANSAC&#39; requires the package sklearn, using&quot;</span>
        <span class="o">+</span> <span class="s2">&quot; &#39;poly&#39; instead&quot;</span><span class="p">,</span>
        <span class="ne">RuntimeWarning</span><span class="p">)</span>
      <span class="n">fit</span> <span class="o">=</span> <span class="s2">&quot;poly&quot;</span>

  <span class="k">if</span> <span class="n">fit</span> <span class="o">==</span> <span class="s2">&quot;poly&quot;</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">polyfit</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">degree</span><span class="p">)</span>
  <span class="k">elif</span> <span class="n">fit</span> <span class="o">==</span> <span class="s2">&quot;RANSAC&quot;</span><span class="p">:</span>
    <span class="n">model</span> <span class="o">=</span> <span class="n">sklin</span><span class="o">.</span><span class="n">RANSACRegressor</span><span class="p">(</span><span class="n">sklin</span><span class="o">.</span><span class="n">LinearRegression</span><span class="p">(</span><span class="n">fit_intercept</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>
    <span class="n">xdat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">xdat</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
      <span class="c1"># interpret 1d-array as list of len(x) samples instead of</span>
      <span class="c1"># one sample of length len(x)</span>
      <span class="n">xdat</span> <span class="o">=</span> <span class="n">xdat</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">polydat</span> <span class="o">=</span> <span class="n">skpre</span><span class="o">.</span><span class="n">PolynomialFeatures</span><span class="p">(</span><span class="n">degree</span><span class="p">)</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">xdat</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
      <span class="n">model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">polydat</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
      <span class="n">coef</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">estimator_</span><span class="o">.</span><span class="n">coef_</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
      <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
        <span class="s2">&quot;RANSAC did not reach consensus, &quot;</span>
        <span class="o">+</span> <span class="s2">&quot;using numpy&#39;s polyfit&quot;</span><span class="p">,</span>
        <span class="ne">RuntimeWarning</span><span class="p">)</span>
      <span class="n">coef</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">polyfit</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">degree</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">coef</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;invalid fitting mode (</span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">fit</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">delay_embedding</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">emb_dim</span><span class="p">,</span> <span class="n">lag</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Perform a time-delay embedding of a time series</span>

<span class="sd">  Args:</span>
<span class="sd">    data (array-like):</span>
<span class="sd">      the data that should be embedded</span>
<span class="sd">    emb_dim (int):</span>
<span class="sd">      the embedding dimension</span>
<span class="sd">  Kwargs:</span>
<span class="sd">    lag (int):</span>
<span class="sd">      the lag between elements in the embedded vectors</span>

<span class="sd">  Returns:</span>
<span class="sd">    emb_dim x m array:</span>
<span class="sd">      matrix of embedded vectors of the form</span>
<span class="sd">      [data[i], data[i+lag], data[i+2*lag], ... data[i+(emb_dim-1)*lag]]</span>
<span class="sd">      for i in 0 to m-1 (m = len(data)-(emb_dim-1)*lag)</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
  <span class="n">min_len</span> <span class="o">=</span> <span class="p">(</span><span class="n">emb_dim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">lag</span> <span class="o">+</span> <span class="mi">1</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">min_len</span><span class="p">:</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;cannot embed data of length </span><span class="si">{}</span><span class="s2"> with embedding dimension </span><span class="si">{}</span><span class="s2"> &quot;</span> \
        <span class="o">+</span> <span class="s2">&quot;and lag </span><span class="si">{}</span><span class="s2">, minimum required length is </span><span class="si">{}</span><span class="s2">&quot;</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="n">emb_dim</span><span class="p">,</span> <span class="n">lag</span><span class="p">,</span> <span class="n">min_len</span><span class="p">))</span>
  <span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">-</span> <span class="n">min_len</span> <span class="o">+</span> <span class="mi">1</span>
  <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">emb_dim</span><span class="p">)</span> <span class="o">*</span> <span class="n">lag</span><span class="p">],</span> <span class="n">m</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
  <span class="n">indices</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">m</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">m</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
  <span class="k">return</span> <span class="n">data</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span>

<div class="viewcode-block" id="lyap_r_len"><a class="viewcode-back" href="../../nolds.html#nolds.lyap_r_len">[docs]</a><span class="k">def</span> <span class="nf">lyap_r_len</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Helper function that calculates the minimum number of data points required</span>
<span class="sd">  to use lyap_r.</span>

<span class="sd">  Note that none of the required parameters may be set to None.</span>

<span class="sd">  Kwargs:</span>
<span class="sd">    kwargs(dict):</span>
<span class="sd">      arguments used for lyap_r (required: emb_dim, lag, trajectory_len and</span>
<span class="sd">      min_tsep)</span>

<span class="sd">  Returns:</span>
<span class="sd">    minimum number of data points required to call lyap_r with the given</span>
<span class="sd">    parameters</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="c1"># minimum length required to find single orbit vector</span>
  <span class="n">min_len</span> <span class="o">=</span> <span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;emb_dim&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;lag&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
  <span class="c1"># we need trajectory_len orbit vectors to follow a complete trajectory</span>
  <span class="n">min_len</span> <span class="o">+=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;trajectory_len&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>
  <span class="c1"># we need min_tsep * 2 + 1 orbit vectors to find neighbors for each</span>
  <span class="n">min_len</span> <span class="o">+=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;min_tsep&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span>
  <span class="k">return</span> <span class="n">min_len</span></div>

<div class="viewcode-block" id="lyap_r"><a class="viewcode-back" href="../../nolds.html#nolds.lyap_r">[docs]</a><span class="k">def</span> <span class="nf">lyap_r</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">emb_dim</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">lag</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">min_tsep</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tau</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">min_neighbors</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span>
           <span class="n">trajectory_len</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">fit</span><span class="o">=</span><span class="s2">&quot;RANSAC&quot;</span><span class="p">,</span> <span class="n">debug_plot</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">debug_data</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
           <span class="n">plot_file</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fit_offset</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Estimates the largest Lyapunov exponent using the algorithm of Rosenstein</span>
<span class="sd">  et al. [lr_1]_.</span>

<span class="sd">  Explanation of Lyapunov exponents:</span>
<span class="sd">    See lyap_e.</span>

<span class="sd">  Explanation of the algorithm:</span>
<span class="sd">    The algorithm of Rosenstein et al. is only able to recover the largest</span>
<span class="sd">    Lyapunov exponent, but behaves rather robust to parameter choices.</span>

<span class="sd">    The idea for the algorithm relates closely to the definition of Lyapunov</span>
<span class="sd">    exponents. First, the dynamics of the data are reconstructed using a delay</span>
<span class="sd">    embedding method with a lag, such that each value x_i of the data is mapped</span>
<span class="sd">    to the vector</span>

<span class="sd">    X_i = [x_i, x_(i+lag), x_(i+2*lag), ..., x_(i+(emb_dim-1) * lag)]</span>

<span class="sd">    For each such vector X_i, we find the closest neighbor X_j using the</span>
<span class="sd">    euclidean distance. We know that as we follow the trajectories from X_i and</span>
<span class="sd">    X_j in time in a chaotic system the distances between X_(i+k) and X_(j+k)</span>
<span class="sd">    denoted as d_i(k) will increase according to a power law</span>
<span class="sd">    d_i(k) = c * e^(lambda * k) where lambda is a good approximation of the</span>
<span class="sd">    highest Lyapunov exponent, because the exponential expansion along the axis</span>
<span class="sd">    associated with this exponent will quickly dominate the expansion or</span>
<span class="sd">    contraction along other axes.</span>

<span class="sd">    To calculate lambda, we look at the logarithm of the distance trajectory,</span>
<span class="sd">    because log(d_i(k)) = log(c) + lambda * k. This gives a set of lines</span>
<span class="sd">    (one for each index i) whose slope is an approximation of lambda. We</span>
<span class="sd">    therefore extract the mean log trajectory d&#39;(k) by taking the mean of</span>
<span class="sd">    log(d_i(k)) over all orbit vectors X_i. We then fit a straight line to</span>
<span class="sd">    the plot of d&#39;(k) versus k. The slope of the line gives the desired</span>
<span class="sd">    parameter lambda.</span>

<span class="sd">  Method for choosing min_tsep:</span>
<span class="sd">    Usually we want to find neighbors between points that are close in phase</span>
<span class="sd">    space but not too close in time, because we want to avoid spurious</span>
<span class="sd">    correlations between the obtained trajectories that originate from temporal</span>
<span class="sd">    dependencies rather than the dynamic properties of the system. Therefore it</span>
<span class="sd">    is critical to find a good value for min_tsep. One rather plausible</span>
<span class="sd">    estimate for this value is to set min_tsep to the mean period of the</span>
<span class="sd">    signal, which can be obtained by calculating the mean frequency using the</span>
<span class="sd">    fast fourier transform. This procedure is used by default if the user sets</span>
<span class="sd">    min_tsep = None.</span>

<span class="sd">  Method for choosing lag:</span>
<span class="sd">    Another parameter that can be hard to choose by instinct alone is the lag</span>
<span class="sd">    between individual values in a vector of the embedded orbit. Here,</span>
<span class="sd">    Rosenstein et al. suggest to set the lag to the distance where the</span>
<span class="sd">    autocorrelation function drops below 1 - 1/e times its original (maximal)</span>
<span class="sd">    value. This procedure is used by default if the user sets lag = None.</span>

<span class="sd">  References:</span>
<span class="sd">    .. [lr_1] M. T. Rosenstein, J. J. Collins, and C. J. De Luca,</span>
<span class="sd">       “A practical method for calculating largest Lyapunov exponents from</span>
<span class="sd">       small data sets,” Physica D: Nonlinear Phenomena, vol. 65, no. 1,</span>
<span class="sd">       pp. 117–134, 1993.</span>

<span class="sd">  Reference Code:</span>
<span class="sd">    .. [lr_a] mirwais, &quot;Largest Lyapunov Exponent with Rosenstein&#39;s Algorithm&quot;,</span>
<span class="sd">       url: http://www.mathworks.com/matlabcentral/fileexchange/38424-largest-lyapunov-exponent-with-rosenstein-s-algorithm</span>
<span class="sd">    .. [lr_b] Shapour Mohammadi, &quot;LYAPROSEN: MATLAB function to calculate</span>
<span class="sd">       Lyapunov exponent&quot;,</span>
<span class="sd">       url: https://ideas.repec.org/c/boc/bocode/t741502.html</span>

<span class="sd">  Args:</span>
<span class="sd">    data (iterable of float):</span>
<span class="sd">      (one-dimensional) time series</span>
<span class="sd">  Kwargs:</span>
<span class="sd">    emb_dim (int):</span>
<span class="sd">      embedding dimension for delay embedding</span>
<span class="sd">    lag (float):</span>
<span class="sd">      lag for delay embedding</span>
<span class="sd">    min_tsep (float):</span>
<span class="sd">      minimal temporal separation between two &quot;neighbors&quot; (default:</span>
<span class="sd">      find a suitable value by calculating the mean period of the data)</span>
<span class="sd">    tau (float):</span>
<span class="sd">      step size between data points in the time series in seconds</span>
<span class="sd">      (normalization scaling factor for exponents)</span>
<span class="sd">    min_neighbors (int):</span>
<span class="sd">      if lag=None, the search for a suitable lag will be stopped when the</span>
<span class="sd">      number of potential neighbors for a vector drops below min_neighbors</span>
<span class="sd">    trajectory_len (int):</span>
<span class="sd">      the time (in number of data points) to follow the distance</span>
<span class="sd">      trajectories between two neighboring points</span>
<span class="sd">    fit (str):</span>
<span class="sd">      the fitting method to use for the line fit, either &#39;poly&#39; for normal</span>
<span class="sd">      least squares polynomial fitting or &#39;RANSAC&#39; for RANSAC-fitting which</span>
<span class="sd">      is more robust to outliers</span>
<span class="sd">    debug_plot (boolean):</span>
<span class="sd">      if True, a simple plot of the final line-fitting step will</span>
<span class="sd">      be shown</span>
<span class="sd">    debug_data (boolean):</span>
<span class="sd">      if True, debugging data will be returned alongside the result</span>
<span class="sd">    plot_file (str):</span>
<span class="sd">      if debug_plot is True and plot_file is not None, the plot will be saved</span>
<span class="sd">      under the given file name instead of directly showing it through</span>
<span class="sd">      ``plt.show()``</span>
<span class="sd">    fit_offset (int):</span>
<span class="sd">      neglect the first fit_offset steps when fitting</span>

<span class="sd">  Returns:</span>
<span class="sd">    float:</span>
<span class="sd">      an estimate of the largest Lyapunov exponent (a positive exponent is</span>
<span class="sd">      a strong indicator for chaos)</span>
<span class="sd">    (1d-vector, 1d-vector, list):</span>
<span class="sd">      only present if debug_data is True: debug data of the form</span>
<span class="sd">      ``(ks, div_traj, poly)`` where ``ks`` are the x-values of the line fit, </span>
<span class="sd">      ``div_traj`` are the y-values and ``poly`` are the line coefficients</span>
<span class="sd">      (``[slope, intercept]``).</span>

<span class="sd">  &quot;&quot;&quot;</span>
  <span class="c1"># convert data to float to avoid overflow errors in rowwise_euclidean</span>
  <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float32&quot;</span><span class="p">)</span>
  <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
  <span class="n">max_tsep_factor</span> <span class="o">=</span> <span class="mf">0.25</span>
  <span class="k">if</span> <span class="n">lag</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">min_tsep</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="c1"># both the algorithm for lag and min_tsep need the fft</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">rfft</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">n</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">min_tsep</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="c1"># calculate min_tsep as mean period (= 1 / mean frequency)</span>
    <span class="n">mf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">rfftfreq</span><span class="p">(</span><span class="n">n</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
    <span class="n">mf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">mf</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="mi">1</span><span class="p">:]))</span>
    <span class="n">min_tsep</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">mf</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">min_tsep</span> <span class="o">&gt;</span> <span class="n">max_tsep_factor</span> <span class="o">*</span> <span class="n">n</span><span class="p">:</span>
      <span class="n">min_tsep</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">max_tsep_factor</span> <span class="o">*</span> <span class="n">n</span><span class="p">)</span>
      <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;signal has very low mean frequency, setting min_tsep = </span><span class="si">{:d}</span><span class="s2">&quot;</span>
      <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">min_tsep</span><span class="p">),</span> <span class="ne">RuntimeWarning</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">lag</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="c1"># calculate the lag as point where the autocorrelation drops to (1 - 1/e)</span>
    <span class="c1"># times its maximum value</span>
    <span class="c1"># note: the Wiener–Khinchin theorem states that the spectral</span>
    <span class="c1"># decomposition of the autocorrelation function of a process is the power</span>
    <span class="c1"># spectrum of that process</span>
    <span class="c1"># =&gt; we can use fft to calculate the autocorrelation</span>
    <span class="n">acorr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">irfft</span><span class="p">(</span><span class="n">f</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">f</span><span class="p">))</span>
    <span class="n">acorr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">acorr</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">eps</span> <span class="o">=</span> <span class="n">acorr</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">e</span><span class="p">)</span>
    <span class="n">lag</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="c1"># small helper function to calculate resulting number of vectors for a</span>
    <span class="c1"># given lag value</span>
    <span class="k">def</span> <span class="nf">nb_neighbors</span><span class="p">(</span><span class="n">lag_value</span><span class="p">):</span>
      <span class="n">min_len</span> <span class="o">=</span> <span class="n">lyap_r_len</span><span class="p">(</span>
        <span class="n">emb_dim</span><span class="o">=</span><span class="n">emb_dim</span><span class="p">,</span> <span class="n">lag</span><span class="o">=</span><span class="n">i</span><span class="p">,</span> <span class="n">trajectory_len</span><span class="o">=</span><span class="n">trajectory_len</span><span class="p">,</span>
        <span class="n">min_tsep</span><span class="o">=</span><span class="n">min_tsep</span>
      <span class="p">)</span>
      <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="n">min_len</span><span class="p">)</span>
    <span class="c1"># find lag</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="p">):</span>
      <span class="n">lag</span> <span class="o">=</span> <span class="n">i</span>
      <span class="k">if</span> <span class="n">acorr</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">eps</span> <span class="ow">or</span> <span class="n">acorr</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">eps</span><span class="p">:</span>
        <span class="k">break</span>
      <span class="k">if</span> <span class="n">nb_neighbors</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">min_neighbors</span><span class="p">:</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;autocorrelation declined too slowly to find suitable lag&quot;</span> \
          <span class="o">+</span> <span class="s2">&quot;, setting lag to </span><span class="si">{}</span><span class="s2">&quot;</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">lag</span><span class="p">),</span> <span class="ne">RuntimeWarning</span><span class="p">)</span>
        <span class="k">break</span>
  <span class="n">min_len</span> <span class="o">=</span> <span class="n">lyap_r_len</span><span class="p">(</span>
    <span class="n">emb_dim</span><span class="o">=</span><span class="n">emb_dim</span><span class="p">,</span> <span class="n">lag</span><span class="o">=</span><span class="n">lag</span><span class="p">,</span> <span class="n">trajectory_len</span><span class="o">=</span><span class="n">trajectory_len</span><span class="p">,</span>
    <span class="n">min_tsep</span><span class="o">=</span><span class="n">min_tsep</span>
  <span class="p">)</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">min_len</span><span class="p">:</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;for emb_dim = </span><span class="si">{}</span><span class="s2">, lag = </span><span class="si">{}</span><span class="s2">, min_tsep = </span><span class="si">{}</span><span class="s2"> and trajectory_len = </span><span class="si">{}</span><span class="s2">&quot;</span> \
      <span class="o">+</span> <span class="s2">&quot; you need at least </span><span class="si">{}</span><span class="s2"> datapoints in your time series&quot;</span>
    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
      <span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">emb_dim</span><span class="p">,</span> <span class="n">lag</span><span class="p">,</span> <span class="n">min_tsep</span><span class="p">,</span> <span class="n">trajectory_len</span><span class="p">,</span> <span class="n">min_len</span><span class="p">),</span>
      <span class="ne">RuntimeWarning</span>
    <span class="p">)</span>
  <span class="c1"># delay embedding</span>
  <span class="n">orbit</span> <span class="o">=</span> <span class="n">delay_embedding</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">emb_dim</span><span class="p">,</span> <span class="n">lag</span><span class="p">)</span>
  <span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">orbit</span><span class="p">)</span>
  <span class="c1"># construct matrix with pairwise distances between vectors in orbit</span>
  <span class="n">dists</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">rowwise_euclidean</span><span class="p">(</span><span class="n">orbit</span><span class="p">,</span> <span class="n">orbit</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">)])</span>
  <span class="c1"># we do not want to consider vectors as neighbor that are less than min_tsep</span>
  <span class="c1"># time steps together =&gt; mask the distances min_tsep to the right and left of</span>
  <span class="c1"># each index by setting them to infinity (will never be considered as nearest</span>
  <span class="c1"># neighbors)</span>
  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
    <span class="n">dists</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span> <span class="o">-</span> <span class="n">min_tsep</span><span class="p">):</span><span class="n">i</span> <span class="o">+</span> <span class="n">min_tsep</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s2">&quot;inf&quot;</span><span class="p">)</span>
  <span class="c1"># check that we have enough data points to continue</span>
  <span class="n">ntraj</span> <span class="o">=</span> <span class="n">m</span> <span class="o">-</span> <span class="n">trajectory_len</span> <span class="o">+</span> <span class="mi">1</span>
  <span class="n">min_traj</span> <span class="o">=</span> <span class="n">min_tsep</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span> <span class="c1"># in each row min_tsep + 1 disances are inf</span>
  <span class="k">if</span> <span class="n">ntraj</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Not enough data points. Need </span><span class="si">{}</span><span class="s2"> additional data points to follow &quot;</span> \
        <span class="o">+</span> <span class="s2">&quot;a complete trajectory.&quot;</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">-</span><span class="n">ntraj</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
  <span class="k">if</span> <span class="n">ntraj</span> <span class="o">&lt;</span> <span class="n">min_traj</span><span class="p">:</span>
    <span class="c1"># not enough data points =&gt; there are rows where all values are inf</span>
    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">dists</span><span class="p">[:</span><span class="n">ntraj</span><span class="p">,</span> <span class="p">:</span><span class="n">ntraj</span><span class="p">]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Not enough data points. At least </span><span class="si">{}</span><span class="s2"> trajectories are required &quot;</span> \
        <span class="o">+</span> <span class="s2">&quot;to find a valid neighbor for each orbit vector with min_tsep=</span><span class="si">{}</span><span class="s2"> &quot;</span> \
        <span class="o">+</span> <span class="s2">&quot;but only </span><span class="si">{}</span><span class="s2"> could be created.&quot;</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">min_traj</span><span class="p">,</span> <span class="n">min_tsep</span><span class="p">,</span> <span class="n">ntraj</span><span class="p">))</span>
  <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">dists</span><span class="p">[:</span><span class="n">ntraj</span><span class="p">,</span> <span class="p">:</span><span class="n">ntraj</span><span class="p">]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
  <span class="c1"># find nearest neighbors (exclude last columns, because these vectors cannot</span>
  <span class="c1"># be followed in time for trajectory_len steps)</span>
  <span class="n">nb_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">dists</span><span class="p">[:</span><span class="n">ntraj</span><span class="p">,</span> <span class="p">:</span><span class="n">ntraj</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
  
  <span class="c1"># build divergence trajectory by averaging distances along the trajectory</span>
  <span class="c1"># over all neighbor pairs</span>
  <span class="n">div_traj</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">trajectory_len</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
  <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">trajectory_len</span><span class="p">):</span>
    <span class="c1"># calculate mean trajectory distance at step k</span>
    <span class="n">indices</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">ntraj</span><span class="p">)</span> <span class="o">+</span> <span class="n">k</span><span class="p">,</span> <span class="n">nb_idx</span> <span class="o">+</span> <span class="n">k</span><span class="p">)</span>
    <span class="n">div_traj_k</span> <span class="o">=</span> <span class="n">dists</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span>
    <span class="c1"># filter entries where distance is zero (would lead to -inf after log)</span>
    <span class="n">nonzero</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">div_traj_k</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nonzero</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
      <span class="c1"># if all entries where zero, we have to use -inf</span>
      <span class="n">div_traj</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">div_traj</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">div_traj_k</span><span class="p">[</span><span class="n">nonzero</span><span class="p">]))</span>
  <span class="c1"># filter -inf entries from mean trajectory</span>
  <span class="n">ks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">trajectory_len</span><span class="p">)</span>
  <span class="n">finite</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">div_traj</span><span class="p">))</span>
  <span class="n">ks</span> <span class="o">=</span> <span class="n">ks</span><span class="p">[</span><span class="n">finite</span><span class="p">]</span>
  <span class="n">div_traj</span> <span class="o">=</span> <span class="n">div_traj</span><span class="p">[</span><span class="n">finite</span><span class="p">]</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ks</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
    <span class="c1"># if all points or all but one point in the trajectory is -inf, we cannot</span>
    <span class="c1"># fit a line through the remaining points =&gt; return -inf as exponent</span>
    <span class="n">poly</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="c1"># normal line fitting</span>
    <span class="n">poly</span> <span class="o">=</span> <span class="n">poly_fit</span><span class="p">(</span><span class="n">ks</span><span class="p">[</span><span class="n">fit_offset</span><span class="p">:],</span> <span class="n">div_traj</span><span class="p">[</span><span class="n">fit_offset</span><span class="p">:],</span> <span class="mi">1</span><span class="p">,</span> <span class="n">fit</span><span class="o">=</span><span class="n">fit</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">debug_plot</span><span class="p">:</span>
    <span class="n">plot_reg</span><span class="p">(</span><span class="n">ks</span><span class="p">[</span><span class="n">fit_offset</span><span class="p">:],</span> <span class="n">div_traj</span><span class="p">[</span><span class="n">fit_offset</span><span class="p">:],</span> <span class="n">poly</span><span class="p">,</span> <span class="s2">&quot;k&quot;</span><span class="p">,</span> <span class="s2">&quot;log(d(k))&quot;</span><span class="p">,</span> <span class="n">fname</span><span class="o">=</span><span class="n">plot_file</span><span class="p">)</span>
  <span class="n">le</span> <span class="o">=</span> <span class="n">poly</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">tau</span>
  <span class="k">if</span> <span class="n">debug_data</span><span class="p">:</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">le</span><span class="p">,</span> <span class="p">(</span><span class="n">ks</span><span class="p">,</span> <span class="n">div_traj</span><span class="p">,</span> <span class="n">poly</span><span class="p">))</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">le</span></div>

<div class="viewcode-block" id="lyap_e_len"><a class="viewcode-back" href="../../nolds.html#nolds.lyap_e_len">[docs]</a><span class="k">def</span> <span class="nf">lyap_e_len</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Helper function that calculates the minimum number of data points required</span>
<span class="sd">  to use lyap_e.</span>

<span class="sd">  Note that none of the required parameters may be set to None.</span>

<span class="sd">  Kwargs:</span>
<span class="sd">    kwargs(dict):</span>
<span class="sd">      arguments used for lyap_e (required: emb_dim, matrix_dim, min_nb</span>
<span class="sd">      and min_tsep)</span>

<span class="sd">  Returns:</span>
<span class="sd">    minimum number of data points required to call lyap_e with the given</span>
<span class="sd">    parameters</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;emb_dim&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;matrix_dim&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
  <span class="c1"># minimum length required to find single orbit vector</span>
  <span class="n">min_len</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;emb_dim&#39;</span><span class="p">]</span>
  <span class="c1"># we need to follow each starting point of an orbit vector for m more steps</span>
  <span class="n">min_len</span> <span class="o">+=</span> <span class="n">m</span>
  <span class="c1"># we need min_tsep * 2 + 1 orbit vectors to find neighbors for each</span>
  <span class="n">min_len</span> <span class="o">+=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;min_tsep&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="mi">2</span>
  <span class="c1"># we need at least min_nb neighbors for each orbit vector</span>
  <span class="n">min_len</span> <span class="o">+=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;min_nb&#39;</span><span class="p">]</span>
  <span class="k">return</span> <span class="n">min_len</span></div>

<div class="viewcode-block" id="lyap_e"><a class="viewcode-back" href="../../nolds.html#nolds.lyap_e">[docs]</a><span class="k">def</span> <span class="nf">lyap_e</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">emb_dim</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">matrix_dim</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">min_nb</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">min_tsep</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">tau</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
           <span class="n">debug_plot</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">debug_data</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">plot_file</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Estimates the Lyapunov exponents for the given data using the algorithm of</span>
<span class="sd">  Eckmann et al. [le_1]_.</span>

<span class="sd">  Recommendations for parameter settings by Eckmann et al.:</span>
<span class="sd">    * long recording time improves accuracy, small tau does not</span>
<span class="sd">    * use large values for emb_dim</span>
<span class="sd">    * matrix_dim should be &#39;somewhat larger than the expected number of</span>
<span class="sd">      positive Lyapunov exponents&#39;</span>
<span class="sd">    * min_nb = min(2 * matrix_dim, matrix_dim + 4)</span>

<span class="sd">  Explanation of Lyapunov exponents:</span>
<span class="sd">    The Lyapunov exponent describes the rate of separation of two</span>
<span class="sd">    infinitesimally close trajectories of a dynamical system in phase space.</span>
<span class="sd">    In a chaotic system, these trajectories diverge exponentially following</span>
<span class="sd">    the equation:</span>

<span class="sd">    \|X(t, X_0) - X(t, X_0 + eps)| = e^(lambda * t) * \|eps|</span>

<span class="sd">    In this equation X(t, X_0) is the trajectory of the system X starting at</span>
<span class="sd">    the point X_0 in phase space at time t. eps is the (infinitesimal)</span>
<span class="sd">    difference vector and lambda is called the Lyapunov exponent. If the</span>
<span class="sd">    system has more than one free variable, the phase space is</span>
<span class="sd">    multidimensional and each dimension has its own Lyapunov exponent. The</span>
<span class="sd">    existence of at least one positive Lyapunov exponent is generally seen as</span>
<span class="sd">    a strong indicator for chaos.</span>

<span class="sd">  Explanation of the Algorithm:</span>
<span class="sd">    To calculate the Lyapunov exponents analytically, the Jacobian of the</span>
<span class="sd">    system is required. The algorithm of Eckmann et al. therefore tries to</span>
<span class="sd">    estimate this Jacobian by reconstructing the dynamics of the system from</span>
<span class="sd">    which the time series was obtained. For this, several steps are required:</span>

<span class="sd">    * Embed the time series [x_1, x_2, ..., x_(N-1)] in an orbit of emb_dim</span>
<span class="sd">      dimensions (map each point x_i of the time series to a vector</span>
<span class="sd">      [x_i, x_(i+1), x_(i+2), ... x_(i+emb_dim-1)]).</span>
<span class="sd">    * For each vector X_i in this orbit find a radius r_i so that at least</span>
<span class="sd">      min_nb other vectors lie within (chebyshev-)distance r_i around X_i.</span>
<span class="sd">      These vectors will be called &quot;neighbors&quot; of X_i.</span>
<span class="sd">    * Find the Matrix T_i that sends points from the neighborhood of X_i to</span>
<span class="sd">      the neighborhood of X_(i+1). To avoid undetermined values in T_i, we</span>
<span class="sd">      construct T_i not with size (emb_dim x emb_dim) but with size</span>
<span class="sd">      (matrix_dim x matrix_dim), so that we have a larger &quot;step size&quot; m in the</span>
<span class="sd">      X_i, which are now defined as X&#39;_i = [x_i, x_(i+m), x_(i+2m),</span>
<span class="sd">      ... x_(i+(matrix_dim-1)*m)]. This means that emb_dim-1 must be divisible</span>
<span class="sd">      by matrix_dim-1. The T_i are then found by a linear least squares fit,</span>
<span class="sd">      assuring that T_i (X_j - X_i) ~= X_(j+m) - X_(i+m) for any X_j in the</span>
<span class="sd">      neighborhood of X_i.</span>
<span class="sd">    * Starting with i = 1 and Q_0 = identity successively decompose the matrix</span>
<span class="sd">      T_i * Q_(i-1) into the matrices Q_i and R_i by a QR-decomposition.</span>
<span class="sd">    * Calculate the Lyapunov exponents from the mean of the logarithm of the</span>
<span class="sd">      diagonal elements of the matrices R_i. To normalize the Lyapunov</span>
<span class="sd">      exponents, they have to be divided by m and by the step size tau of the</span>
<span class="sd">      original time series.</span>

<span class="sd">  References:</span>
<span class="sd">    .. [le_1] J. P. Eckmann, S. O. Kamphorst, D. Ruelle, and S. Ciliberto,</span>
<span class="sd">       “Liapunov exponents from time series,” Physical Review A,</span>
<span class="sd">       vol. 34, no. 6, pp. 4971–4979, 1986.</span>

<span class="sd">  Reference code:</span>
<span class="sd">    .. [le_a] Manfred Füllsack, &quot;Lyapunov exponent&quot;,</span>
<span class="sd">       url: http://systems-sciences.uni-graz.at/etextbook/sw2/lyapunov.html</span>
<span class="sd">    .. [le_b] Steve SIU, Lyapunov Exponents Toolbox (LET),</span>
<span class="sd">       url: http://www.mathworks.com/matlabcentral/fileexchange/233-let/content/LET/findlyap.m</span>
<span class="sd">    .. [le_c] Rainer Hegger, Holger Kantz, and Thomas Schreiber, TISEAN,</span>
<span class="sd">       url: http://www.mpipks-dresden.mpg.de/~tisean/Tisean_3.0.1/index.html</span>

<span class="sd">  Args:</span>
<span class="sd">    data (array-like of float):</span>
<span class="sd">      (scalar) data points</span>

<span class="sd">  Kwargs:</span>
<span class="sd">    emb_dim (int):</span>
<span class="sd">      embedding dimension</span>
<span class="sd">    matrix_dim (int):</span>
<span class="sd">      matrix dimension (emb_dim - 1 must be divisible by matrix_dim - 1)</span>
<span class="sd">    min_nb (int):</span>
<span class="sd">      minimal number of neighbors</span>
<span class="sd">      (default: min(2 * matrix_dim, matrix_dim + 4))</span>
<span class="sd">    min_tsep (int):</span>
<span class="sd">      minimal temporal separation between two &quot;neighbors&quot;</span>
<span class="sd">    tau (float):</span>
<span class="sd">      step size of the data in seconds</span>
<span class="sd">      (normalization scaling factor for exponents)</span>
<span class="sd">    debug_plot (boolean):</span>
<span class="sd">      if True, a histogram matrix of the individual estimates will be shown</span>
<span class="sd">    debug_data (boolean):</span>
<span class="sd">      if True, debugging data will be returned alongside the result</span>
<span class="sd">    plot_file (str):</span>
<span class="sd">      if debug_plot is True and plot_file is not None, the plot will be saved</span>
<span class="sd">      under the given file name instead of directly showing it through</span>
<span class="sd">      ``plt.show()``</span>

<span class="sd">  Returns:</span>
<span class="sd">    float array:</span>
<span class="sd">      array of matrix_dim Lyapunov exponents (positive exponents are indicators</span>
<span class="sd">      for chaos)</span>
<span class="sd">    2d-array of floats:</span>
<span class="sd">      only present if debug_data is True: all estimates for the matrix_dim</span>
<span class="sd">      Lyapunov exponents from the x iterations of R_i. The shape of this debug</span>
<span class="sd">      data is (x, matrix_dim).</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
  <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">emb_dim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="p">(</span><span class="n">matrix_dim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;emb_dim - 1 must be divisible by matrix_dim - 1!&quot;</span><span class="p">)</span>
  <span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="n">emb_dim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="p">(</span><span class="n">matrix_dim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">min_nb</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="c1"># minimal number of neighbors as suggested by Eckmann et al.</span>
    <span class="n">min_nb</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">matrix_dim</span><span class="p">,</span> <span class="n">matrix_dim</span> <span class="o">+</span> <span class="mi">4</span><span class="p">)</span>

  <span class="n">min_len</span> <span class="o">=</span> <span class="n">lyap_e_len</span><span class="p">(</span>
    <span class="n">emb_dim</span><span class="o">=</span><span class="n">emb_dim</span><span class="p">,</span> <span class="n">matrix_dim</span><span class="o">=</span><span class="n">matrix_dim</span><span class="p">,</span> <span class="n">min_nb</span><span class="o">=</span><span class="n">min_nb</span><span class="p">,</span> <span class="n">min_tsep</span><span class="o">=</span><span class="n">min_tsep</span>
  <span class="p">)</span>
  <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">min_len</span><span class="p">:</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> data points are not enough! For emb_dim = </span><span class="si">{}</span><span class="s2">, matrix_dim = </span><span class="si">{}</span><span class="s2">, &quot;</span> \
      <span class="o">+</span> <span class="s2">&quot;min_tsep = </span><span class="si">{}</span><span class="s2"> and min_nb = </span><span class="si">{}</span><span class="s2"> you need at least </span><span class="si">{}</span><span class="s2"> data points &quot;</span> \
      <span class="o">+</span> <span class="s2">&quot;in your time series&quot;</span>
    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
      <span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">emb_dim</span><span class="p">,</span> <span class="n">matrix_dim</span><span class="p">,</span> <span class="n">min_tsep</span><span class="p">,</span> <span class="n">min_nb</span><span class="p">,</span> <span class="n">min_len</span><span class="p">),</span>
      <span class="ne">RuntimeWarning</span>
    <span class="p">)</span>

  <span class="c1"># construct orbit as matrix (e = emb_dim)</span>
  <span class="c1"># x0 x1 x2 ... xe-1</span>
  <span class="c1"># x1 x2 x3 ... xe</span>
  <span class="c1"># x2 x3 x4 ... xe+1</span>
  <span class="c1"># ...</span>

  <span class="c1"># note: we need to be able to step m points further for the beta vector</span>
  <span class="c1">#       =&gt; maximum start index is n - emb_dim - m</span>
  <span class="n">orbit</span> <span class="o">=</span> <span class="n">delay_embedding</span><span class="p">(</span><span class="n">data</span><span class="p">[:</span><span class="o">-</span><span class="n">m</span><span class="p">],</span> <span class="n">emb_dim</span><span class="p">,</span> <span class="n">lag</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">orbit</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">min_nb</span><span class="p">:</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">min_len</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Not enough data points. Need at least </span><span class="si">{}</span><span class="s2"> additional data points &quot;</span> \
        <span class="o">+</span> <span class="s2">&quot;to have min_nb = </span><span class="si">{}</span><span class="s2"> neighbor candidates&quot;</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">min_nb</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">orbit</span><span class="p">),</span> <span class="n">min_nb</span><span class="p">))</span>
  <span class="n">old_Q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="n">matrix_dim</span><span class="p">)</span>
  <span class="n">lexp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">matrix_dim</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float32&quot;</span><span class="p">)</span>
  <span class="n">lexp_counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">lexp</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
  <span class="n">debug_values</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="c1"># TODO reduce number of points to visit?</span>
  <span class="c1"># TODO performance test!</span>
  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">orbit</span><span class="p">)):</span>
    <span class="c1"># find neighbors for each vector in the orbit using the chebyshev distance</span>
    <span class="n">diffs</span> <span class="o">=</span> <span class="n">rowwise_chebyshev</span><span class="p">(</span><span class="n">orbit</span><span class="p">,</span> <span class="n">orbit</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    <span class="c1"># ensure that we do not count the difference of the vector to itself</span>
    <span class="n">diffs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">)</span>
    <span class="c1"># mask all neighbors that are too close in time to the vector itself</span>
    <span class="n">mask_from</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span> <span class="o">-</span> <span class="n">min_tsep</span><span class="p">)</span>
    <span class="n">mask_to</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">diffs</span><span class="p">),</span> <span class="n">i</span> <span class="o">+</span> <span class="n">min_tsep</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">diffs</span><span class="p">[</span><span class="n">mask_from</span><span class="p">:</span><span class="n">mask_to</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
    <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">diffs</span><span class="p">)</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="n">indices</span><span class="p">[</span><span class="n">min_nb</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>  <span class="c1"># index of the min_nb-nearest neighbor</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">diffs</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>  <span class="c1"># corresponding distance</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">r</span><span class="p">):</span>
      <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">min_len</span>
      <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Not enough data points. Orbit vector </span><span class="si">{}</span><span class="s2"> has less than min_nb = &quot;</span> \
          <span class="o">+</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> valid neighbors that are at least min_tsep = </span><span class="si">{}</span><span class="s2"> time steps &quot;</span> \
          <span class="o">+</span> <span class="s2">&quot;away. Input must have at least length </span><span class="si">{}</span><span class="s2">.&quot;</span>
      <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">min_nb</span><span class="p">,</span> <span class="n">min_tsep</span><span class="p">,</span> <span class="n">min_len</span><span class="p">))</span>
    <span class="c1"># there may be more than min_nb vectors at distance r (if multiple vectors</span>
    <span class="c1"># have a distance of exactly r)</span>
    <span class="c1"># =&gt; update index accordingly</span>
    <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">diffs</span> <span class="o">&lt;=</span> <span class="n">r</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># find the matrix T_i that satisifies</span>
    <span class="c1"># T_i (orbit&#39;[j] - orbit&#39;[i]) = (orbit&#39;[j+m] - orbit&#39;[i+m])</span>
    <span class="c1"># for all neighbors j where orbit&#39;[i] = [x[i], x[i+m],</span>
    <span class="c1"># ... x[i + (matrix_dim-1)*m]]</span>

    <span class="c1"># note that T_i has the following form:</span>
    <span class="c1"># 0  1  0  ... 0</span>
    <span class="c1"># 0  0  1  ... 0</span>
    <span class="c1"># ...</span>
    <span class="c1"># a0 a1 a2 ... a(matrix_dim-1)</span>

    <span class="c1"># This is because for all rows except the last one the aforementioned</span>
    <span class="c1"># equation has a clear solution since orbit&#39;[j+m] - orbit&#39;[i+m] =</span>
    <span class="c1"># [x[j+m]-x[i+m], x[j+2*m]-x[i+2*m], ... x[j+d_M*m]-x[i+d_M*m]]</span>
    <span class="c1"># and</span>
    <span class="c1"># orbit&#39;[j] - orbit&#39;[i] =</span>
    <span class="c1"># [x[j]-x[i], x[j+m]-x[i+m], ... x[j+(d_M-1)*m]-x[i+(d_M-1)*m]]</span>
    <span class="c1"># therefore x[j+k*m] - x[i+k*m] is already contained in</span>
    <span class="c1"># orbit&#39;[j] - orbit&#39;[x] for all k from 1 to matrix_dim-1. Only for</span>
    <span class="c1"># k = matrix_dim there is an actual problem to solve.</span>

    <span class="c1"># We can therefore find a = [a0, a1, a2, ... a(matrix_dim-1)] by</span>
    <span class="c1"># formulating a linear least squares problem (mat_X * a = vec_beta)</span>
    <span class="c1"># as follows.</span>

    <span class="c1"># build matrix X for linear least squares (d_M = matrix_dim)</span>
    <span class="c1"># x_j1 - x_i   x_j1+m - x_i+m   ...   x_j1+(d_M-1)m - x_i+(d_M-1)m</span>
    <span class="c1"># x_j2 - x_i   x_j2+m - x_i+m   ...   x_j2+(d_M-1)m - x_i+(d_M-1)m</span>
    <span class="c1"># ...</span>

    <span class="c1"># note: emb_dim = (d_M - 1) * m + 1</span>
    <span class="n">mat_X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">data</span><span class="p">[</span><span class="n">j</span><span class="p">:</span><span class="n">j</span> <span class="o">+</span> <span class="n">emb_dim</span><span class="p">:</span><span class="n">m</span><span class="p">]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">])</span>
    <span class="n">mat_X</span> <span class="o">-=</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span> <span class="o">+</span> <span class="n">emb_dim</span><span class="p">:</span><span class="n">m</span><span class="p">]</span>

    <span class="c1"># build vector beta for linear least squares</span>
    <span class="c1"># x_j1+(d_M)m - x_i+(d_M)m</span>
    <span class="c1"># x_j2+(d_M)m - x_i+(d_M)m</span>
    <span class="c1"># ...</span>
    <span class="k">if</span> <span class="nb">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">indices</span><span class="p">),</span><span class="n">i</span><span class="p">)</span> <span class="o">+</span> <span class="n">matrix_dim</span> <span class="o">*</span> <span class="n">m</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
      <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">min_len</span>
      <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Not enough data points. Cannot follow orbit vector </span><span class="si">{}</span><span class="s2"> for &quot;</span> \
          <span class="o">+</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> (matrix_dim * m) time steps. Input must have at least length &quot;</span> \
          <span class="o">+</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">.&quot;</span>
      <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">matrix_dim</span> <span class="o">*</span> <span class="n">m</span><span class="p">,</span> <span class="n">min_len</span><span class="p">))</span>
    <span class="n">vec_beta</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">indices</span> <span class="o">+</span> <span class="n">matrix_dim</span> <span class="o">*</span> <span class="n">m</span><span class="p">]</span> <span class="o">-</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">matrix_dim</span> <span class="o">*</span> <span class="n">m</span><span class="p">]</span>

    <span class="c1"># perform linear least squares</span>
    <span class="n">a</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">lstsq</span><span class="p">(</span><span class="n">mat_X</span><span class="p">,</span> <span class="n">vec_beta</span><span class="p">,</span> <span class="n">rcond</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
    <span class="c1"># build matrix T</span>
    <span class="c1"># 0  1  0  ... 0</span>
    <span class="c1"># 0  0  1  ... 0</span>
    <span class="c1"># ...</span>
    <span class="c1"># 0  0  0  ... 1</span>
    <span class="c1"># a1 a2 a3 ... a_(d_M)</span>
    <span class="n">mat_T</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">matrix_dim</span><span class="p">,</span> <span class="n">matrix_dim</span><span class="p">))</span>
    <span class="n">mat_T</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="n">matrix_dim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">mat_T</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span>

    <span class="c1"># QR-decomposition of T * old_Q</span>
    <span class="n">mat_Q</span><span class="p">,</span> <span class="n">mat_R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">qr</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">mat_T</span><span class="p">,</span> <span class="n">old_Q</span><span class="p">))</span>
    <span class="c1"># force diagonal of R to be positive</span>
    <span class="c1"># (if QR = A then also QLL&#39;R = A with L&#39; = L^-1)</span>
    <span class="n">sign_diag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">mat_R</span><span class="p">))</span>
    <span class="n">sign_diag</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">sign_diag</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">sign_diag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">sign_diag</span><span class="p">)</span>
    <span class="n">mat_Q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">mat_Q</span><span class="p">,</span> <span class="n">sign_diag</span><span class="p">)</span>
    <span class="n">mat_R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">sign_diag</span><span class="p">,</span> <span class="n">mat_R</span><span class="p">)</span>

    <span class="n">old_Q</span> <span class="o">=</span> <span class="n">mat_Q</span>
    <span class="c1"># successively build sum for Lyapunov exponents</span>
    <span class="n">diag_R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">mat_R</span><span class="p">)</span>
    <span class="c1"># filter zeros in mat_R (would lead to -infs)</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">diag_R</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">lexp_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">diag_R</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float32&quot;</span><span class="p">)</span>
    <span class="n">lexp_i</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">diag_R</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>
    <span class="n">lexp_i</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">diag_R</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
    <span class="k">if</span> <span class="n">debug_plot</span> <span class="ow">or</span> <span class="n">debug_data</span><span class="p">:</span>
      <span class="n">debug_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lexp_i</span> <span class="o">/</span> <span class="n">tau</span> <span class="o">/</span> <span class="n">m</span><span class="p">)</span>
    <span class="n">lexp</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">+=</span> <span class="n">lexp_i</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
    <span class="n">lexp_counts</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
  <span class="c1"># end of loop over orbit vectors</span>
  <span class="c1"># it may happen that all R-matrices contained zeros =&gt; exponent really has</span>
  <span class="c1"># to be -inf</span>
  <span class="k">if</span> <span class="n">debug_plot</span><span class="p">:</span>
    <span class="n">plot_histogram_matrix</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">debug_values</span><span class="p">),</span> <span class="s2">&quot;layp_e&quot;</span><span class="p">,</span> <span class="n">fname</span><span class="o">=</span><span class="n">plot_file</span><span class="p">)</span>
  <span class="c1"># normalize exponents over number of individual mat_Rs</span>
  <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">lexp_counts</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
  <span class="n">lexp</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">/=</span> <span class="n">lexp_counts</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
  <span class="n">lexp</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">lexp_counts</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
  <span class="c1"># normalize with respect to tau</span>
  <span class="n">lexp</span> <span class="o">/=</span> <span class="n">tau</span>
  <span class="c1"># take m into account</span>
  <span class="n">lexp</span> <span class="o">/=</span> <span class="n">m</span>
  <span class="k">if</span> <span class="n">debug_data</span><span class="p">:</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">lexp</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">debug_values</span><span class="p">))</span>
  <span class="k">return</span> <span class="n">lexp</span></div>


<span class="k">def</span> <span class="nf">plot_dists</span><span class="p">(</span><span class="n">dists</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fname</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="c1"># local import to avoid dependency for non-debug use</span>
  <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
  <span class="n">nstd</span> <span class="o">=</span> <span class="mi">3</span>
  <span class="n">nbins</span> <span class="o">=</span> <span class="mi">50</span>
  <span class="n">dists_full</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">dists</span><span class="p">)</span>
  <span class="n">ymax</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dists_full</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.05</span>
  <span class="n">mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dists_full</span><span class="p">)</span>
  <span class="n">std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">dists_full</span><span class="p">)</span>
  <span class="n">rng</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">mean</span> <span class="o">+</span> <span class="n">std</span> <span class="o">*</span> <span class="n">nstd</span><span class="p">)</span>
  <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="n">colors</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;green&quot;</span><span class="p">,</span> <span class="s2">&quot;blue&quot;</span><span class="p">]</span>
  <span class="k">for</span> <span class="n">h</span><span class="p">,</span> <span class="n">bins</span> <span class="ow">in</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">dat</span><span class="p">,</span> <span class="n">nbins</span><span class="p">,</span> <span class="n">rng</span><span class="p">)</span> <span class="k">for</span> <span class="n">dat</span> <span class="ow">in</span> <span class="n">dists</span><span class="p">]:</span>
    <span class="n">bw</span> <span class="o">=</span> <span class="n">bins</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">bins</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">bar</span><span class="p">(</span><span class="n">bins</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">h</span><span class="p">,</span> <span class="n">bw</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;m=</span><span class="si">{:d}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">m</span> <span class="o">+</span> <span class="n">i</span><span class="p">),</span>
            <span class="n">color</span><span class="o">=</span><span class="n">colors</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
    <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
  <span class="n">plt</span><span class="o">.</span><span class="n">axvline</span><span class="p">(</span><span class="n">tolerance</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">)</span>
  <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s2">&quot;best&quot;</span><span class="p">)</span>
  <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;distance&quot;</span><span class="p">)</span>
  <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;count&quot;</span><span class="p">)</span>
  <span class="n">plt</span><span class="o">.</span><span class="n">ylim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">ymax</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">title</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="n">title</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">fname</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>
  <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>


<div class="viewcode-block" id="sampen"><a class="viewcode-back" href="../../nolds.html#nolds.sampen">[docs]</a><span class="k">def</span> <span class="nf">sampen</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">emb_dim</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dist</span><span class="o">=</span><span class="n">rowwise_chebyshev</span><span class="p">,</span>
           <span class="n">debug_plot</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">debug_data</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">plot_file</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Computes the sample entropy of the given data.</span>

<span class="sd">  Explanation of the sample entropy:</span>
<span class="sd">    The sample entropy of a time series is defined as the negative natural</span>
<span class="sd">    logarithm of the conditional probability that two sequences similar for</span>
<span class="sd">    emb_dim points remain similar at the next point, excluding self-matches.</span>

<span class="sd">    A lower value for the sample entropy therefore corresponds to a higher</span>
<span class="sd">    probability indicating more self-similarity.</span>

<span class="sd">  Explanation of the algorithm:</span>
<span class="sd">    The algorithm constructs all subsequences of length emb_dim</span>
<span class="sd">    [s_1, s_2, s_3, ...] and then counts each pair (s_i, s_j) with i != j</span>
<span class="sd">    where dist(s_i, s_j) &lt; tolerance. The same process is repeated for all</span>
<span class="sd">    subsequences of length emb_dim + 1. The sum of similar sequence pairs</span>
<span class="sd">    with length emb_dim + 1 is divided by the sum of similar sequence pairs</span>
<span class="sd">    with length emb_dim. The result of the algorithm is the negative logarithm</span>
<span class="sd">    of this ratio/probability.</span>

<span class="sd">  References:</span>
<span class="sd">    .. [se_1] J. S. Richman and J. R. Moorman, “Physiological time-series</span>
<span class="sd">       analysis using approximate entropy and sample entropy,”</span>
<span class="sd">       American Journal of Physiology-Heart and Circulatory Physiology,</span>
<span class="sd">       vol. 278, no. 6, pp. H2039–H2049, 2000.</span>

<span class="sd">  Reference code:</span>
<span class="sd">    .. [se_a] &quot;sample_entropy&quot; function in R-package &quot;pracma&quot;,</span>
<span class="sd">        url: https://cran.r-project.org/web/packages/pracma/pracma.pdf</span>

<span class="sd">  Args:</span>
<span class="sd">    data (array-like of float):</span>
<span class="sd">      input data</span>

<span class="sd">  Kwargs:</span>
<span class="sd">    emb_dim (int):</span>
<span class="sd">      the embedding dimension (length of vectors to compare)</span>
<span class="sd">    tolerance (float):</span>
<span class="sd">      distance threshold for two template vectors to be considered equal</span>
<span class="sd">      (default: 0.2 * std(data))</span>
<span class="sd">    dist (function (2d-array, 1d-array) -&gt; 1d-array):</span>
<span class="sd">      distance function used to calculate the distance between template</span>
<span class="sd">      vectors. Sampen is defined using ``rowwise_chebyshev``. You should only use</span>
<span class="sd">      something else, if you are sure that you need it.</span>
<span class="sd">    debug_plot (boolean):</span>
<span class="sd">      if True, a histogram of the individual distances for m and m+1</span>
<span class="sd">    debug_data (boolean):</span>
<span class="sd">      if True, debugging data will be returned alongside the result</span>
<span class="sd">    plot_file (str):</span>
<span class="sd">      if debug_plot is True and plot_file is not None, the plot will be saved</span>
<span class="sd">      under the given file name instead of directly showing it through</span>
<span class="sd">      ``plt.show()``</span>

<span class="sd">  Returns:</span>
<span class="sd">    float:</span>
<span class="sd">      the sample entropy of the data (negative logarithm of ratio between</span>
<span class="sd">      similar template vectors of length emb_dim + 1 and emb_dim)</span>
<span class="sd">    [float list, float list]:</span>
<span class="sd">      Lists of lists of the form ``[dists_m, dists_m1]`` containing the distances</span>
<span class="sd">      between template vectors for m (dists_m) and for m + 1 (dists_m1).</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    
  <span class="k">if</span> <span class="n">tolerance</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">tolerance</span> <span class="o">=</span> <span class="mf">0.2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
  <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

  <span class="c1"># build matrix of &quot;template vectors&quot;</span>
  <span class="c1"># (all consecutive subsequences of length m)</span>
  <span class="c1"># x0 x1 x2 x3 ... xm-1</span>
  <span class="c1"># x1 x2 x3 x4 ... xm</span>
  <span class="c1"># x2 x3 x4 x5 ... xm+1</span>
  <span class="c1"># ...</span>
  <span class="c1"># x_n-m-1     ... xn-1</span>

  <span class="c1"># since we need two of these matrices for m = emb_dim and m = emb_dim +1,</span>
  <span class="c1"># we build one that is large enough =&gt; shape (emb_dim+1, n-emb_dim)</span>

  <span class="c1"># note that we ignore the last possible template vector with length emb_dim,</span>
  <span class="c1"># because this vector has no corresponding vector of length m+1 and thus does</span>
  <span class="c1"># not count towards the conditional probability</span>
  <span class="c1"># (otherwise first dimension would be n-emb_dim+1 and not n-emb_dim)</span>
  <span class="n">tVecs</span> <span class="o">=</span> <span class="n">delay_embedding</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="n">emb_dim</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">lag</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
  <span class="n">plot_data</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="n">counts</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="p">[</span><span class="n">emb_dim</span><span class="p">,</span> <span class="n">emb_dim</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]:</span>
    <span class="n">counts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">plot_data</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
    <span class="c1"># get the matrix that we need for the current m</span>
    <span class="n">tVecsM</span> <span class="o">=</span> <span class="n">tVecs</span><span class="p">[:</span><span class="n">n</span> <span class="o">-</span> <span class="n">m</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:</span><span class="n">m</span><span class="p">]</span>
    <span class="c1"># successively calculate distances between each pair of template vectors</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">tVecsM</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
      <span class="n">dsts</span> <span class="o">=</span> <span class="n">dist</span><span class="p">(</span><span class="n">tVecsM</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:],</span> <span class="n">tVecsM</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
      <span class="k">if</span> <span class="n">debug_plot</span><span class="p">:</span>
        <span class="n">plot_data</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">dsts</span><span class="p">)</span>
      <span class="c1"># count how many distances are smaller than the tolerance</span>
      <span class="n">counts</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dsts</span> <span class="o">&lt;</span> <span class="n">tolerance</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">counts</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="c1"># log would be infinite =&gt; cannot determine saen</span>
    <span class="n">saen</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">saen</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">*</span> <span class="n">counts</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">counts</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
  <span class="k">if</span> <span class="n">debug_plot</span><span class="p">:</span>
    <span class="n">plot_dists</span><span class="p">(</span><span class="n">plot_data</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s2">&quot;sampEn = </span><span class="si">{:.3f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">saen</span><span class="p">),</span>
               <span class="n">fname</span><span class="o">=</span><span class="n">plot_file</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">debug_data</span><span class="p">:</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">saen</span><span class="p">,</span> <span class="n">plot_data</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">saen</span></div>


<div class="viewcode-block" id="binary_n"><a class="viewcode-back" href="../../nolds.html#nolds.binary_n">[docs]</a><span class="k">def</span> <span class="nf">binary_n</span><span class="p">(</span><span class="n">total_N</span><span class="p">,</span> <span class="n">min_n</span><span class="o">=</span><span class="mi">50</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Creates a list of values by successively halving the total length total_N</span>
<span class="sd">  until the resulting value is less than min_n.</span>

<span class="sd">  Non-integer results are rounded down.</span>

<span class="sd">  Args:</span>
<span class="sd">    total_N (int):</span>
<span class="sd">      total length</span>
<span class="sd">  Kwargs:</span>
<span class="sd">    min_n (int):</span>
<span class="sd">      minimal length after division</span>

<span class="sd">  Returns:</span>
<span class="sd">    list of integers:</span>
<span class="sd">      total_N/2, total_N/4, total_N/8, ... until total_N/2^i &lt; min_n</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="n">max_exp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">*</span> <span class="n">total_N</span> <span class="o">/</span> <span class="n">min_n</span><span class="p">)</span>
  <span class="n">max_exp</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">max_exp</span><span class="p">))</span>
  <span class="k">return</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">*</span> <span class="n">total_N</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="n">i</span><span class="p">)))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">max_exp</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span></div>


<div class="viewcode-block" id="logarithmic_n"><a class="viewcode-back" href="../../nolds.html#nolds.logarithmic_n">[docs]</a><span class="k">def</span> <span class="nf">logarithmic_n</span><span class="p">(</span><span class="n">min_n</span><span class="p">,</span> <span class="n">max_n</span><span class="p">,</span> <span class="n">factor</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Creates a list of values by successively multiplying a minimum value min_n by</span>
<span class="sd">  a factor &gt; 1 until a maximum value max_n is reached.</span>

<span class="sd">  Non-integer results are rounded down.</span>

<span class="sd">  Args:</span>
<span class="sd">    min_n (float):</span>
<span class="sd">      minimum value (must be &lt; max_n)</span>
<span class="sd">    max_n (float):</span>
<span class="sd">      maximum value (must be &gt; min_n)</span>
<span class="sd">    factor (float):</span>
<span class="sd">      factor used to increase min_n (must be &gt; 1)</span>

<span class="sd">  Returns:</span>
<span class="sd">    list of integers:</span>
<span class="sd">      min_n, min_n * factor, min_n * factor^2, ... min_n * factor^i &lt; max_n</span>
<span class="sd">      without duplicates</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="k">assert</span> <span class="n">max_n</span> <span class="o">&gt;</span> <span class="n">min_n</span>
  <span class="k">assert</span> <span class="n">factor</span> <span class="o">&gt;</span> <span class="mi">1</span>
  <span class="c1"># stop condition: min * f^x = max</span>
  <span class="c1"># =&gt; f^x = max/min</span>
  <span class="c1"># =&gt; x = log(max/min) / log(f)</span>
  <span class="n">max_i</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">*</span> <span class="n">max_n</span> <span class="o">/</span> <span class="n">min_n</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">factor</span><span class="p">)))</span>
  <span class="n">ns</span> <span class="o">=</span> <span class="p">[</span><span class="n">min_n</span><span class="p">]</span>
  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">max_i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">min_n</span> <span class="o">*</span> <span class="p">(</span><span class="n">factor</span> <span class="o">**</span> <span class="n">i</span><span class="p">)))</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="n">ns</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
      <span class="n">ns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">ns</span></div>

<div class="viewcode-block" id="logmid_n"><a class="viewcode-back" href="../../nolds.html#nolds.logmid_n">[docs]</a><span class="k">def</span> <span class="nf">logmid_n</span><span class="p">(</span><span class="n">max_n</span><span class="p">,</span> <span class="n">ratio</span><span class="o">=</span><span class="mi">1</span><span class="o">/</span><span class="mf">4.0</span><span class="p">,</span> <span class="n">nsteps</span><span class="o">=</span><span class="mi">15</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Creates an array of integers that lie evenly spaced in the &quot;middle&quot; of the</span>
<span class="sd">  logarithmic scale from 0 to log(max_n).</span>

<span class="sd">  If max_n is very small and/or nsteps is very large, this may lead to</span>
<span class="sd">  duplicate values which will be removed from the output.</span>

<span class="sd">  This function has benefits in hurst_rs, because it cuts away both very small</span>
<span class="sd">  and very large n, which both can cause problems, and still produces a</span>
<span class="sd">  logarithmically spaced sequence.</span>

<span class="sd">  Args:</span>
<span class="sd">    max_n (int):</span>
<span class="sd">      largest possible output value (should be the sequence length when used in</span>
<span class="sd">      hurst_rs)</span>

<span class="sd">  Kwargs:</span>
<span class="sd">    ratio (float):</span>
<span class="sd">      width of the &quot;middle&quot; of the logarithmic interval relative to log(max_n).</span>
<span class="sd">      For example, for ratio=1/2.0 the logarithm of the resulting values will</span>
<span class="sd">      lie between 0.25 * log(max_n) and 0.75 * log(max_n).</span>
<span class="sd">    nsteps (float):</span>
<span class="sd">      (maximum) number of values to take from the specified range</span>

<span class="sd">  Returns:</span>
<span class="sd">    array of int:</span>
<span class="sd">      a logarithmically spaced sequence of at most nsteps values (may be less,</span>
<span class="sd">      because only unique values are returned)</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="n">l</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">max_n</span><span class="p">)</span>
  <span class="n">span</span> <span class="o">=</span> <span class="n">l</span> <span class="o">*</span> <span class="n">ratio</span>
  <span class="n">start</span> <span class="o">=</span> <span class="n">l</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">ratio</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.5</span>
  <span class="n">midrange</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="mf">1.0</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nsteps</span><span class="p">)</span><span class="o">/</span><span class="n">nsteps</span><span class="o">*</span><span class="n">span</span>
  <span class="n">nvals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">midrange</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;int32&quot;</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">nvals</span><span class="p">)</span></div>

<div class="viewcode-block" id="logarithmic_r"><a class="viewcode-back" href="../../nolds.html#nolds.logarithmic_r">[docs]</a><span class="k">def</span> <span class="nf">logarithmic_r</span><span class="p">(</span><span class="n">min_n</span><span class="p">,</span> <span class="n">max_n</span><span class="p">,</span> <span class="n">factor</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Creates a list of values by successively multiplying a minimum value min_n by</span>
<span class="sd">  a factor &gt; 1 until a maximum value max_n is reached.</span>

<span class="sd">  Args:</span>
<span class="sd">    min_n (float):</span>
<span class="sd">      minimum value (must be &lt; max_n)</span>
<span class="sd">    max_n (float):</span>
<span class="sd">      maximum value (must be &gt; min_n)</span>
<span class="sd">    factor (float):</span>
<span class="sd">      factor used to increase min_n (must be &gt; 1)</span>

<span class="sd">  Returns:</span>
<span class="sd">    list of floats:</span>
<span class="sd">      min_n, min_n * factor, min_n * factor^2, ... min_n * factor^i &lt; max_n</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="k">assert</span> <span class="n">max_n</span> <span class="o">&gt;</span> <span class="n">min_n</span>
  <span class="k">assert</span> <span class="n">factor</span> <span class="o">&gt;</span> <span class="mi">1</span>
  <span class="n">max_i</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">*</span> <span class="n">max_n</span> <span class="o">/</span> <span class="n">min_n</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">factor</span><span class="p">)))</span>
  <span class="k">return</span> <span class="p">[</span><span class="n">min_n</span> <span class="o">*</span> <span class="p">(</span><span class="n">factor</span> <span class="o">**</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">max_i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span></div>


<div class="viewcode-block" id="expected_rs"><a class="viewcode-back" href="../../nolds.html#nolds.expected_rs">[docs]</a><span class="k">def</span> <span class="nf">expected_rs</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Calculates the expected (R/S)_n for white noise for a given n.</span>

<span class="sd">  This is used as a correction factor in the function hurst_rs. It uses the</span>
<span class="sd">  formula of Anis-Lloyd-Peters (see [h_3]_).</span>

<span class="sd">  Args:</span>
<span class="sd">    n (int):</span>
<span class="sd">      the value of n for which the expected (R/S)_n should be calculated</span>

<span class="sd">  Returns:</span>
<span class="sd">    float:</span>
<span class="sd">      expected (R/S)_n for white noise</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="n">front</span> <span class="o">=</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">/</span> <span class="n">n</span>
  <span class="n">i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="p">)</span>
  <span class="n">back</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">n</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span> <span class="o">/</span> <span class="n">i</span><span class="p">))</span>
  <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">340</span><span class="p">:</span>
    <span class="n">middle</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">gamma</span><span class="p">((</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">/</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">/</span> <span class="n">math</span><span class="o">.</span><span class="n">gamma</span><span class="p">(</span><span class="n">n</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">middle</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">n</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">front</span> <span class="o">*</span> <span class="n">middle</span> <span class="o">*</span> <span class="n">back</span></div>

<div class="viewcode-block" id="expected_h"><a class="viewcode-back" href="../../nolds.html#nolds.expected_h">[docs]</a><span class="k">def</span> <span class="nf">expected_h</span><span class="p">(</span><span class="n">nvals</span><span class="p">,</span> <span class="n">fit</span><span class="o">=</span><span class="s2">&quot;RANSAC&quot;</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Uses expected_rs to calculate the expected value for the Hurst exponent h</span>
<span class="sd">  based on the values of n used for the calculation.</span>

<span class="sd">  Args:</span>
<span class="sd">    nvals (iterable of int):</span>
<span class="sd">      the values of n used to calculate the individual (R/S)_n</span>

<span class="sd">  KWargs:</span>
<span class="sd">    fit (str):</span>
<span class="sd">      the fitting method to use for the line fit, either &#39;poly&#39; for normal</span>
<span class="sd">      least squares polynomial fitting or &#39;RANSAC&#39; for RANSAC-fitting which</span>
<span class="sd">      is more robust to outliers</span>

<span class="sd">  Returns:</span>
<span class="sd">    float:</span>
<span class="sd">      expected h for white noise</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="n">rsvals</span> <span class="o">=</span> <span class="p">[</span><span class="n">expected_rs</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">nvals</span><span class="p">]</span>
  <span class="n">poly</span> <span class="o">=</span> <span class="n">poly_fit</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">nvals</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">rsvals</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">fit</span><span class="o">=</span><span class="n">fit</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">poly</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>


<span class="k">def</span> <span class="nf">rs</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">unbiased</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Calculates an individual R/S value in the rescaled range approach for</span>
<span class="sd">  a given n.</span>

<span class="sd">  Note: This is just a helper function for hurst_rs and should not be called</span>
<span class="sd">  directly.</span>

<span class="sd">  Args:</span>
<span class="sd">    data (array-like of float):</span>
<span class="sd">      time series</span>
<span class="sd">    n (float):</span>
<span class="sd">      size of the subseries in which data should be split</span>

<span class="sd">  Kwargs:</span>
<span class="sd">    unbiased (boolean):</span>
<span class="sd">      if True, the standard deviation based on the unbiased variance</span>
<span class="sd">      (1/(N-1) instead of 1/N) will be used. This should be the default choice,</span>
<span class="sd">      since the true mean of the sequences is not known. This parameter should</span>
<span class="sd">      only be changed to recreate results of other implementations.</span>

<span class="sd">  Returns:</span>
<span class="sd">    float:</span>
<span class="sd">      (R/S)_n</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
  <span class="n">total_N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
  <span class="n">m</span> <span class="o">=</span> <span class="n">total_N</span> <span class="o">//</span> <span class="n">n</span> <span class="c1"># number of sequences</span>
  <span class="c1"># cut values at the end of data to make the array divisible by n</span>
  <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[:</span><span class="n">total_N</span> <span class="o">-</span> <span class="p">(</span><span class="n">total_N</span> <span class="o">%</span> <span class="n">n</span><span class="p">)]</span>
  <span class="c1"># split remaining data into subsequences of length n</span>
  <span class="n">seqs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>
  <span class="c1"># calculate means of subsequences</span>
  <span class="n">means</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">seqs</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
  <span class="c1"># normalize subsequences by substracting mean</span>
  <span class="n">y</span> <span class="o">=</span> <span class="n">seqs</span> <span class="o">-</span> <span class="n">means</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">m</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
  <span class="c1"># build cumulative sum of subsequences</span>
  <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
  <span class="c1"># find ranges</span>
  <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
  <span class="c1"># find standard deviation</span>
  <span class="c1"># we should use the unbiased estimator, since we do not know the true mean</span>
  <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">seqs</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">ddof</span><span class="o">=</span><span class="mi">1</span> <span class="k">if</span> <span class="n">unbiased</span> <span class="k">else</span> <span class="mi">0</span><span class="p">)</span>
  <span class="c1"># some ranges may be zero and have to be excluded from the analysis</span>
  <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">r</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
  <span class="n">r</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
  <span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
  <span class="c1"># it may happen that all ranges are zero (if all values in data are equal)</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="c1"># return mean of r/s along subsequence index</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">r</span> <span class="o">/</span> <span class="n">s</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">plot_histogram_matrix</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">fname</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="c1"># local import to avoid dependency for non-debug use</span>
  <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
  <span class="n">nhists</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
  <span class="n">nbins</span> <span class="o">=</span> <span class="mi">25</span>
  <span class="n">ylim</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span>
  <span class="n">nrows</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">nhists</span><span class="p">)))</span>
  <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="n">nrows</span> <span class="o">*</span> <span class="mi">4</span><span class="p">,</span> <span class="n">nrows</span> <span class="o">*</span> <span class="mi">4</span><span class="p">))</span>
  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nhists</span><span class="p">):</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="n">nrows</span><span class="p">,</span> <span class="n">nrows</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">absmax</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">data</span><span class="p">[:,</span> <span class="n">i</span><span class="p">])),</span> <span class="nb">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">data</span><span class="p">[:,</span> <span class="n">i</span><span class="p">])))</span>
    <span class="n">rng</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="n">absmax</span><span class="p">,</span> <span class="n">absmax</span><span class="p">)</span>
    <span class="n">h</span><span class="p">,</span> <span class="n">bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">data</span><span class="p">[:,</span> <span class="n">i</span><span class="p">],</span> <span class="n">nbins</span><span class="p">,</span> <span class="n">rng</span><span class="p">)</span>
    <span class="n">bin_width</span> <span class="o">=</span> <span class="n">bins</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">bins</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">h</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;float32&quot;</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">bar</span><span class="p">(</span><span class="n">bins</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">h</span><span class="p">,</span> <span class="n">bin_width</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">axvline</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">data</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]),</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">ylim</span><span class="p">(</span><span class="n">ylim</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{:s}</span><span class="s2">[</span><span class="si">{:d}</span><span class="s2">]&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">i</span><span class="p">))</span>
  <span class="k">if</span> <span class="n">fname</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>
  <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">plot_reg</span><span class="p">(</span><span class="n">xvals</span><span class="p">,</span> <span class="n">yvals</span><span class="p">,</span> <span class="n">poly</span><span class="p">,</span> <span class="n">x_label</span><span class="o">=</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="n">y_label</span><span class="o">=</span><span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="n">data_label</span><span class="o">=</span><span class="s2">&quot;data&quot;</span><span class="p">,</span>
             <span class="n">reg_label</span><span class="o">=</span><span class="s2">&quot;regression line&quot;</span><span class="p">,</span> <span class="n">fname</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Helper function to plot trend lines for line-fitting approaches. This</span>
<span class="sd">  function will show a plot through ``plt.show()`` and close it after the window</span>
<span class="sd">  has been closed by the user.</span>

<span class="sd">  Args:</span>
<span class="sd">    xvals (list/array of float):</span>
<span class="sd">      list of x-values</span>
<span class="sd">    yvals (list/array of float):</span>
<span class="sd">      list of y-values</span>
<span class="sd">    poly (list/array of float):</span>
<span class="sd">      polynomial parameters as accepted by ``np.polyval``</span>
<span class="sd">  Kwargs:</span>
<span class="sd">    x_label (str):</span>
<span class="sd">      label of the x-axis</span>
<span class="sd">    y_label (str):</span>
<span class="sd">      label of the y-axis</span>
<span class="sd">    data_label (str):</span>
<span class="sd">      label of the data</span>
<span class="sd">    reg_label(str):</span>
<span class="sd">      label of the regression line</span>
<span class="sd">    fname (str):</span>
<span class="sd">      file name (if not None, the plot will be saved to disc instead of</span>
<span class="sd">      showing it though ``plt.show()``)</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="c1"># local import to avoid dependency for non-debug use</span>
  <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
  <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xvals</span><span class="p">,</span> <span class="n">yvals</span><span class="p">,</span> <span class="s2">&quot;bo&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">data_label</span><span class="p">)</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">poly</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xvals</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">polyval</span><span class="p">(</span><span class="n">poly</span><span class="p">,</span> <span class="n">xvals</span><span class="p">),</span> <span class="s2">&quot;r-&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">reg_label</span><span class="p">)</span>
  <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="n">x_label</span><span class="p">)</span>
  <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="n">y_label</span><span class="p">)</span>
  <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s2">&quot;best&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">fname</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>
  <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>


<div class="viewcode-block" id="hurst_rs"><a class="viewcode-back" href="../../nolds.html#nolds.hurst_rs">[docs]</a><span class="k">def</span> <span class="nf">hurst_rs</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">nvals</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fit</span><span class="o">=</span><span class="s2">&quot;RANSAC&quot;</span><span class="p">,</span> <span class="n">debug_plot</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
             <span class="n">debug_data</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">plot_file</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">corrected</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">unbiased</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Calculates the Hurst exponent by a standard rescaled range (R/S) approach.</span>

<span class="sd">  Explanation of Hurst exponent:</span>
<span class="sd">    The Hurst exponent is a measure for the &quot;long-term memory&quot; of a</span>
<span class="sd">    time series, meaning the long statistical dependencies in the data that do</span>
<span class="sd">    not originate from cycles.</span>

<span class="sd">    It originates from H.E. Hursts observations of the problem of long-term</span>
<span class="sd">    storage in water reservoirs. If x_i is the discharge of a river in year i</span>
<span class="sd">    and we observe this discharge for N years, we can calculate the storage</span>
<span class="sd">    capacity that would be required to keep the discharge steady at its mean</span>
<span class="sd">    value.</span>

<span class="sd">    To do so, we first substract the mean over all x_i from the individual</span>
<span class="sd">    x_i to obtain the departures x&#39;_i from the mean for each year i. As the</span>
<span class="sd">    excess or deficit in discharge always carrys over from year i to year i+1,</span>
<span class="sd">    we need to examine the cumulative sum of x&#39;_i, denoted by y_i. This</span>
<span class="sd">    cumulative sum represents the filling of our hypothetical storage. If the</span>
<span class="sd">    sum is above 0, we are storing excess discharge from the river, if it is</span>
<span class="sd">    below zero we have compensated a deficit in discharge by releasing</span>
<span class="sd">    water from the storage. The range (maximum - minimum) R of y_i therefore</span>
<span class="sd">    represents the total capacity required for the storage.</span>

<span class="sd">    Hurst showed that this value follows a steady trend for varying N if it</span>
<span class="sd">    is normalized by the standard deviation sigma over the x_i. Namely he</span>
<span class="sd">    obtained the following formula:</span>

<span class="sd">    R/sigma = (N/2)^K</span>

<span class="sd">    In this equation, K is called the Hurst exponent. Its value is 0.5 for</span>
<span class="sd">    white noise, but becomes greater for time series that exhibit some positive</span>
<span class="sd">    dependency on previous values. For negative dependencies it becomes less</span>
<span class="sd">    than 0.5.</span>

<span class="sd">  Explanation of the algorithm:</span>
<span class="sd">    The rescaled range (R/S) approach is directly derived from Hurst&#39;s</span>
<span class="sd">    definition. The time series of length N is split into non-overlapping</span>
<span class="sd">    subseries of length n. Then, R and S (S = sigma) are calculated for each</span>
<span class="sd">    subseries and the mean is taken over all subseries yielding (R/S)_n. This</span>
<span class="sd">    process is repeated for several lengths n. Finally, the exponent K is</span>
<span class="sd">    obtained by fitting a straight line to the plot of log((R/S)_n) vs log(n).</span>

<span class="sd">    There seems to be no consensus how to chose the subseries lenghts n.</span>
<span class="sd">    This function therefore leaves the choice to the user. The module provides</span>
<span class="sd">    some utility functions for &quot;typical&quot; values:</span>

<span class="sd">      * binary_n: N/2, N/4, N/8, ...</span>
<span class="sd">      * logarithmic_n: min_n, min_n * f, min_n * f^2, ...</span>

<span class="sd">  References:</span>
<span class="sd">    .. [h_1] H. E. Hurst, “The problem of long-term storage in reservoirs,”</span>
<span class="sd">       International Association of Scientific Hydrology. Bulletin, vol. 1,</span>
<span class="sd">       no. 3, pp. 13–27, 1956.</span>
<span class="sd">    .. [h_2] H. E. Hurst, “A suggested statistical model of some time series</span>
<span class="sd">       which occur in nature,” Nature, vol. 180, p. 494, 1957.</span>
<span class="sd">    .. [h_3] R. Weron, “Estimating long-range dependence: finite sample</span>
<span class="sd">       properties and confidence intervals,” Physica A: Statistical Mechanics</span>
<span class="sd">       and its Applications, vol. 312, no. 1, pp. 285–299, 2002.</span>

<span class="sd">  Reference Code:</span>
<span class="sd">    .. [h_a] &quot;hurst&quot; function in R-package &quot;pracma&quot;,</span>
<span class="sd">             url: https://cran.r-project.org/web/packages/pracma/pracma.pdf</span>

<span class="sd">             Note: Pracma yields several estimates of the Hurst exponent, which</span>
<span class="sd">             are listed below. Unless otherwise stated they use the divisors</span>
<span class="sd">             of the length of the sequence as n. The length is reduced by at</span>
<span class="sd">             most 1% to find the value that has the most divisors.</span>

<span class="sd">             * The &quot;Simple R/S&quot; estimate is just log((R/S)_n) / log(n) for </span>
<span class="sd">               n = N.</span>
<span class="sd">             * The &quot;theoretical Hurst exponent&quot; is the value that would be</span>
<span class="sd">               expected of an uncorrected rescaled range approach for random</span>
<span class="sd">               noise of the size of the input data.</span>
<span class="sd">             * The &quot;empirical Hurst exponent&quot; is the uncorrected Hurst exponent</span>
<span class="sd">               obtained by the rescaled range approach.</span>
<span class="sd">             * The &quot;corrected empirical Hurst exponent&quot; is the Anis-Lloyd-Peters</span>
<span class="sd">               corrected Hurst exponent, but with sqrt(1/2 * pi * n) added to</span>
<span class="sd">               the (R/S)_n before the log.</span>
<span class="sd">             * The &quot;corrected R over S Hurst exponent&quot; uses the R-function &quot;lm&quot;</span>
<span class="sd">               instead of pracmas own &quot;polyfit&quot; and uses n = N/2, N/4, N/8, ...</span>
<span class="sd">               by successively halving the subsequences (which means that some</span>
<span class="sd">               subsequences may be one element longer than others). In contrast</span>
<span class="sd">               to its name it does not use the Anis-Lloyd-Peters correction</span>
<span class="sd">               factor.</span>

<span class="sd">             If you want to compare the output of pracma to the output of</span>
<span class="sd">             nolds, the &quot;empirical hurst exponent&quot; is the only measure that</span>
<span class="sd">             exactly corresponds to the Hurst measure implemented in nolds</span>
<span class="sd">             (by choosing corrected=False, fit=&quot;poly&quot; and employing the same</span>
<span class="sd">             strategy for choosing n as the divisors of the (reduced)</span>
<span class="sd">             sequence length).</span>
<span class="sd">    .. [h_b] Rafael Weron, &quot;HURST: MATLAB function to compute the Hurst</span>
<span class="sd">             exponent using R/S Analysis&quot;,</span>
<span class="sd">             url: https://ideas.repec.org/c/wuu/hscode/m11003.html</span>

<span class="sd">             Note: When the same values for nvals are used and fit is set to</span>
<span class="sd">             &quot;poly&quot;, nolds yields exactly the same results as this</span>
<span class="sd">             implementation.</span>
<span class="sd">    .. [h_c] Bill Davidson, &quot;Hurst exponent&quot;,</span>
<span class="sd">             url: http://www.mathworks.com/matlabcentral/fileexchange/9842-hurst-exponent</span>
<span class="sd">    .. [h_d] Tomaso Aste, &quot;Generalized Hurst exponent&quot;,</span>
<span class="sd">             url: http://de.mathworks.com/matlabcentral/fileexchange/30076-generalized-hurst-exponent</span>

<span class="sd">  Args:</span>
<span class="sd">    data (array-like of float):</span>
<span class="sd">      time series</span>
<span class="sd">  Kwargs:</span>
<span class="sd">    nvals (iterable of int):</span>
<span class="sd">      sizes of subseries to use</span>
<span class="sd">      (default: logmid_n(total_N, ratio=1/4.0, nsteps=15) , that is 15</span>
<span class="sd">      logarithmically spaced values in the medium 25% of the logarithmic range)</span>

<span class="sd">      Generally, the choice for n is a trade-off between the length and the</span>
<span class="sd">      number of the subsequences that are used for the calculation of the</span>
<span class="sd">      (R/S)_n. Very low values of n lead to high variance in the ``r`` and ``s``</span>
<span class="sd">      while very high values may leave too few subsequences that the mean along</span>
<span class="sd">      them is still meaningful. Logarithmic spacing makes sense, because it </span>
<span class="sd">      translates to even spacing in the log-log-plot.</span>
<span class="sd">    fit (str):</span>
<span class="sd">      the fitting method to use for the line fit, either &#39;poly&#39; for normal</span>
<span class="sd">      least squares polynomial fitting or &#39;RANSAC&#39; for RANSAC-fitting which</span>
<span class="sd">      is more robust to outliers</span>
<span class="sd">    debug_plot (boolean):</span>
<span class="sd">      if True, a simple plot of the final line-fitting step will be shown</span>
<span class="sd">    debug_data (boolean):</span>
<span class="sd">      if True, debugging data will be returned alongside the result</span>
<span class="sd">    plot_file (str):</span>
<span class="sd">      if debug_plot is True and plot_file is not None, the plot will be saved</span>
<span class="sd">      under the given file name instead of directly showing it through</span>
<span class="sd">      ``plt.show()``</span>
<span class="sd">    corrected (boolean):</span>
<span class="sd">      if True, the Anis-Lloyd-Peters correction factor will be applied to the</span>
<span class="sd">      output according to the expected value for the individual (R/S)_n</span>
<span class="sd">      (see [h_3]_)</span>
<span class="sd">    unbiased (boolean):</span>
<span class="sd">      if True, the standard deviation based on the unbiased variance</span>
<span class="sd">      (1/(N-1) instead of 1/N) will be used. This should be the default choice,</span>
<span class="sd">      since the true mean of the sequences is not known. This parameter should</span>
<span class="sd">      only be changed to recreate results of other implementations.</span>

<span class="sd">  Returns:</span>
<span class="sd">    float:</span>
<span class="sd">      estimated Hurst exponent K using a rescaled range approach (if K = 0.5</span>
<span class="sd">      there are no long-range correlations in the data, if K &lt; 0.5 there are</span>
<span class="sd">      negative long-range correlations, if K &gt; 0.5 there are positive</span>
<span class="sd">      long-range correlations)</span>
<span class="sd">    (1d-vector, 1d-vector, list):</span>
<span class="sd">      only present if debug_data is True: debug data of the form</span>
<span class="sd">      ``(nvals, rsvals, poly)`` where ``nvals`` are the values used for log(n), </span>
<span class="sd">      ``rsvals`` are the corresponding log((R/S)_n) and ``poly`` are the line </span>
<span class="sd">      coefficients (``[slope, intercept]``)</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
  <span class="n">total_N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">nvals</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="c1"># chooses a default value for nvals that will give 15 logarithmically</span>
    <span class="c1"># spaced datapoints leaning towards the middle of the logarithmic range</span>
    <span class="c1"># (since both too small and too large n introduce too much variance)</span>
    <span class="n">nvals</span> <span class="o">=</span> <span class="n">logmid_n</span><span class="p">(</span><span class="n">total_N</span><span class="p">,</span> <span class="n">ratio</span><span class="o">=</span><span class="mi">1</span><span class="o">/</span><span class="mf">4.0</span><span class="p">,</span> <span class="n">nsteps</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>
  <span class="c1"># get individual values for (R/S)_n</span>
  <span class="n">rsvals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">rs</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">unbiased</span><span class="o">=</span><span class="n">unbiased</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">nvals</span><span class="p">])</span>
  <span class="c1"># filter NaNs (zeros should not be possible, because if R is 0 then</span>
  <span class="c1"># S is also zero)</span>
  <span class="n">not_nan</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">rsvals</span><span class="p">))</span>
  <span class="n">rsvals</span> <span class="o">=</span> <span class="n">rsvals</span><span class="p">[</span><span class="n">not_nan</span><span class="p">]</span>
  <span class="n">nvals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">nvals</span><span class="p">)[</span><span class="n">not_nan</span><span class="p">]</span>
  <span class="c1"># it may happen that no rsvals are left (if all values of data are the same)</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">rsvals</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="n">poly</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">debug_plot</span><span class="p">:</span>
      <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Cannot display debug plot, all (R/S)_n are NaN&quot;</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="c1"># fit a line to the logarithm of the obtained (R/S)_n</span>
    <span class="n">xvals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">nvals</span><span class="p">)</span>
    <span class="n">yvals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">rsvals</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">corrected</span><span class="p">:</span>
      <span class="n">yvals</span> <span class="o">-=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">([</span><span class="n">expected_rs</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">nvals</span><span class="p">])</span>
    <span class="n">poly</span> <span class="o">=</span> <span class="n">poly_fit</span><span class="p">(</span><span class="n">xvals</span><span class="p">,</span> <span class="n">yvals</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">fit</span><span class="o">=</span><span class="n">fit</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">debug_plot</span><span class="p">:</span>
      <span class="n">plot_reg</span><span class="p">(</span><span class="n">xvals</span><span class="p">,</span> <span class="n">yvals</span><span class="p">,</span> <span class="n">poly</span><span class="p">,</span> <span class="s2">&quot;log(n)&quot;</span><span class="p">,</span> <span class="s2">&quot;log((R/S)_n)&quot;</span><span class="p">,</span>
               <span class="n">fname</span><span class="o">=</span><span class="n">plot_file</span><span class="p">)</span>
  <span class="c1"># account for correction if necessary</span>
  <span class="n">h</span> <span class="o">=</span> <span class="n">poly</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mf">0.5</span> <span class="k">if</span> <span class="n">corrected</span> <span class="k">else</span> <span class="n">poly</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
  <span class="c1"># return line slope (+ correction) as hurst exponent</span>
  <span class="k">if</span> <span class="n">debug_data</span><span class="p">:</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">nvals</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">rsvals</span><span class="p">),</span> <span class="n">poly</span><span class="p">))</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">h</span></div>

<span class="c1"># TODO implement generalized hurst exponent H_q</span>

<div class="viewcode-block" id="corr_dim"><a class="viewcode-back" href="../../nolds.html#nolds.corr_dim">[docs]</a><span class="k">def</span> <span class="nf">corr_dim</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">emb_dim</span><span class="p">,</span> <span class="n">rvals</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dist</span><span class="o">=</span><span class="n">rowwise_euclidean</span><span class="p">,</span>
             <span class="n">fit</span><span class="o">=</span><span class="s2">&quot;RANSAC&quot;</span><span class="p">,</span> <span class="n">debug_plot</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">debug_data</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">plot_file</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Calculates the correlation dimension with the Grassberger-Procaccia algorithm</span>

<span class="sd">  Explanation of correlation dimension:</span>
<span class="sd">    The correlation dimension is a characteristic measure that can be used</span>
<span class="sd">    to describe the geometry of chaotic attractors. It is defined using the</span>
<span class="sd">    correlation sum C(r) which is the fraction of pairs of points X_i in the</span>
<span class="sd">    phase space whose distance is smaller than r.</span>

<span class="sd">    If the relation between C(r) and r can be described by the power law</span>

<span class="sd">    C(r) ~ r^D</span>

<span class="sd">    then D is called the correlation dimension of the system.</span>

<span class="sd">    In a d-dimensional system, the maximum value for D is d. This value is</span>
<span class="sd">    obtained for systems that expand uniformly in each dimension with time.</span>
<span class="sd">    The lowest possible value is 0 for a system with constant C(r) (i.e. a</span>
<span class="sd">    system that visits just one point in the phase space). Generally if D is</span>
<span class="sd">    lower than d and the system has an attractor, this attractor is called</span>
<span class="sd">    &quot;strange&quot; and D is a measure of this &quot;strangeness&quot;.</span>

<span class="sd">  Explanation of the algorithm:</span>
<span class="sd">    The Grassberger-Procaccia algorithm calculates C(r) for a range of</span>
<span class="sd">    different r and then fits a straight line into the plot of log(C(r))</span>
<span class="sd">    versus log(r).</span>

<span class="sd">    This version of the algorithm is created for one-dimensional (scalar) time</span>
<span class="sd">    series. Therefore, before calculating C(r), a delay embedding of the time</span>
<span class="sd">    series is performed to yield emb_dim dimensional vectors</span>
<span class="sd">    Y_i = [X_i, X_(i+1), X_(i+2), ... X_(i+embd_dim-1)]. Choosing a higher</span>
<span class="sd">    value for emb_dim allows to reconstruct higher dimensional dynamics and</span>
<span class="sd">    avoids &quot;systematic errors due to corrections to scaling&quot;.</span>

<span class="sd">  References:</span>
<span class="sd">    .. [cd_1] P. Grassberger and I. Procaccia, “Characterization of strange</span>
<span class="sd">              attractors,” Physical review letters, vol. 50, no. 5, p. 346,</span>
<span class="sd">              1983.</span>
<span class="sd">    .. [cd_2] P. Grassberger and I. Procaccia, “Measuring the strangeness of</span>
<span class="sd">              strange attractors,” Physica D: Nonlinear Phenomena, vol. 9,</span>
<span class="sd">              no. 1, pp. 189–208, 1983.</span>
<span class="sd">    .. [cd_3] P. Grassberger, “Grassberger-Procaccia algorithm,”</span>
<span class="sd">              Scholarpedia, vol. 2, no. 5, p. 3043.</span>
<span class="sd">              urL: http://www.scholarpedia.org/article/Grassberger-Procaccia_algorithm</span>

<span class="sd">  Reference Code:</span>
<span class="sd">    .. [cd_a] &quot;corrDim&quot; function in R package &quot;fractal&quot;,</span>
<span class="sd">              url: https://cran.r-project.org/web/packages/fractal/fractal.pdf</span>
<span class="sd">    .. [cd_b] Peng Yuehua, &quot;Correlation dimension&quot;,</span>
<span class="sd">              url: http://de.mathworks.com/matlabcentral/fileexchange/24089-correlation-dimension</span>

<span class="sd">  Args:</span>
<span class="sd">    data (array-like of float):</span>
<span class="sd">      time series of data points</span>
<span class="sd">    emb_dim (int):</span>
<span class="sd">      embedding dimension</span>
<span class="sd">  Kwargs:</span>
<span class="sd">    rvals (iterable of float):</span>
<span class="sd">      list of values for to use for r</span>
<span class="sd">      (default: logarithmic_r(0.1 * std, 0.5 * std, 1.03))</span>
<span class="sd">    dist (function (2d-array, 1d-array) -&gt; 1d-array):</span>
<span class="sd">      row-wise difference function</span>
<span class="sd">    fit (str):</span>
<span class="sd">      the fitting method to use for the line fit, either &#39;poly&#39; for normal</span>
<span class="sd">      least squares polynomial fitting or &#39;RANSAC&#39; for RANSAC-fitting which</span>
<span class="sd">      is more robust to outliers</span>
<span class="sd">    debug_plot (boolean):</span>
<span class="sd">      if True, a simple plot of the final line-fitting step will be shown</span>
<span class="sd">    debug_data (boolean):</span>
<span class="sd">      if True, debugging data will be returned alongside the result</span>
<span class="sd">    plot_file (str):</span>
<span class="sd">      if debug_plot is True and plot_file is not None, the plot will be saved</span>
<span class="sd">      under the given file name instead of directly showing it through</span>
<span class="sd">      ``plt.show()``</span>

<span class="sd">  Returns:</span>
<span class="sd">    float:</span>
<span class="sd">      correlation dimension as slope of the line fitted to log(r) vs log(C(r))</span>
<span class="sd">    (1d-vector, 1d-vector, list):</span>
<span class="sd">      only present if debug_data is True: debug data of the form</span>
<span class="sd">      ``(rvals, csums, poly)`` where ``rvals`` are the values used for log(r), </span>
<span class="sd">      ``csums`` are the corresponding log(C(r)) and ``poly`` are the line </span>
<span class="sd">      coefficients (``[slope, intercept]``)</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

  <span class="c1"># TODO what are good values for r?</span>
  <span class="c1"># TODO do this for multiple values of emb_dim?</span>
  <span class="k">if</span> <span class="n">rvals</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">sd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="n">rvals</span> <span class="o">=</span> <span class="n">logarithmic_r</span><span class="p">(</span><span class="mf">0.1</span> <span class="o">*</span> <span class="n">sd</span><span class="p">,</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">sd</span><span class="p">,</span> <span class="mf">1.03</span><span class="p">)</span>
  <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
  <span class="n">orbit</span> <span class="o">=</span> <span class="n">delay_embedding</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">emb_dim</span><span class="p">,</span> <span class="n">lag</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
  <span class="n">dists</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">dist</span><span class="p">(</span><span class="n">orbit</span><span class="p">,</span> <span class="n">orbit</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">orbit</span><span class="p">))])</span>
  <span class="n">csums</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">rvals</span><span class="p">:</span>
    <span class="n">s</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="n">n</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dists</span> <span class="o">&lt;</span> <span class="n">r</span><span class="p">)</span>
    <span class="n">csums</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
  <span class="n">csums</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">csums</span><span class="p">)</span>
  <span class="c1"># filter zeros from csums</span>
  <span class="n">nonzero</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">csums</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
  <span class="n">rvals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">rvals</span><span class="p">)[</span><span class="n">nonzero</span><span class="p">]</span>
  <span class="n">csums</span> <span class="o">=</span> <span class="n">csums</span><span class="p">[</span><span class="n">nonzero</span><span class="p">]</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">csums</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="c1"># all sums are zero =&gt; we cannot fit a line</span>
    <span class="n">poly</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">]</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">poly</span> <span class="o">=</span> <span class="n">poly_fit</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">rvals</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">csums</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">debug_plot</span><span class="p">:</span>
    <span class="n">plot_reg</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">rvals</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">csums</span><span class="p">),</span> <span class="n">poly</span><span class="p">,</span> <span class="s2">&quot;log(r)&quot;</span><span class="p">,</span> <span class="s2">&quot;log(C(r))&quot;</span><span class="p">,</span>
             <span class="n">fname</span><span class="o">=</span><span class="n">plot_file</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">debug_data</span><span class="p">:</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">poly</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">rvals</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">csums</span><span class="p">),</span> <span class="n">poly</span><span class="p">))</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">poly</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>

<div class="viewcode-block" id="dfa"><a class="viewcode-back" href="../../nolds.html#nolds.dfa">[docs]</a><span class="k">def</span> <span class="nf">dfa</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">nvals</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">overlap</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">fit_trend</span><span class="o">=</span><span class="s2">&quot;poly&quot;</span><span class="p">,</span>
        <span class="n">fit_exp</span><span class="o">=</span><span class="s2">&quot;RANSAC&quot;</span><span class="p">,</span> <span class="n">debug_plot</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">debug_data</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">plot_file</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Performs a detrended fluctuation analysis (DFA) on the given data</span>

<span class="sd">  Recommendations for parameter settings by Hardstone et al.:</span>
<span class="sd">    * nvals should be equally spaced on a logarithmic scale so that each window</span>
<span class="sd">      scale hase the same weight</span>
<span class="sd">    * min(nvals) &lt; 4 does not make much sense as fitting a polynomial (even if</span>
<span class="sd">      it is only of order 1) to 3 or less data points is very prone.</span>
<span class="sd">    * max(nvals) &gt; len(data) / 10 does not make much sense as we will then have</span>
<span class="sd">      less than 10 windows to calculate the average fluctuation</span>
<span class="sd">    * use overlap=True to obtain more windows and therefore better statistics</span>
<span class="sd">      (at an increased computational cost)</span>

<span class="sd">  Explanation of DFA:</span>
<span class="sd">    Detrended fluctuation analysis, much like the Hurst exponent, is used to</span>
<span class="sd">    find long-term statistical dependencies in time series.</span>

<span class="sd">    The idea behind DFA originates from the definition of self-affine</span>
<span class="sd">    processes. A process X is said to be self-affine if the standard deviation</span>
<span class="sd">    of the values within a window of length n changes with the window length</span>
<span class="sd">    factor L in a power law:</span>

<span class="sd">    std(X,L * n) = L^H * std(X, n)</span>

<span class="sd">    where std(X, k) is the standard deviation of the process X calculated over</span>
<span class="sd">    windows of size k. In this equation, H is called the Hurst parameter, which</span>
<span class="sd">    behaves indeed very similar to the Hurst exponent.</span>

<span class="sd">    Like the Hurst exponent, H can be obtained from a time series by</span>
<span class="sd">    calculating std(X,n) for different n and fitting a straight line to the</span>
<span class="sd">    plot of log(std(X,n)) versus log(n).</span>

<span class="sd">    To calculate a single std(X,n), the time series is split into windows of</span>
<span class="sd">    equal length n, so that the ith window of this size has the form</span>

<span class="sd">    W_(n,i) = [x_i, x_(i+1), x_(i+2), ... x_(i+n-1)]</span>

<span class="sd">    The value std(X,n) is then obtained by calculating std(W_(n,i)) for each i</span>
<span class="sd">    and averaging the obtained values over i.</span>

<span class="sd">    The aforementioned definition of self-affinity, however, assumes that the</span>
<span class="sd">    process is  non-stationary (i.e. that the standard deviation changes over</span>
<span class="sd">    time) and it is highly influenced by local and global trends of the time</span>
<span class="sd">    series.</span>

<span class="sd">    To overcome these problems, an estimate alpha of H is calculated by using a</span>
<span class="sd">    &quot;walk&quot; or &quot;signal profile&quot; instead of the raw time series. This walk is</span>
<span class="sd">    obtained by substracting the mean and then taking the cumulative sum of the</span>
<span class="sd">    original time series. The local trends are removed for each window</span>
<span class="sd">    separately by fitting a polynomial p_(n,i) to the window W_(n,i) and then</span>
<span class="sd">    calculating W&#39;_(n,i) = W_(n,i) - p_(n,i) (element-wise substraction).</span>

<span class="sd">    We then calculate std(X,n) as before only using the &quot;detrended&quot; window</span>
<span class="sd">    W&#39;_(n,i) instead of W_(n,i). Instead of H we obtain the parameter alpha</span>
<span class="sd">    from the line fitting.</span>

<span class="sd">    For alpha &lt; 1 the underlying process is stationary and can be modelled as</span>
<span class="sd">    fractional Gaussian noise with H = alpha. This means for alpha = 0.5 we</span>
<span class="sd">    have no correlation or &quot;memory&quot;, for 0.5 &lt; alpha &lt; 1 we have a memory with</span>
<span class="sd">    positive correlation and for alpha &lt; 0.5 the correlation is negative.</span>

<span class="sd">    For alpha &gt; 1 the underlying process is non-stationary and can be modeled</span>
<span class="sd">    as fractional Brownian motion with H = alpha - 1.</span>

<span class="sd">  References:</span>
<span class="sd">    .. [dfa_1] C.-K. Peng, S. V. Buldyrev, S. Havlin, M. Simons,</span>
<span class="sd">               H. E. Stanley, and A. L. Goldberger, “Mosaic organization of</span>
<span class="sd">               DNA nucleotides,” Physical Review E, vol. 49, no. 2, 1994.</span>
<span class="sd">    .. [dfa_2] R. Hardstone, S.-S. Poil, G. Schiavone, R. Jansen,</span>
<span class="sd">               V. V. Nikulin, H. D. Mansvelder, and K. Linkenkaer-Hansen,</span>
<span class="sd">               “Detrended fluctuation analysis: A scale-free view on neuronal</span>
<span class="sd">               oscillations,” Frontiers in Physiology, vol. 30, 2012.</span>

<span class="sd">  Reference code:</span>
<span class="sd">    .. [dfa_a] Peter Jurica, &quot;Introduction to MDFA in Python&quot;,</span>
<span class="sd">       url: http://bsp.brain.riken.jp/~juricap/mdfa/mdfaintro.html</span>
<span class="sd">    .. [dfa_b] JE Mietus, &quot;dfa&quot;,</span>
<span class="sd">       url: https://www.physionet.org/physiotools/dfa/dfa-1.htm</span>
<span class="sd">    .. [dfa_c] &quot;DFA&quot; function in R package &quot;fractal&quot;</span>

<span class="sd">  Args:</span>
<span class="sd">    data (array-like of float):</span>
<span class="sd">      time series</span>
<span class="sd">  Kwargs:</span>
<span class="sd">    nvals (iterable of int):</span>
<span class="sd">      subseries sizes at which to calculate fluctuation</span>
<span class="sd">      (default: logarithmic_n(4, 0.1*len(data), 1.2))</span>
<span class="sd">    overlap (boolean):</span>
<span class="sd">      if True, the windows W_(n,i) will have a 50% overlap,</span>
<span class="sd">      otherwise non-overlapping windows will be used</span>
<span class="sd">    order (int):</span>
<span class="sd">      (polynomial) order of trend to remove</span>
<span class="sd">    fit_trend (str):</span>
<span class="sd">      the fitting method to use for fitting the trends, either &#39;poly&#39;</span>
<span class="sd">      for normal least squares polynomial fitting or &#39;RANSAC&#39; for</span>
<span class="sd">      RANSAC-fitting which is more robust to outliers but also tends to</span>
<span class="sd">      lead to unstable results</span>
<span class="sd">    fit_exp (str):</span>
<span class="sd">      the fitting method to use for the line fit, either &#39;poly&#39; for normal</span>
<span class="sd">      least squares polynomial fitting or &#39;RANSAC&#39; for RANSAC-fitting which</span>
<span class="sd">      is more robust to outliers</span>
<span class="sd">    debug_plot (boolean):</span>
<span class="sd">      if True, a simple plot of the final line-fitting step will be shown</span>
<span class="sd">    debug_data (boolean):</span>
<span class="sd">      if True, debugging data will be returned alongside the result</span>
<span class="sd">    plot_file (str):</span>
<span class="sd">      if debug_plot is True and plot_file is not None, the plot will be saved</span>
<span class="sd">      under the given file name instead of directly showing it through</span>
<span class="sd">      ``plt.show()``</span>
<span class="sd">  Returns:</span>
<span class="sd">    float:</span>
<span class="sd">      the estimate alpha for the Hurst parameter (alpha &lt; 1: stationary</span>
<span class="sd">      process similar to fractional Gaussian noise with H = alpha,</span>
<span class="sd">      alpha &gt; 1: non-stationary process similar to fractional Brownian</span>
<span class="sd">      motion with H = alpha - 1)</span>
<span class="sd">    (1d-vector, 1d-vector, list):</span>
<span class="sd">      only present if debug_data is True: debug data of the form</span>
<span class="sd">      ``(nvals, fluctuations, poly)`` where ``nvals`` are the values used for</span>
<span class="sd">      log(n), ``fluctuations`` are the corresponding log(std(X,n)) and ``poly``</span>
<span class="sd">      are the line coefficients (``[slope, intercept]``)</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
  <span class="n">total_N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">nvals</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">total_N</span> <span class="o">&gt;</span> <span class="mi">70</span><span class="p">:</span>
      <span class="n">nvals</span> <span class="o">=</span> <span class="n">logarithmic_n</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mf">0.1</span> <span class="o">*</span> <span class="n">total_N</span><span class="p">,</span> <span class="mf">1.2</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">total_N</span> <span class="o">&gt;</span> <span class="mi">10</span><span class="p">:</span>
      <span class="n">nvals</span> <span class="o">=</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">nvals</span> <span class="o">=</span> <span class="p">[</span><span class="n">total_N</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="n">total_N</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
      <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;choosing nvals = </span><span class="si">{}</span><span class="s2"> , DFA with less than ten data points is &quot;</span> \
          <span class="o">+</span> <span class="s2">&quot;extremely unreliable&quot;</span>
      <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">nvals</span><span class="p">),</span><span class="ne">RuntimeWarning</span><span class="p">)</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nvals</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;at least two nvals are needed&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">nvals</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;nvals must be at least two&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">nvals</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">total_N</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;nvals cannot be larger than the input size&quot;</span><span class="p">)</span>
  <span class="c1"># create the signal profile</span>
  <span class="c1"># (cumulative sum of deviations from the mean =&gt; &quot;walk&quot;)</span>
  <span class="n">walk</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">data</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
  <span class="n">fluctuations</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">nvals</span><span class="p">:</span>
    <span class="k">assert</span> <span class="n">n</span> <span class="o">&gt;=</span> <span class="mi">2</span>
    <span class="c1"># subdivide data into chunks of size n</span>
    <span class="k">if</span> <span class="n">overlap</span><span class="p">:</span>
      <span class="c1"># step size n/2 instead of n</span>
      <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">walk</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span> <span class="o">+</span> <span class="n">n</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">walk</span><span class="p">)</span> <span class="o">-</span> <span class="n">n</span><span class="p">,</span> <span class="n">n</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)])</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="c1"># non-overlapping windows =&gt; we can simply do a reshape</span>
      <span class="n">d</span> <span class="o">=</span> <span class="n">walk</span><span class="p">[:</span><span class="n">total_N</span> <span class="o">-</span> <span class="p">(</span><span class="n">total_N</span> <span class="o">%</span> <span class="n">n</span><span class="p">)]</span>
      <span class="n">d</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">total_N</span> <span class="o">//</span> <span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>
    <span class="c1"># calculate local trends as polynomes</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="n">tpoly</span> <span class="o">=</span> <span class="p">[</span><span class="n">poly_fit</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">order</span><span class="p">,</span> <span class="n">fit</span><span class="o">=</span><span class="n">fit_trend</span><span class="p">)</span>
             <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">d</span><span class="p">))]</span>
    <span class="n">tpoly</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">tpoly</span><span class="p">)</span>
    <span class="n">trend</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">polyval</span><span class="p">(</span><span class="n">tpoly</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">d</span><span class="p">))])</span>
    <span class="c1"># calculate standard deviation (&quot;fluctuation&quot;) of walks in d around trend</span>
    <span class="n">flucs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">d</span> <span class="o">-</span> <span class="n">trend</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">n</span><span class="p">)</span>
    <span class="c1"># calculate mean fluctuation over all subsequences</span>
    <span class="n">f_n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">flucs</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">flucs</span><span class="p">)</span>
    <span class="n">fluctuations</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">f_n</span><span class="p">)</span>
  <span class="n">fluctuations</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">fluctuations</span><span class="p">)</span>
  <span class="c1"># filter zeros from fluctuations</span>
  <span class="n">nonzero</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">fluctuations</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
  <span class="n">nvals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">nvals</span><span class="p">)[</span><span class="n">nonzero</span><span class="p">]</span>
  <span class="n">fluctuations</span> <span class="o">=</span> <span class="n">fluctuations</span><span class="p">[</span><span class="n">nonzero</span><span class="p">]</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">fluctuations</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="c1"># all fluctuations are zero =&gt; we cannot fit a line</span>
    <span class="n">poly</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">]</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">poly</span> <span class="o">=</span> <span class="n">poly_fit</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">nvals</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">fluctuations</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span>
                    <span class="n">fit</span><span class="o">=</span><span class="n">fit_exp</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">debug_plot</span><span class="p">:</span>
    <span class="n">plot_reg</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">nvals</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">fluctuations</span><span class="p">),</span> <span class="n">poly</span><span class="p">,</span> <span class="s2">&quot;log(n)&quot;</span><span class="p">,</span> <span class="s2">&quot;std(X,n)&quot;</span><span class="p">,</span>
             <span class="n">fname</span><span class="o">=</span><span class="n">plot_file</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">debug_data</span><span class="p">:</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">poly</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">nvals</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">fluctuations</span><span class="p">),</span> <span class="n">poly</span><span class="p">))</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">poly</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper"><div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  <li><a href="../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2016-2018, Christopher Schölzel.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.6.6</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.10</a>
      
    </div>

    

    
  </body>
</html>