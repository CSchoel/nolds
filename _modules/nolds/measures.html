<!DOCTYPE html>

<html lang="en" data-content_root="../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>nolds.measures &#8212; Nolds 0.6.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../../_static/basic.css?v=c058f7c8" />
    <link rel="stylesheet" type="text/css" href="../../_static/alabaster.css?v=19a2ea7e" />
    <script src="../../_static/documentation_options.js?v=8fa8b3e9"></script>
    <script src="../../_static/doctools.js?v=9a2dae69"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for nolds.measures</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="p">(</span><span class="n">absolute_import</span><span class="p">,</span> <span class="n">division</span><span class="p">,</span>
                        <span class="n">print_function</span><span class="p">,</span> <span class="n">unicode_literals</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">builtins</span> <span class="kn">import</span> <span class="p">(</span>
  <span class="nb">bytes</span><span class="p">,</span> <span class="nb">dict</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">list</span><span class="p">,</span> <span class="nb">object</span><span class="p">,</span> <span class="nb">range</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="n">ascii</span><span class="p">,</span> <span class="nb">chr</span><span class="p">,</span> <span class="nb">hex</span><span class="p">,</span> <span class="nb">input</span><span class="p">,</span> <span class="nb">next</span><span class="p">,</span>
  <span class="nb">oct</span><span class="p">,</span> <span class="nb">open</span><span class="p">,</span> <span class="nb">pow</span><span class="p">,</span> <span class="nb">round</span><span class="p">,</span> <span class="nb">super</span><span class="p">,</span> <span class="nb">filter</span><span class="p">,</span> <span class="nb">map</span><span class="p">,</span> <span class="nb">zip</span>
<span class="p">)</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">math</span>


<span class="k">def</span> <span class="nf">rowwise_chebyshev</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
  <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">y</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">rowwise_euclidean</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
  <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">x</span> <span class="o">-</span> <span class="n">y</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">poly_fit</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">degree</span><span class="p">,</span> <span class="n">fit</span><span class="o">=</span><span class="s2">&quot;RANSAC&quot;</span><span class="p">):</span>
  <span class="c1"># check if we can use RANSAC</span>
  <span class="k">if</span> <span class="n">fit</span> <span class="o">==</span> <span class="s2">&quot;RANSAC&quot;</span><span class="p">:</span>
    <span class="k">try</span><span class="p">:</span>
      <span class="c1"># ignore ImportWarnings in sklearn</span>
      <span class="k">with</span> <span class="n">warnings</span><span class="o">.</span><span class="n">catch_warnings</span><span class="p">():</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">simplefilter</span><span class="p">(</span><span class="s2">&quot;ignore&quot;</span><span class="p">,</span> <span class="ne">ImportWarning</span><span class="p">)</span>
        <span class="kn">import</span> <span class="nn">sklearn.linear_model</span> <span class="k">as</span> <span class="nn">sklin</span>
        <span class="kn">import</span> <span class="nn">sklearn.preprocessing</span> <span class="k">as</span> <span class="nn">skpre</span>
    <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
      <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
        <span class="s2">&quot;fitting mode &#39;RANSAC&#39; requires the package sklearn, using&quot;</span>
        <span class="o">+</span> <span class="s2">&quot; &#39;poly&#39; instead&quot;</span><span class="p">,</span>
        <span class="ne">RuntimeWarning</span><span class="p">)</span>
      <span class="n">fit</span> <span class="o">=</span> <span class="s2">&quot;poly&quot;</span>

  <span class="k">if</span> <span class="n">fit</span> <span class="o">==</span> <span class="s2">&quot;poly&quot;</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">polyfit</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">degree</span><span class="p">)</span>
  <span class="k">elif</span> <span class="n">fit</span> <span class="o">==</span> <span class="s2">&quot;RANSAC&quot;</span><span class="p">:</span>
    <span class="n">model</span> <span class="o">=</span> <span class="n">sklin</span><span class="o">.</span><span class="n">RANSACRegressor</span><span class="p">(</span><span class="n">sklin</span><span class="o">.</span><span class="n">LinearRegression</span><span class="p">(</span><span class="n">fit_intercept</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>
    <span class="n">xdat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">xdat</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
      <span class="c1"># interpret 1d-array as list of len(x) samples instead of</span>
      <span class="c1"># one sample of length len(x)</span>
      <span class="n">xdat</span> <span class="o">=</span> <span class="n">xdat</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">polydat</span> <span class="o">=</span> <span class="n">skpre</span><span class="o">.</span><span class="n">PolynomialFeatures</span><span class="p">(</span><span class="n">degree</span><span class="p">)</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">xdat</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
      <span class="n">model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">polydat</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
      <span class="n">coef</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">estimator_</span><span class="o">.</span><span class="n">coef_</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
      <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
        <span class="s2">&quot;RANSAC did not reach consensus, &quot;</span>
        <span class="o">+</span> <span class="s2">&quot;using numpy&#39;s polyfit&quot;</span><span class="p">,</span>
        <span class="ne">RuntimeWarning</span><span class="p">)</span>
      <span class="n">coef</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">polyfit</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">degree</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">coef</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;invalid fitting mode (</span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">fit</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">delay_embedding</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">emb_dim</span><span class="p">,</span> <span class="n">lag</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Perform a time-delay embedding of a time series</span>

<span class="sd">  Args:</span>
<span class="sd">    data (array-like):</span>
<span class="sd">      the data that should be embedded</span>
<span class="sd">    emb_dim (int):</span>
<span class="sd">      the embedding dimension</span>
<span class="sd">  Kwargs:</span>
<span class="sd">    lag (int):</span>
<span class="sd">      the lag between elements in the embedded vectors</span>

<span class="sd">  Returns:</span>
<span class="sd">    emb_dim x m array:</span>
<span class="sd">      matrix of embedded vectors of the form</span>
<span class="sd">      [data[i], data[i+lag], data[i+2*lag], ... data[i+(emb_dim-1)*lag]]</span>
<span class="sd">      for i in 0 to m-1 (m = len(data)-(emb_dim-1)*lag)</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
  <span class="n">min_len</span> <span class="o">=</span> <span class="p">(</span><span class="n">emb_dim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">lag</span> <span class="o">+</span> <span class="mi">1</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">min_len</span><span class="p">:</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;cannot embed data of length </span><span class="si">{}</span><span class="s2"> with embedding dimension </span><span class="si">{}</span><span class="s2"> &quot;</span> \
        <span class="o">+</span> <span class="s2">&quot;and lag </span><span class="si">{}</span><span class="s2">, minimum required length is </span><span class="si">{}</span><span class="s2">&quot;</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="n">emb_dim</span><span class="p">,</span> <span class="n">lag</span><span class="p">,</span> <span class="n">min_len</span><span class="p">))</span>
  <span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">-</span> <span class="n">min_len</span> <span class="o">+</span> <span class="mi">1</span>
  <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">emb_dim</span><span class="p">)</span> <span class="o">*</span> <span class="n">lag</span><span class="p">],</span> <span class="n">m</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
  <span class="n">indices</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">m</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">m</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
  <span class="k">return</span> <span class="n">data</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span>


<div class="viewcode-block" id="lyap_r_len">
<a class="viewcode-back" href="../../nolds.html#nolds.lyap_r_len">[docs]</a>
<span class="k">def</span> <span class="nf">lyap_r_len</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Helper function that calculates the minimum number of data points required</span>
<span class="sd">  to use lyap_r.</span>

<span class="sd">  Note that none of the required parameters may be set to None.</span>

<span class="sd">  Kwargs:</span>
<span class="sd">    kwargs(dict):</span>
<span class="sd">      arguments used for lyap_r (required: emb_dim, lag, trajectory_len and</span>
<span class="sd">      min_tsep)</span>

<span class="sd">  Returns:</span>
<span class="sd">    minimum number of data points required to call lyap_r with the given</span>
<span class="sd">    parameters</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="c1"># minimum length required to find single orbit vector</span>
  <span class="n">min_len</span> <span class="o">=</span> <span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;emb_dim&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;lag&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
  <span class="c1"># we need trajectory_len orbit vectors to follow a complete trajectory</span>
  <span class="n">min_len</span> <span class="o">+=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;trajectory_len&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>
  <span class="c1"># we need min_tsep * 2 + 1 orbit vectors to find neighbors for each</span>
  <span class="n">min_len</span> <span class="o">+=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;min_tsep&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span>
  <span class="k">return</span> <span class="n">min_len</span></div>



<div class="viewcode-block" id="lyap_r">
<a class="viewcode-back" href="../../nolds.html#nolds.lyap_r">[docs]</a>
<span class="k">def</span> <span class="nf">lyap_r</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">emb_dim</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">lag</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">min_tsep</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tau</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">min_neighbors</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span>
           <span class="n">trajectory_len</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">fit</span><span class="o">=</span><span class="s2">&quot;RANSAC&quot;</span><span class="p">,</span> <span class="n">debug_plot</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">debug_data</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
           <span class="n">plot_file</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fit_offset</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Estimates the largest Lyapunov exponent using the algorithm of Rosenstein</span>
<span class="sd">  et al. [lr_1]_.</span>

<span class="sd">  Explanation of Lyapunov exponents:</span>
<span class="sd">    See lyap_e.</span>

<span class="sd">  Explanation of the algorithm:</span>
<span class="sd">    The algorithm of Rosenstein et al. is only able to recover the largest</span>
<span class="sd">    Lyapunov exponent, but behaves rather robust to parameter choices.</span>

<span class="sd">    The idea for the algorithm relates closely to the definition of Lyapunov</span>
<span class="sd">    exponents. First, the dynamics of the data are reconstructed using a delay</span>
<span class="sd">    embedding method with a lag, such that each value x_i of the data is mapped</span>
<span class="sd">    to the vector</span>

<span class="sd">    X_i = [x_i, x_(i+lag), x_(i+2*lag), ..., x_(i+(emb_dim-1) * lag)]</span>

<span class="sd">    For each such vector X_i, we find the closest neighbor X_j using the</span>
<span class="sd">    euclidean distance. We know that as we follow the trajectories from X_i and</span>
<span class="sd">    X_j in time in a chaotic system the distances between X_(i+k) and X_(j+k)</span>
<span class="sd">    denoted as d_i(k) will increase according to a power law</span>
<span class="sd">    d_i(k) = c * e^(lambda * k) where lambda is a good approximation of the</span>
<span class="sd">    highest Lyapunov exponent, because the exponential expansion along the axis</span>
<span class="sd">    associated with this exponent will quickly dominate the expansion or</span>
<span class="sd">    contraction along other axes.</span>

<span class="sd">    To calculate lambda, we look at the logarithm of the distance trajectory,</span>
<span class="sd">    because log(d_i(k)) = log(c) + lambda * k. This gives a set of lines</span>
<span class="sd">    (one for each index i) whose slope is an approximation of lambda. We</span>
<span class="sd">    therefore extract the mean log trajectory d&#39;(k) by taking the mean of</span>
<span class="sd">    log(d_i(k)) over all orbit vectors X_i. We then fit a straight line to</span>
<span class="sd">    the plot of d&#39;(k) versus k. The slope of the line gives the desired</span>
<span class="sd">    parameter lambda.</span>

<span class="sd">  Method for choosing min_tsep:</span>
<span class="sd">    Usually we want to find neighbors between points that are close in phase</span>
<span class="sd">    space but not too close in time, because we want to avoid spurious</span>
<span class="sd">    correlations between the obtained trajectories that originate from temporal</span>
<span class="sd">    dependencies rather than the dynamic properties of the system. Therefore it</span>
<span class="sd">    is critical to find a good value for min_tsep. One rather plausible</span>
<span class="sd">    estimate for this value is to set min_tsep to the mean period of the</span>
<span class="sd">    signal, which can be obtained by calculating the mean frequency using the</span>
<span class="sd">    fast fourier transform. This procedure is used by default if the user sets</span>
<span class="sd">    min_tsep = None.</span>

<span class="sd">  Method for choosing lag:</span>
<span class="sd">    Another parameter that can be hard to choose by instinct alone is the lag</span>
<span class="sd">    between individual values in a vector of the embedded orbit. Here,</span>
<span class="sd">    Rosenstein et al. suggest to set the lag to the distance where the</span>
<span class="sd">    autocorrelation function drops below 1 - 1/e times its original (maximal)</span>
<span class="sd">    value. This procedure is used by default if the user sets lag = None.</span>

<span class="sd">  References:</span>
<span class="sd">    .. [lr_1] M. T. Rosenstein, J. J. Collins, and C. J. De Luca,</span>
<span class="sd">       “A practical method for calculating largest Lyapunov exponents from</span>
<span class="sd">       small data sets,” Physica D: Nonlinear Phenomena, vol. 65, no. 1,</span>
<span class="sd">       pp. 117–134, 1993.</span>

<span class="sd">  Reference Code:</span>
<span class="sd">    .. [lr_a] mirwais, &quot;Largest Lyapunov Exponent with Rosenstein&#39;s Algorithm&quot;,</span>
<span class="sd">       url: http://www.mathworks.com/matlabcentral/fileexchange/38424-largest-lyapunov-exponent-with-rosenstein-s-algorithm</span>
<span class="sd">    .. [lr_b] Shapour Mohammadi, &quot;LYAPROSEN: MATLAB function to calculate</span>
<span class="sd">       Lyapunov exponent&quot;,</span>
<span class="sd">       url: https://ideas.repec.org/c/boc/bocode/t741502.html</span>
<span class="sd">    .. [lr_c] Rainer Hegger, Holger Kantz, and Thomas Schreiber, &quot;TISEAN 3.0.0 - Nonlinear Time Series Analysis&quot;,</span>
<span class="sd">       url: https://www.pks.mpg.de/tisean/Tisean_3.0.0/docs/docs_c/lyap_r.html</span>

<span class="sd">  Args:</span>
<span class="sd">    data (iterable of float):</span>
<span class="sd">      (one-dimensional) time series</span>
<span class="sd">  Kwargs:</span>
<span class="sd">    emb_dim (int):</span>
<span class="sd">      embedding dimension for delay embedding</span>
<span class="sd">    lag (float):</span>
<span class="sd">      lag for delay embedding</span>
<span class="sd">    min_tsep (float):</span>
<span class="sd">      minimal temporal separation between two &quot;neighbors&quot; (default:</span>
<span class="sd">      find a suitable value by calculating the mean period of the data)</span>
<span class="sd">    tau (float):</span>
<span class="sd">      step size between data points in the time series in seconds</span>
<span class="sd">      (normalization scaling factor for exponents)</span>
<span class="sd">    min_neighbors (int):</span>
<span class="sd">      if lag=None, the search for a suitable lag will be stopped when the</span>
<span class="sd">      number of potential neighbors for a vector drops below min_neighbors</span>
<span class="sd">    trajectory_len (int):</span>
<span class="sd">      the time (in number of data points) to follow the distance</span>
<span class="sd">      trajectories between two neighboring points</span>
<span class="sd">    fit (str):</span>
<span class="sd">      the fitting method to use for the line fit, either &#39;poly&#39; for normal</span>
<span class="sd">      least squares polynomial fitting or &#39;RANSAC&#39; for RANSAC-fitting which</span>
<span class="sd">      is more robust to outliers</span>
<span class="sd">    debug_plot (boolean):</span>
<span class="sd">      if True, a simple plot of the final line-fitting step will</span>
<span class="sd">      be shown</span>
<span class="sd">    debug_data (boolean):</span>
<span class="sd">      if True, debugging data will be returned alongside the result</span>
<span class="sd">    plot_file (str):</span>
<span class="sd">      if debug_plot is True and plot_file is not None, the plot will be saved</span>
<span class="sd">      under the given file name instead of directly showing it through</span>
<span class="sd">      ``plt.show()``</span>
<span class="sd">    fit_offset (int):</span>
<span class="sd">      neglect the first fit_offset steps when fitting</span>

<span class="sd">  Returns:</span>
<span class="sd">    float:</span>
<span class="sd">      an estimate of the largest Lyapunov exponent (a positive exponent is</span>
<span class="sd">      a strong indicator for chaos)</span>
<span class="sd">    (1d-vector, 1d-vector, list):</span>
<span class="sd">      only present if debug_data is True: debug data of the form</span>
<span class="sd">      ``(ks, div_traj, poly)`` where ``ks`` are the x-values of the line fit,</span>
<span class="sd">      ``div_traj`` are the y-values and ``poly`` are the line coefficients</span>
<span class="sd">      (``[slope, intercept]``).</span>

<span class="sd">  &quot;&quot;&quot;</span>
  <span class="c1"># convert data to float to avoid overflow errors in rowwise_euclidean</span>
  <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
  <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
  <span class="n">max_tsep_factor</span> <span class="o">=</span> <span class="mf">0.25</span>
  <span class="k">if</span> <span class="n">lag</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">min_tsep</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="c1"># both the algorithm for lag and min_tsep need the fft</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">rfft</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">n</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">min_tsep</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="c1"># calculate min_tsep as mean period (= 1 / mean frequency)</span>
    <span class="c1"># to get the mean frequency, we weight the frequency buckets in the</span>
    <span class="c1"># fft result by the absolute power in that bucket and then divide</span>
    <span class="c1"># by the total power accross all buckets to get a weigthed mean</span>
    <span class="n">mf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">rfftfreq</span><span class="p">(</span><span class="n">n</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">f</span><span class="o">**</span><span class="mi">2</span>
    <span class="n">mf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">mf</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">min_tsep</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">mf</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">min_tsep</span> <span class="o">&gt;</span> <span class="n">max_tsep_factor</span> <span class="o">*</span> <span class="n">n</span><span class="p">:</span>
      <span class="n">min_tsep</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">max_tsep_factor</span> <span class="o">*</span> <span class="n">n</span><span class="p">)</span>
      <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;signal has very low mean frequency, setting min_tsep = </span><span class="si">{:d}</span><span class="s2">&quot;</span>
      <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">min_tsep</span><span class="p">),</span> <span class="ne">RuntimeWarning</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">lag</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="c1"># calculate the lag as point where the autocorrelation drops to (1 - 1/e)</span>
    <span class="c1"># times its maximum value</span>
    <span class="c1"># note: the Wiener–Khinchin theorem states that the spectral</span>
    <span class="c1"># decomposition of the autocorrelation function of a process is the power</span>
    <span class="c1"># spectrum of that process</span>
    <span class="c1"># =&gt; we can use fft to calculate the autocorrelation</span>
    <span class="n">acorr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">irfft</span><span class="p">(</span><span class="n">f</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">f</span><span class="p">))</span>
    <span class="n">acorr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">acorr</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">eps</span> <span class="o">=</span> <span class="n">acorr</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">e</span><span class="p">)</span>
    <span class="n">lag</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="c1"># small helper function to calculate resulting number of vectors for a</span>
    <span class="c1"># given lag value</span>
    <span class="k">def</span> <span class="nf">nb_neighbors</span><span class="p">(</span><span class="n">lag_value</span><span class="p">):</span>
      <span class="n">min_len</span> <span class="o">=</span> <span class="n">lyap_r_len</span><span class="p">(</span>
        <span class="n">emb_dim</span><span class="o">=</span><span class="n">emb_dim</span><span class="p">,</span> <span class="n">lag</span><span class="o">=</span><span class="n">i</span><span class="p">,</span> <span class="n">trajectory_len</span><span class="o">=</span><span class="n">trajectory_len</span><span class="p">,</span>
        <span class="n">min_tsep</span><span class="o">=</span><span class="n">min_tsep</span>
      <span class="p">)</span>
      <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="n">min_len</span><span class="p">)</span>
    <span class="c1"># find lag</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
      <span class="n">lag</span> <span class="o">=</span> <span class="n">i</span>
      <span class="k">if</span> <span class="n">acorr</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">eps</span> <span class="ow">or</span> <span class="n">acorr</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">eps</span><span class="p">:</span>
        <span class="k">break</span>
      <span class="k">if</span> <span class="n">nb_neighbors</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">min_neighbors</span><span class="p">:</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;autocorrelation declined too slowly to find suitable lag&quot;</span> \
          <span class="o">+</span> <span class="s2">&quot;, setting lag to </span><span class="si">{}</span><span class="s2">&quot;</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">lag</span><span class="p">),</span> <span class="ne">RuntimeWarning</span><span class="p">)</span>
        <span class="k">break</span>
  <span class="n">min_len</span> <span class="o">=</span> <span class="n">lyap_r_len</span><span class="p">(</span>
    <span class="n">emb_dim</span><span class="o">=</span><span class="n">emb_dim</span><span class="p">,</span> <span class="n">lag</span><span class="o">=</span><span class="n">lag</span><span class="p">,</span> <span class="n">trajectory_len</span><span class="o">=</span><span class="n">trajectory_len</span><span class="p">,</span>
    <span class="n">min_tsep</span><span class="o">=</span><span class="n">min_tsep</span>
  <span class="p">)</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">min_len</span><span class="p">:</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;for emb_dim = </span><span class="si">{}</span><span class="s2">, lag = </span><span class="si">{}</span><span class="s2">, min_tsep = </span><span class="si">{}</span><span class="s2"> and trajectory_len = </span><span class="si">{}</span><span class="s2">&quot;</span> \
      <span class="o">+</span> <span class="s2">&quot; you need at least </span><span class="si">{}</span><span class="s2"> datapoints in your time series&quot;</span>
    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
      <span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">emb_dim</span><span class="p">,</span> <span class="n">lag</span><span class="p">,</span> <span class="n">min_tsep</span><span class="p">,</span> <span class="n">trajectory_len</span><span class="p">,</span> <span class="n">min_len</span><span class="p">),</span>
      <span class="ne">RuntimeWarning</span>
    <span class="p">)</span>
  <span class="c1"># delay embedding</span>
  <span class="n">orbit</span> <span class="o">=</span> <span class="n">delay_embedding</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">emb_dim</span><span class="p">,</span> <span class="n">lag</span><span class="p">)</span>
  <span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">orbit</span><span class="p">)</span>
  <span class="c1"># construct matrix with pairwise distances between vectors in orbit</span>
  <span class="n">dists</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">rowwise_euclidean</span><span class="p">(</span><span class="n">orbit</span><span class="p">,</span> <span class="n">orbit</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">)])</span>
  <span class="c1"># we do not want to consider vectors as neighbor that are less than min_tsep</span>
  <span class="c1"># time steps together =&gt; mask the distances min_tsep to the right and left of</span>
  <span class="c1"># each index by setting them to infinity (will never be considered as nearest</span>
  <span class="c1"># neighbors)</span>
  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
    <span class="n">dists</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span> <span class="o">-</span> <span class="n">min_tsep</span><span class="p">):</span><span class="n">i</span> <span class="o">+</span> <span class="n">min_tsep</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s2">&quot;inf&quot;</span><span class="p">)</span>
  <span class="c1"># check that we have enough data points to continue</span>
  <span class="n">ntraj</span> <span class="o">=</span> <span class="n">m</span> <span class="o">-</span> <span class="n">trajectory_len</span> <span class="o">+</span> <span class="mi">1</span>
  <span class="n">min_traj</span> <span class="o">=</span> <span class="n">min_tsep</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span>  <span class="c1"># in each row min_tsep + 1 disances are inf</span>
  <span class="k">if</span> <span class="n">ntraj</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Not enough data points. Need </span><span class="si">{}</span><span class="s2"> additional data points to follow &quot;</span> \
        <span class="o">+</span> <span class="s2">&quot;a complete trajectory.&quot;</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">-</span><span class="n">ntraj</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
  <span class="k">if</span> <span class="n">ntraj</span> <span class="o">&lt;</span> <span class="n">min_traj</span><span class="p">:</span>
    <span class="c1"># not enough data points =&gt; there are rows where all values are inf</span>
    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">dists</span><span class="p">[:</span><span class="n">ntraj</span><span class="p">,</span> <span class="p">:</span><span class="n">ntraj</span><span class="p">]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Not enough data points. At least </span><span class="si">{}</span><span class="s2"> trajectories are required &quot;</span> \
        <span class="o">+</span> <span class="s2">&quot;to find a valid neighbor for each orbit vector with min_tsep=</span><span class="si">{}</span><span class="s2"> &quot;</span> \
        <span class="o">+</span> <span class="s2">&quot;but only </span><span class="si">{}</span><span class="s2"> could be created.&quot;</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">min_traj</span><span class="p">,</span> <span class="n">min_tsep</span><span class="p">,</span> <span class="n">ntraj</span><span class="p">))</span>
  <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">dists</span><span class="p">[:</span><span class="n">ntraj</span><span class="p">,</span> <span class="p">:</span><span class="n">ntraj</span><span class="p">]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
  <span class="c1"># find nearest neighbors (exclude last columns, because these vectors cannot</span>
  <span class="c1"># be followed in time for trajectory_len steps)</span>
  <span class="n">nb_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">dists</span><span class="p">[:</span><span class="n">ntraj</span><span class="p">,</span> <span class="p">:</span><span class="n">ntraj</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

  <span class="c1"># build divergence trajectory by averaging distances along the trajectory</span>
  <span class="c1"># over all neighbor pairs</span>
  <span class="n">div_traj</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">trajectory_len</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
  <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">trajectory_len</span><span class="p">):</span>
    <span class="c1"># calculate mean trajectory distance at step k</span>
    <span class="n">indices</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">ntraj</span><span class="p">)</span> <span class="o">+</span> <span class="n">k</span><span class="p">,</span> <span class="n">nb_idx</span> <span class="o">+</span> <span class="n">k</span><span class="p">)</span>
    <span class="n">div_traj_k</span> <span class="o">=</span> <span class="n">dists</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span>
    <span class="c1"># filter entries where distance is zero (would lead to -inf after log)</span>
    <span class="n">nonzero</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">div_traj_k</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nonzero</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
      <span class="c1"># if all entries where zero, we have to use -inf</span>
      <span class="n">div_traj</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">div_traj</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">div_traj_k</span><span class="p">[</span><span class="n">nonzero</span><span class="p">]))</span>
  <span class="c1"># filter -inf entries from mean trajectory</span>
  <span class="n">ks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">trajectory_len</span><span class="p">)</span>
  <span class="n">finite</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">div_traj</span><span class="p">))</span>
  <span class="n">ks</span> <span class="o">=</span> <span class="n">ks</span><span class="p">[</span><span class="n">finite</span><span class="p">]</span>
  <span class="n">div_traj</span> <span class="o">=</span> <span class="n">div_traj</span><span class="p">[</span><span class="n">finite</span><span class="p">]</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ks</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
    <span class="c1"># if all points or all but one point in the trajectory is -inf, we cannot</span>
    <span class="c1"># fit a line through the remaining points =&gt; return -inf as exponent</span>
    <span class="n">poly</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="c1"># normal line fitting</span>
    <span class="n">poly</span> <span class="o">=</span> <span class="n">poly_fit</span><span class="p">(</span><span class="n">ks</span><span class="p">[</span><span class="n">fit_offset</span><span class="p">:],</span> <span class="n">div_traj</span><span class="p">[</span><span class="n">fit_offset</span><span class="p">:],</span> <span class="mi">1</span><span class="p">,</span> <span class="n">fit</span><span class="o">=</span><span class="n">fit</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">debug_plot</span><span class="p">:</span>
    <span class="n">plot_reg</span><span class="p">(</span>
      <span class="n">ks</span><span class="p">[</span><span class="n">fit_offset</span><span class="p">:],</span> <span class="n">div_traj</span><span class="p">[</span><span class="n">fit_offset</span><span class="p">:],</span>
      <span class="n">poly</span><span class="p">,</span> <span class="s2">&quot;k&quot;</span><span class="p">,</span> <span class="s2">&quot;log(d(k))&quot;</span><span class="p">,</span> <span class="n">fname</span><span class="o">=</span><span class="n">plot_file</span><span class="p">)</span>
  <span class="n">le</span> <span class="o">=</span> <span class="n">poly</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">tau</span>
  <span class="k">if</span> <span class="n">debug_data</span><span class="p">:</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">le</span><span class="p">,</span> <span class="p">(</span><span class="n">ks</span><span class="p">,</span> <span class="n">div_traj</span><span class="p">,</span> <span class="n">poly</span><span class="p">))</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">le</span></div>



<div class="viewcode-block" id="lyap_e_len">
<a class="viewcode-back" href="../../nolds.html#nolds.lyap_e_len">[docs]</a>
<span class="k">def</span> <span class="nf">lyap_e_len</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Helper function that calculates the minimum number of data points required</span>
<span class="sd">  to use lyap_e.</span>

<span class="sd">  Note that none of the required parameters may be set to None.</span>

<span class="sd">  Kwargs:</span>
<span class="sd">    kwargs(dict):</span>
<span class="sd">      arguments used for lyap_e (required: emb_dim, matrix_dim, min_nb</span>
<span class="sd">      and min_tsep)</span>

<span class="sd">  Returns:</span>
<span class="sd">    minimum number of data points required to call lyap_e with the given</span>
<span class="sd">    parameters</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;emb_dim&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;matrix_dim&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
  <span class="c1"># minimum length required to find single orbit vector</span>
  <span class="n">min_len</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;emb_dim&#39;</span><span class="p">]</span>
  <span class="c1"># we need to follow each starting point of an orbit vector for m more steps</span>
  <span class="n">min_len</span> <span class="o">+=</span> <span class="n">m</span>
  <span class="c1"># we need min_tsep * 2 + 1 orbit vectors to find neighbors for each</span>
  <span class="n">min_len</span> <span class="o">+=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;min_tsep&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="mi">2</span>
  <span class="c1"># we need at least min_nb neighbors for each orbit vector</span>
  <span class="n">min_len</span> <span class="o">+=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;min_nb&#39;</span><span class="p">]</span>
  <span class="k">return</span> <span class="n">min_len</span></div>



<div class="viewcode-block" id="lyap_e">
<a class="viewcode-back" href="../../nolds.html#nolds.lyap_e">[docs]</a>
<span class="k">def</span> <span class="nf">lyap_e</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">emb_dim</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">matrix_dim</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">min_nb</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">min_tsep</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">tau</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
           <span class="n">debug_plot</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">debug_data</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">plot_file</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Estimates the Lyapunov exponents for the given data using the algorithm of</span>
<span class="sd">  Eckmann et al. [le_1]_.</span>

<span class="sd">  Recommendations for parameter settings by Eckmann et al.:</span>
<span class="sd">    * long recording time improves accuracy, small tau does not</span>
<span class="sd">    * use large values for emb_dim</span>
<span class="sd">    * matrix_dim should be &#39;somewhat larger than the expected number of</span>
<span class="sd">      positive Lyapunov exponents&#39;</span>
<span class="sd">    * min_nb = min(2 * matrix_dim, matrix_dim + 4)</span>

<span class="sd">  Explanation of Lyapunov exponents:</span>
<span class="sd">    The Lyapunov exponent describes the rate of separation of two</span>
<span class="sd">    infinitesimally close trajectories of a dynamical system in phase space.</span>
<span class="sd">    In a chaotic system, these trajectories diverge exponentially following</span>
<span class="sd">    the equation:</span>

<span class="sd">    \|X(t, X_0) - X(t, X_0 + eps)| = e^(lambda * t) * \|eps|</span>

<span class="sd">    In this equation X(t, X_0) is the trajectory of the system X starting at</span>
<span class="sd">    the point X_0 in phase space at time t. eps is the (infinitesimal)</span>
<span class="sd">    difference vector and lambda is called the Lyapunov exponent. If the</span>
<span class="sd">    system has more than one free variable, the phase space is</span>
<span class="sd">    multidimensional and each dimension has its own Lyapunov exponent. The</span>
<span class="sd">    existence of at least one positive Lyapunov exponent is generally seen as</span>
<span class="sd">    a strong indicator for chaos.</span>

<span class="sd">  Explanation of the Algorithm:</span>
<span class="sd">    To calculate the Lyapunov exponents analytically, the Jacobian of the</span>
<span class="sd">    system is required. The algorithm of Eckmann et al. therefore tries to</span>
<span class="sd">    estimate this Jacobian by reconstructing the dynamics of the system from</span>
<span class="sd">    which the time series was obtained. For this, several steps are required:</span>

<span class="sd">    * Embed the time series [x_1, x_2, ..., x_(N-1)] in an orbit of emb_dim</span>
<span class="sd">      dimensions (map each point x_i of the time series to a vector</span>
<span class="sd">      [x_i, x_(i+1), x_(i+2), ... x_(i+emb_dim-1)]).</span>
<span class="sd">    * For each vector X_i in this orbit find a radius r_i so that at least</span>
<span class="sd">      min_nb other vectors lie within (chebyshev-)distance r_i around X_i.</span>
<span class="sd">      These vectors will be called &quot;neighbors&quot; of X_i.</span>
<span class="sd">    * Find the Matrix T_i that sends points from the neighborhood of X_i to</span>
<span class="sd">      the neighborhood of X_(i+1). To avoid undetermined values in T_i, we</span>
<span class="sd">      construct T_i not with size (emb_dim x emb_dim) but with size</span>
<span class="sd">      (matrix_dim x matrix_dim), so that we have a larger &quot;step size&quot; m in the</span>
<span class="sd">      X_i, which are now defined as X&#39;_i = [x_i, x_(i+m), x_(i+2m),</span>
<span class="sd">      ... x_(i+(matrix_dim-1)*m)]. This means that emb_dim-1 must be divisible</span>
<span class="sd">      by matrix_dim-1. The T_i are then found by a linear least squares fit,</span>
<span class="sd">      assuring that T_i (X_j - X_i) ~= X_(j+m) - X_(i+m) for any X_j in the</span>
<span class="sd">      neighborhood of X_i.</span>
<span class="sd">    * Starting with i = 1 and Q_0 = identity successively decompose the matrix</span>
<span class="sd">      T_i * Q_(i-1) into the matrices Q_i and R_i by a QR-decomposition.</span>
<span class="sd">    * Calculate the Lyapunov exponents from the mean of the logarithm of the</span>
<span class="sd">      diagonal elements of the matrices R_i. To normalize the Lyapunov</span>
<span class="sd">      exponents, they have to be divided by m and by the step size tau of the</span>
<span class="sd">      original time series.</span>

<span class="sd">  References:</span>
<span class="sd">    .. [le_1] J. P. Eckmann, S. O. Kamphorst, D. Ruelle, and S. Ciliberto,</span>
<span class="sd">       “Liapunov exponents from time series,” Physical Review A,</span>
<span class="sd">       vol. 34, no. 6, pp. 4971–4979, 1986.</span>

<span class="sd">  Reference code:</span>
<span class="sd">    .. [le_a] Manfred Füllsack, &quot;Lyapunov exponent&quot;,</span>
<span class="sd">       url: http://systems-sciences.uni-graz.at/etextbook/sw2/lyapunov.html</span>
<span class="sd">    .. [le_b] Steve SIU, Lyapunov Exponents Toolbox (LET),</span>
<span class="sd">       url: http://www.mathworks.com/matlabcentral/fileexchange/233-let/content/LET/findlyap.m</span>
<span class="sd">    .. [le_c] Rainer Hegger, Holger Kantz, and Thomas Schreiber, TISEAN,</span>
<span class="sd">       url: http://www.mpipks-dresden.mpg.de/~tisean/Tisean_3.0.1/index.html</span>

<span class="sd">  Args:</span>
<span class="sd">    data (array-like of float):</span>
<span class="sd">      (scalar) data points</span>

<span class="sd">  Kwargs:</span>
<span class="sd">    emb_dim (int):</span>
<span class="sd">      embedding dimension</span>
<span class="sd">    matrix_dim (int):</span>
<span class="sd">      matrix dimension (emb_dim - 1 must be divisible by matrix_dim - 1)</span>
<span class="sd">    min_nb (int):</span>
<span class="sd">      minimal number of neighbors</span>
<span class="sd">      (default: min(2 * matrix_dim, matrix_dim + 4))</span>
<span class="sd">    min_tsep (int):</span>
<span class="sd">      minimal temporal separation between two &quot;neighbors&quot;</span>
<span class="sd">    tau (float):</span>
<span class="sd">      step size of the data in seconds</span>
<span class="sd">      (normalization scaling factor for exponents)</span>
<span class="sd">    debug_plot (boolean):</span>
<span class="sd">      if True, a histogram matrix of the individual estimates will be shown</span>
<span class="sd">    debug_data (boolean):</span>
<span class="sd">      if True, debugging data will be returned alongside the result</span>
<span class="sd">    plot_file (str):</span>
<span class="sd">      if debug_plot is True and plot_file is not None, the plot will be saved</span>
<span class="sd">      under the given file name instead of directly showing it through</span>
<span class="sd">      ``plt.show()``</span>

<span class="sd">  Returns:</span>
<span class="sd">    float array:</span>
<span class="sd">      array of matrix_dim Lyapunov exponents (positive exponents are indicators</span>
<span class="sd">      for chaos)</span>
<span class="sd">    2d-array of floats:</span>
<span class="sd">      only present if debug_data is True: all estimates for the matrix_dim</span>
<span class="sd">      Lyapunov exponents from the x iterations of R_i. The shape of this debug</span>
<span class="sd">      data is (x, matrix_dim).</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="c1"># convert to float to avoid errors when using &#39;inf&#39; as distance</span>
  <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
  <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">emb_dim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="p">(</span><span class="n">matrix_dim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;emb_dim - 1 must be divisible by matrix_dim - 1!&quot;</span><span class="p">)</span>
  <span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="n">emb_dim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="p">(</span><span class="n">matrix_dim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">min_nb</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="c1"># minimal number of neighbors as suggested by Eckmann et al.</span>
    <span class="n">min_nb</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">matrix_dim</span><span class="p">,</span> <span class="n">matrix_dim</span> <span class="o">+</span> <span class="mi">4</span><span class="p">)</span>

  <span class="n">min_len</span> <span class="o">=</span> <span class="n">lyap_e_len</span><span class="p">(</span>
    <span class="n">emb_dim</span><span class="o">=</span><span class="n">emb_dim</span><span class="p">,</span> <span class="n">matrix_dim</span><span class="o">=</span><span class="n">matrix_dim</span><span class="p">,</span> <span class="n">min_nb</span><span class="o">=</span><span class="n">min_nb</span><span class="p">,</span> <span class="n">min_tsep</span><span class="o">=</span><span class="n">min_tsep</span>
  <span class="p">)</span>
  <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">min_len</span><span class="p">:</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> data points are not enough! For emb_dim = </span><span class="si">{}</span><span class="s2">, matrix_dim = </span><span class="si">{}</span><span class="s2">&quot;</span> \
      <span class="o">+</span> <span class="s2">&quot;, min_tsep = </span><span class="si">{}</span><span class="s2"> and min_nb = </span><span class="si">{}</span><span class="s2"> you need at least </span><span class="si">{}</span><span class="s2"> data points &quot;</span> \
      <span class="o">+</span> <span class="s2">&quot;in your time series&quot;</span>
    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
      <span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">emb_dim</span><span class="p">,</span> <span class="n">matrix_dim</span><span class="p">,</span> <span class="n">min_tsep</span><span class="p">,</span> <span class="n">min_nb</span><span class="p">,</span> <span class="n">min_len</span><span class="p">),</span>
      <span class="ne">RuntimeWarning</span>
    <span class="p">)</span>

  <span class="c1"># construct orbit as matrix (e = emb_dim)</span>
  <span class="c1"># x0 x1 x2 ... xe-1</span>
  <span class="c1"># x1 x2 x3 ... xe</span>
  <span class="c1"># x2 x3 x4 ... xe+1</span>
  <span class="c1"># ...</span>

  <span class="c1"># note: we need to be able to step m points further for the beta vector</span>
  <span class="c1">#       =&gt; maximum start index is n - emb_dim - m</span>
  <span class="n">orbit</span> <span class="o">=</span> <span class="n">delay_embedding</span><span class="p">(</span><span class="n">data</span><span class="p">[:</span><span class="o">-</span><span class="n">m</span><span class="p">],</span> <span class="n">emb_dim</span><span class="p">,</span> <span class="n">lag</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">orbit</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">min_nb</span><span class="p">:</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">min_len</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Not enough data points. Need at least </span><span class="si">{}</span><span class="s2"> additional data points &quot;</span> \
        <span class="o">+</span> <span class="s2">&quot;to have min_nb = </span><span class="si">{}</span><span class="s2"> neighbor candidates&quot;</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">min_nb</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">orbit</span><span class="p">),</span> <span class="n">min_nb</span><span class="p">))</span>
  <span class="n">old_Q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="n">matrix_dim</span><span class="p">)</span>
  <span class="n">lexp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">matrix_dim</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
  <span class="n">lexp_counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">lexp</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
  <span class="n">debug_values</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="c1"># TODO reduce number of points to visit?</span>
  <span class="c1"># TODO performance test!</span>
  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">orbit</span><span class="p">)):</span>
    <span class="c1"># find neighbors for each vector in the orbit using the chebyshev distance</span>
    <span class="n">diffs</span> <span class="o">=</span> <span class="n">rowwise_chebyshev</span><span class="p">(</span><span class="n">orbit</span><span class="p">,</span> <span class="n">orbit</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    <span class="c1"># ensure that we do not count the difference of the vector to itself</span>
    <span class="n">diffs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">)</span>
    <span class="c1"># mask all neighbors that are too close in time to the vector itself</span>
    <span class="n">mask_from</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span> <span class="o">-</span> <span class="n">min_tsep</span><span class="p">)</span>
    <span class="n">mask_to</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">diffs</span><span class="p">),</span> <span class="n">i</span> <span class="o">+</span> <span class="n">min_tsep</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">diffs</span><span class="p">[</span><span class="n">mask_from</span><span class="p">:</span><span class="n">mask_to</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
    <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">diffs</span><span class="p">)</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="n">indices</span><span class="p">[</span><span class="n">min_nb</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>  <span class="c1"># index of the min_nb-nearest neighbor</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">diffs</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>  <span class="c1"># corresponding distance</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">r</span><span class="p">):</span>
      <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">min_len</span>
      <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Not enough data points. Orbit vector </span><span class="si">{}</span><span class="s2"> has less than min_nb = &quot;</span> \
          <span class="o">+</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> valid neighbors that are at least min_tsep = </span><span class="si">{}</span><span class="s2"> time steps &quot;</span> \
          <span class="o">+</span> <span class="s2">&quot;away. Input must have at least length </span><span class="si">{}</span><span class="s2">.&quot;</span>
      <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">min_nb</span><span class="p">,</span> <span class="n">min_tsep</span><span class="p">,</span> <span class="n">min_len</span><span class="p">))</span>
    <span class="c1"># there may be more than min_nb vectors at distance r (if multiple vectors</span>
    <span class="c1"># have a distance of exactly r)</span>
    <span class="c1"># =&gt; update index accordingly</span>
    <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">diffs</span> <span class="o">&lt;=</span> <span class="n">r</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># find the matrix T_i that satisifies</span>
    <span class="c1"># T_i (orbit&#39;[j] - orbit&#39;[i]) = (orbit&#39;[j+m] - orbit&#39;[i+m])</span>
    <span class="c1"># for all neighbors j where orbit&#39;[i] = [x[i], x[i+m],</span>
    <span class="c1"># ... x[i + (matrix_dim-1)*m]]</span>

    <span class="c1"># note that T_i has the following form:</span>
    <span class="c1"># 0  1  0  ... 0</span>
    <span class="c1"># 0  0  1  ... 0</span>
    <span class="c1"># ...</span>
    <span class="c1"># a0 a1 a2 ... a(matrix_dim-1)</span>

    <span class="c1"># This is because for all rows except the last one the aforementioned</span>
    <span class="c1"># equation has a clear solution since orbit&#39;[j+m] - orbit&#39;[i+m] =</span>
    <span class="c1"># [x[j+m]-x[i+m], x[j+2*m]-x[i+2*m], ... x[j+d_M*m]-x[i+d_M*m]]</span>
    <span class="c1"># and</span>
    <span class="c1"># orbit&#39;[j] - orbit&#39;[i] =</span>
    <span class="c1"># [x[j]-x[i], x[j+m]-x[i+m], ... x[j+(d_M-1)*m]-x[i+(d_M-1)*m]]</span>
    <span class="c1"># therefore x[j+k*m] - x[i+k*m] is already contained in</span>
    <span class="c1"># orbit&#39;[j] - orbit&#39;[x] for all k from 1 to matrix_dim-1. Only for</span>
    <span class="c1"># k = matrix_dim there is an actual problem to solve.</span>

    <span class="c1"># We can therefore find a = [a0, a1, a2, ... a(matrix_dim-1)] by</span>
    <span class="c1"># formulating a linear least squares problem (mat_X * a = vec_beta)</span>
    <span class="c1"># as follows.</span>

    <span class="c1"># build matrix X for linear least squares (d_M = matrix_dim)</span>
    <span class="c1"># x_j1 - x_i   x_j1+m - x_i+m   ...   x_j1+(d_M-1)m - x_i+(d_M-1)m</span>
    <span class="c1"># x_j2 - x_i   x_j2+m - x_i+m   ...   x_j2+(d_M-1)m - x_i+(d_M-1)m</span>
    <span class="c1"># ...</span>

    <span class="c1"># note: emb_dim = (d_M - 1) * m + 1</span>
    <span class="n">mat_X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">data</span><span class="p">[</span><span class="n">j</span><span class="p">:</span><span class="n">j</span> <span class="o">+</span> <span class="n">emb_dim</span><span class="p">:</span><span class="n">m</span><span class="p">]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">])</span>
    <span class="n">mat_X</span> <span class="o">-=</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span> <span class="o">+</span> <span class="n">emb_dim</span><span class="p">:</span><span class="n">m</span><span class="p">]</span>

    <span class="c1"># build vector beta for linear least squares</span>
    <span class="c1"># x_j1+(d_M)m - x_i+(d_M)m</span>
    <span class="c1"># x_j2+(d_M)m - x_i+(d_M)m</span>
    <span class="c1"># ...</span>
    <span class="k">if</span> <span class="nb">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">indices</span><span class="p">),</span> <span class="n">i</span><span class="p">)</span> <span class="o">+</span> <span class="n">matrix_dim</span> <span class="o">*</span> <span class="n">m</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
      <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">min_len</span>
      <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Not enough data points. Cannot follow orbit vector </span><span class="si">{}</span><span class="s2"> for &quot;</span> \
          <span class="o">+</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> (matrix_dim * m) time steps. Input must have at least &quot;</span> \
          <span class="o">+</span> <span class="s2">&quot;length </span><span class="si">{}</span><span class="s2">.&quot;</span>
      <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">matrix_dim</span> <span class="o">*</span> <span class="n">m</span><span class="p">,</span> <span class="n">min_len</span><span class="p">))</span>
    <span class="n">vec_beta</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">indices</span> <span class="o">+</span> <span class="n">matrix_dim</span> <span class="o">*</span> <span class="n">m</span><span class="p">]</span> <span class="o">-</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">matrix_dim</span> <span class="o">*</span> <span class="n">m</span><span class="p">]</span>

    <span class="c1"># perform linear least squares</span>
    <span class="n">a</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">lstsq</span><span class="p">(</span><span class="n">mat_X</span><span class="p">,</span> <span class="n">vec_beta</span><span class="p">,</span> <span class="n">rcond</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
    <span class="c1"># build matrix T</span>
    <span class="c1"># 0  1  0  ... 0</span>
    <span class="c1"># 0  0  1  ... 0</span>
    <span class="c1"># ...</span>
    <span class="c1"># 0  0  0  ... 1</span>
    <span class="c1"># a1 a2 a3 ... a_(d_M)</span>
    <span class="n">mat_T</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">matrix_dim</span><span class="p">,</span> <span class="n">matrix_dim</span><span class="p">))</span>
    <span class="n">mat_T</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="n">matrix_dim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">mat_T</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span>

    <span class="c1"># QR-decomposition of T * old_Q</span>
    <span class="n">mat_Q</span><span class="p">,</span> <span class="n">mat_R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">qr</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">mat_T</span><span class="p">,</span> <span class="n">old_Q</span><span class="p">))</span>
    <span class="c1"># force diagonal of R to be positive</span>
    <span class="c1"># (if QR = A then also QLL&#39;R = A with L&#39; = L^-1)</span>
    <span class="n">sign_diag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">mat_R</span><span class="p">))</span>
    <span class="n">sign_diag</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">sign_diag</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">sign_diag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">sign_diag</span><span class="p">)</span>
    <span class="n">mat_Q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">mat_Q</span><span class="p">,</span> <span class="n">sign_diag</span><span class="p">)</span>
    <span class="n">mat_R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">sign_diag</span><span class="p">,</span> <span class="n">mat_R</span><span class="p">)</span>

    <span class="n">old_Q</span> <span class="o">=</span> <span class="n">mat_Q</span>
    <span class="c1"># successively build sum for Lyapunov exponents</span>
    <span class="n">diag_R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">mat_R</span><span class="p">)</span>
    <span class="c1"># filter zeros in mat_R (would lead to -infs)</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">diag_R</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">lexp_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">diag_R</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
    <span class="n">lexp_i</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">diag_R</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>
    <span class="n">lexp_i</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">diag_R</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
    <span class="k">if</span> <span class="n">debug_plot</span> <span class="ow">or</span> <span class="n">debug_data</span><span class="p">:</span>
      <span class="n">debug_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lexp_i</span> <span class="o">/</span> <span class="n">tau</span> <span class="o">/</span> <span class="n">m</span><span class="p">)</span>
    <span class="n">lexp</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">+=</span> <span class="n">lexp_i</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
    <span class="n">lexp_counts</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
  <span class="c1"># end of loop over orbit vectors</span>
  <span class="c1"># it may happen that all R-matrices contained zeros =&gt; exponent really has</span>
  <span class="c1"># to be -inf</span>
  <span class="k">if</span> <span class="n">debug_plot</span><span class="p">:</span>
    <span class="n">plot_histogram_matrix</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">debug_values</span><span class="p">),</span> <span class="s2">&quot;layp_e&quot;</span><span class="p">,</span> <span class="n">fname</span><span class="o">=</span><span class="n">plot_file</span><span class="p">)</span>
  <span class="c1"># normalize exponents over number of individual mat_Rs</span>
  <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">lexp_counts</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
  <span class="n">lexp</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">/=</span> <span class="n">lexp_counts</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
  <span class="n">lexp</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">lexp_counts</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
  <span class="c1"># normalize with respect to tau</span>
  <span class="n">lexp</span> <span class="o">/=</span> <span class="n">tau</span>
  <span class="c1"># take m into account</span>
  <span class="n">lexp</span> <span class="o">/=</span> <span class="n">m</span>
  <span class="k">if</span> <span class="n">debug_data</span><span class="p">:</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">lexp</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">debug_values</span><span class="p">))</span>
  <span class="k">return</span> <span class="n">lexp</span></div>



<span class="k">def</span> <span class="nf">plot_dists</span><span class="p">(</span><span class="n">dists</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fname</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="c1"># local import to avoid dependency for non-debug use</span>
  <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
  <span class="n">nstd</span> <span class="o">=</span> <span class="mi">3</span>
  <span class="n">nbins</span> <span class="o">=</span> <span class="mi">50</span>
  <span class="n">dists_full</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">dists</span><span class="p">)</span>
  <span class="n">ymax</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dists_full</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.05</span>
  <span class="n">mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dists_full</span><span class="p">)</span>
  <span class="n">std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">dists_full</span><span class="p">,</span> <span class="n">ddof</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
  <span class="n">rng</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">mean</span> <span class="o">+</span> <span class="n">std</span> <span class="o">*</span> <span class="n">nstd</span><span class="p">)</span>
  <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="n">colors</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;green&quot;</span><span class="p">,</span> <span class="s2">&quot;blue&quot;</span><span class="p">]</span>
  <span class="k">for</span> <span class="n">h</span><span class="p">,</span> <span class="n">bins</span> <span class="ow">in</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">dat</span><span class="p">,</span> <span class="n">nbins</span><span class="p">,</span> <span class="n">rng</span><span class="p">)</span> <span class="k">for</span> <span class="n">dat</span> <span class="ow">in</span> <span class="n">dists</span><span class="p">]:</span>
    <span class="n">bw</span> <span class="o">=</span> <span class="n">bins</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">bins</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">bar</span><span class="p">(</span><span class="n">bins</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">h</span><span class="p">,</span> <span class="n">bw</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;m=</span><span class="si">{:d}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">m</span> <span class="o">+</span> <span class="n">i</span><span class="p">),</span>
            <span class="n">color</span><span class="o">=</span><span class="n">colors</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
    <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
  <span class="n">plt</span><span class="o">.</span><span class="n">axvline</span><span class="p">(</span><span class="n">tolerance</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">)</span>
  <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s2">&quot;best&quot;</span><span class="p">)</span>
  <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;distance&quot;</span><span class="p">)</span>
  <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;count&quot;</span><span class="p">)</span>
  <span class="n">plt</span><span class="o">.</span><span class="n">ylim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">ymax</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">title</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="n">title</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">fname</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>
  <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>


<div class="viewcode-block" id="sampen">
<a class="viewcode-back" href="../../nolds.html#nolds.sampen">[docs]</a>
<span class="k">def</span> <span class="nf">sampen</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">emb_dim</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">lag</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">dist</span><span class="o">=</span><span class="n">rowwise_chebyshev</span><span class="p">,</span>
           <span class="n">closed</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">debug_plot</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">debug_data</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">plot_file</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Computes the sample entropy of the given data.</span>

<span class="sd">  Explanation of the sample entropy:</span>
<span class="sd">    The sample entropy of a time series is defined as the negative natural</span>
<span class="sd">    logarithm of the conditional probability that two sequences similar for</span>
<span class="sd">    emb_dim points remain similar at the next point, excluding self-matches.</span>

<span class="sd">    A lower value for the sample entropy therefore corresponds to a higher</span>
<span class="sd">    probability indicating more self-similarity.</span>

<span class="sd">  Explanation of the algorithm:</span>
<span class="sd">    The algorithm constructs all subsequences of length emb_dim</span>
<span class="sd">    [s_1, s_1+lag, s_1+2*lag, ...] and then counts each pair (s_i, s_j) with i != j</span>
<span class="sd">    where dist(s_i, s_j) &lt; tolerance. The same process is repeated for all</span>
<span class="sd">    subsequences of length emb_dim + 1. The sum of similar sequence pairs</span>
<span class="sd">    with length emb_dim + 1 is divided by the sum of similar sequence pairs</span>
<span class="sd">    with length emb_dim. The result of the algorithm is the negative logarithm</span>
<span class="sd">    of this ratio/probability.</span>

<span class="sd">  References:</span>
<span class="sd">    .. [se_1] J. S. Richman and J. R. Moorman, “Physiological time-series</span>
<span class="sd">       analysis using approximate entropy and sample entropy,”</span>
<span class="sd">       American Journal of Physiology-Heart and Circulatory Physiology,</span>
<span class="sd">       vol. 278, no. 6, pp. H2039–H2049, 2000.</span>

<span class="sd">  Reference code:</span>
<span class="sd">    .. [se_a] &quot;sample_entropy&quot; function in R-package &quot;pracma&quot;,</span>
<span class="sd">        url: https://cran.r-project.org/web/packages/pracma/pracma.pdf</span>

<span class="sd">  Args:</span>
<span class="sd">    data (array-like of float):</span>
<span class="sd">      input data</span>

<span class="sd">  Kwargs:</span>
<span class="sd">    emb_dim (int):</span>
<span class="sd">      the embedding dimension (length of vectors to compare)</span>
<span class="sd">    tolerance (float):</span>
<span class="sd">      distance threshold for two template vectors to be considered equal</span>
<span class="sd">      (default: 0.2 * std(data) at emb_dim = 2, corrected for dimension effect</span>
<span class="sd">      for other values of emb_dim)</span>
<span class="sd">    lag (int):</span>
<span class="sd">      delay for the delay embedding</span>
<span class="sd">    dist (function (2d-array, 1d-array) -&gt; 1d-array):</span>
<span class="sd">      distance function used to calculate the distance between template</span>
<span class="sd">      vectors. Sampen is defined using ``rowwise_chebyshev``. You should only</span>
<span class="sd">      use something else, if you are sure that you need it.</span>
<span class="sd">    closed (boolean):</span>
<span class="sd">      if True, will check for vector pairs whose distance is in the closed</span>
<span class="sd">      interval [0, r] (less or equal to r), otherwise the open interval</span>
<span class="sd">      [0, r) (less than r) will be used</span>
<span class="sd">    debug_plot (boolean):</span>
<span class="sd">      if True, a histogram of the individual distances for m and m+1</span>
<span class="sd">    debug_data (boolean):</span>
<span class="sd">      if True, debugging data will be returned alongside the result</span>
<span class="sd">    plot_file (str):</span>
<span class="sd">      if debug_plot is True and plot_file is not None, the plot will be saved</span>
<span class="sd">      under the given file name instead of directly showing it through</span>
<span class="sd">      ``plt.show()``</span>

<span class="sd">  Returns:</span>
<span class="sd">    float:</span>
<span class="sd">      the sample entropy of the data (negative logarithm of ratio between</span>
<span class="sd">      similar template vectors of length emb_dim + 1 and emb_dim)</span>
<span class="sd">    [c_m, c_m1]:</span>
<span class="sd">      list of two floats: count of similar template vectors of length emb_dim</span>
<span class="sd">      (c_m) and of length emb_dim + 1 (c_m1)</span>
<span class="sd">    [float list, float list]:</span>
<span class="sd">      Lists of lists of the form ``[dists_m, dists_m1]`` containing the</span>
<span class="sd">      distances between template vectors for m (dists_m)</span>
<span class="sd">      and for m + 1 (dists_m1).</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

  <span class="k">if</span> <span class="n">tolerance</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="c1"># the reasoning behind this default value is the following:</span>
    <span class="c1"># 1. physionet uses the default values emb_dim = 2, tolerance = 0.2</span>
    <span class="c1"># 2. the chebyshev distance rises logarithmically with increasing dimension</span>
    <span class="c1"># 3. 0.5627 * np.log(emb_dim) + 1.3334 is the logarithmic trend line for</span>
    <span class="c1">#    the chebyshev distance of vectors sampled from a univariate normal</span>
    <span class="c1">#    distribution</span>
    <span class="c1"># 4. 0.1164 is used as a factor to ensure that tolerance == std * 0.2 for</span>
    <span class="c1">#    emb_dim == 2</span>
    <span class="n">tolerance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">ddof</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.1164</span> <span class="o">*</span> <span class="p">(</span><span class="mf">0.5627</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">emb_dim</span><span class="p">)</span> <span class="o">+</span> <span class="mf">1.3334</span><span class="p">)</span>
  <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

  <span class="c1"># build matrix of &quot;template vectors&quot;</span>
  <span class="c1"># (all consecutive subsequences of length m)</span>
  <span class="c1"># x0 x1 x2 x3 ... xm-1</span>
  <span class="c1"># x1 x2 x3 x4 ... xm</span>
  <span class="c1"># x2 x3 x4 x5 ... xm+1</span>
  <span class="c1"># ...</span>
  <span class="c1"># x_n-m-1     ... xn-1</span>

  <span class="c1"># since we need two of these matrices for m = emb_dim and m = emb_dim +1,</span>
  <span class="c1"># we build one that is large enough =&gt; shape (emb_dim+1, n-emb_dim)</span>

  <span class="c1"># note that we ignore the last possible template vector with length emb_dim,</span>
  <span class="c1"># because this vector has no corresponding vector of length m+1 and thus does</span>
  <span class="c1"># not count towards the conditional probability</span>
  <span class="c1"># (otherwise first dimension would be n-emb_dim+1 and not n-emb_dim)</span>
  <span class="n">tVecs</span> <span class="o">=</span> <span class="n">delay_embedding</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="n">emb_dim</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">lag</span><span class="o">=</span><span class="n">lag</span><span class="p">)</span>
  <span class="n">plot_data</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="n">counts</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="p">[</span><span class="n">emb_dim</span><span class="p">,</span> <span class="n">emb_dim</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]:</span>
    <span class="n">counts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">plot_data</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
    <span class="c1"># get the matrix that we need for the current m</span>
    <span class="n">tVecsM</span> <span class="o">=</span> <span class="n">tVecs</span><span class="p">[:</span><span class="n">n</span> <span class="o">-</span> <span class="n">m</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:</span><span class="n">m</span><span class="p">]</span>
    <span class="c1"># successively calculate distances between each pair of template vectors</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">tVecsM</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
      <span class="n">dsts</span> <span class="o">=</span> <span class="n">dist</span><span class="p">(</span><span class="n">tVecsM</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:],</span> <span class="n">tVecsM</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
      <span class="k">if</span> <span class="n">debug_plot</span> <span class="ow">or</span> <span class="n">debug_data</span><span class="p">:</span>
        <span class="n">plot_data</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">dsts</span><span class="p">)</span>
      <span class="c1"># count how many distances are smaller than the tolerance</span>
      <span class="k">if</span> <span class="n">closed</span><span class="p">:</span>
        <span class="n">counts</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dsts</span> <span class="o">&lt;=</span> <span class="n">tolerance</span><span class="p">)</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="n">counts</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dsts</span> <span class="o">&lt;</span> <span class="n">tolerance</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">counts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">counts</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
    <span class="n">saen</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">*</span> <span class="n">counts</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">counts</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="c1"># log would be infinite or undefined =&gt; cannot determine saen</span>
    <span class="n">zcounts</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="n">counts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
      <span class="n">zcounts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;emb_dim&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">counts</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
      <span class="n">zcounts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;emb_dim + 1&quot;</span><span class="p">)</span>
    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
      <span class="p">(</span>
        <span class="s2">&quot;Zero vectors are within tolerance for </span><span class="si">%s</span><span class="s2">. &quot;</span> \
        <span class="o">+</span> <span class="s2">&quot;Consider raising the tolerance parameter to avoid </span><span class="si">%s</span><span class="s2"> result.&quot;</span>
      <span class="p">)</span> <span class="o">%</span> <span class="p">(</span><span class="s2">&quot; and &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">zcounts</span><span class="p">),</span> <span class="s2">&quot;NaN&quot;</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">zcounts</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="k">else</span> <span class="s2">&quot;inf&quot;</span><span class="p">),</span>
      <span class="ne">RuntimeWarning</span>
    <span class="p">)</span>
    <span class="k">if</span> <span class="n">counts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">counts</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
      <span class="n">saen</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="k">elif</span> <span class="n">counts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
      <span class="n">saen</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">saen</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
  <span class="k">if</span> <span class="n">debug_plot</span><span class="p">:</span>
    <span class="n">plot_dists</span><span class="p">(</span><span class="n">plot_data</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s2">&quot;sampEn = </span><span class="si">{:.3f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">saen</span><span class="p">),</span>
               <span class="n">fname</span><span class="o">=</span><span class="n">plot_file</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">debug_data</span><span class="p">:</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">saen</span><span class="p">,</span> <span class="n">counts</span><span class="p">,</span> <span class="n">plot_data</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">saen</span></div>



<div class="viewcode-block" id="binary_n">
<a class="viewcode-back" href="../../nolds.html#nolds.binary_n">[docs]</a>
<span class="k">def</span> <span class="nf">binary_n</span><span class="p">(</span><span class="n">total_N</span><span class="p">,</span> <span class="n">min_n</span><span class="o">=</span><span class="mi">50</span><span class="p">):</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Creates a list of values by successively halving the total length total_N</span>
<span class="sd">  until the resulting value is less than min_n.</span>

<span class="sd">  Non-integer results are rounded down.</span>

<span class="sd">  Args:</span>
<span class="sd">    total_N (int):</span>
<span class="sd">      total length</span>
<span class="sd">  Kwargs:</span>
<span class="sd">    min_n (int):</span>
<span class="sd">      minimal length after division</span>

<span class="sd">  Returns:</span>
<span class="sd">    list of integers:</span>
<span class="sd">      total_N/2, total_N/4, total_N/8, ... until total_N/2^i &lt; min_n</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="n">max_exp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">*</span> <span class="n">total_N</span> <span class="o">/</span> <span class="n">min_n</span><span class="p">)</span>
  <span class="n">max_exp</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">max_exp</span><span class="p">))</span>
  <span class="k">return</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">*</span> <span class="n">total_N</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="n">i</span><span class="p">)))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">max_exp</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span></div>



<div class="viewcode-block" id="logarithmic_n">
<a class="viewcode-back" href="../../nolds.html#nolds.logarithmic_n">[docs]</a>
<span class="k">def</span> <span class="nf">logarithmic_n</span><span class="p">(</span><span class="n">min_n</span><span class="p">,</span> <span class="n">max_n</span><span class="p">,</span> <span class="n">factor</span><span class="p">):</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Creates a list of values by successively multiplying a minimum value min_n by</span>
<span class="sd">  a factor &gt; 1 until a maximum value max_n is reached.</span>

<span class="sd">  Non-integer results are rounded down.</span>

<span class="sd">  Args:</span>
<span class="sd">    min_n (float):</span>
<span class="sd">      minimum value (must be &lt; max_n)</span>
<span class="sd">    max_n (float):</span>
<span class="sd">      maximum value (must be &gt; min_n)</span>
<span class="sd">    factor (float):</span>
<span class="sd">      factor used to increase min_n (must be &gt; 1)</span>

<span class="sd">  Returns:</span>
<span class="sd">    list of integers:</span>
<span class="sd">      min_n, min_n * factor, min_n * factor^2, ... min_n * factor^i &lt; max_n</span>
<span class="sd">      without duplicates</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="k">assert</span> <span class="n">max_n</span> <span class="o">&gt;</span> <span class="n">min_n</span>
  <span class="k">assert</span> <span class="n">factor</span> <span class="o">&gt;</span> <span class="mi">1</span>
  <span class="c1"># stop condition: min * f^x = max</span>
  <span class="c1"># =&gt; f^x = max/min</span>
  <span class="c1"># =&gt; x = log(max/min) / log(f)</span>
  <span class="n">max_i</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">*</span> <span class="n">max_n</span> <span class="o">/</span> <span class="n">min_n</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">factor</span><span class="p">)))</span>
  <span class="n">ns</span> <span class="o">=</span> <span class="p">[</span><span class="n">min_n</span><span class="p">]</span>
  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">max_i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">min_n</span> <span class="o">*</span> <span class="p">(</span><span class="n">factor</span> <span class="o">**</span> <span class="n">i</span><span class="p">)))</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="n">ns</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
      <span class="n">ns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">ns</span></div>



<div class="viewcode-block" id="logmid_n">
<a class="viewcode-back" href="../../nolds.html#nolds.logmid_n">[docs]</a>
<span class="k">def</span> <span class="nf">logmid_n</span><span class="p">(</span><span class="n">max_n</span><span class="p">,</span> <span class="n">ratio</span><span class="o">=</span><span class="mi">1</span><span class="o">/</span><span class="mf">4.0</span><span class="p">,</span> <span class="n">nsteps</span><span class="o">=</span><span class="mi">15</span><span class="p">):</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Creates an array of integers that lie evenly spaced in the &quot;middle&quot; of the</span>
<span class="sd">  logarithmic scale from 0 to log(max_n).</span>

<span class="sd">  If max_n is very small and/or nsteps is very large, this may lead to</span>
<span class="sd">  duplicate values which will be removed from the output.</span>

<span class="sd">  This function has benefits in hurst_rs, because it cuts away both very small</span>
<span class="sd">  and very large n, which both can cause problems, and still produces a</span>
<span class="sd">  logarithmically spaced sequence.</span>

<span class="sd">  Args:</span>
<span class="sd">    max_n (int):</span>
<span class="sd">      largest possible output value (should be the sequence length when used in</span>
<span class="sd">      hurst_rs)</span>

<span class="sd">  Kwargs:</span>
<span class="sd">    ratio (float):</span>
<span class="sd">      width of the &quot;middle&quot; of the logarithmic interval relative to log(max_n).</span>
<span class="sd">      For example, for ratio=1/2.0 the logarithm of the resulting values will</span>
<span class="sd">      lie between 0.25 * log(max_n) and 0.75 * log(max_n).</span>
<span class="sd">    nsteps (float):</span>
<span class="sd">      (maximum) number of values to take from the specified range</span>

<span class="sd">  Returns:</span>
<span class="sd">    array of int:</span>
<span class="sd">      a logarithmically spaced sequence of at most nsteps values (may be less,</span>
<span class="sd">      because only unique values are returned)</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="n">l</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">max_n</span><span class="p">)</span>
  <span class="n">span</span> <span class="o">=</span> <span class="n">l</span> <span class="o">*</span> <span class="n">ratio</span>
  <span class="n">start</span> <span class="o">=</span> <span class="n">l</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">ratio</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.5</span>
  <span class="n">midrange</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="mf">1.0</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nsteps</span><span class="p">)</span><span class="o">/</span><span class="n">nsteps</span><span class="o">*</span><span class="n">span</span>
  <span class="n">nvals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">midrange</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;int32&quot;</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">nvals</span><span class="p">)</span></div>



<div class="viewcode-block" id="logarithmic_r">
<a class="viewcode-back" href="../../nolds.html#nolds.logarithmic_r">[docs]</a>
<span class="k">def</span> <span class="nf">logarithmic_r</span><span class="p">(</span><span class="n">min_n</span><span class="p">,</span> <span class="n">max_n</span><span class="p">,</span> <span class="n">factor</span><span class="p">):</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Creates a list of values by successively multiplying a minimum value min_n by</span>
<span class="sd">  a factor &gt; 1 until a maximum value max_n is reached.</span>

<span class="sd">  Args:</span>
<span class="sd">    min_n (float):</span>
<span class="sd">      minimum value (must be &lt; max_n)</span>
<span class="sd">    max_n (float):</span>
<span class="sd">      maximum value (must be &gt; min_n)</span>
<span class="sd">    factor (float):</span>
<span class="sd">      factor used to increase min_n (must be &gt; 1)</span>

<span class="sd">  Returns:</span>
<span class="sd">    list of floats:</span>
<span class="sd">      min_n, min_n * factor, min_n * factor^2, ... min_n * factor^i &lt; max_n</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="k">assert</span> <span class="n">max_n</span> <span class="o">&gt;</span> <span class="n">min_n</span>
  <span class="k">assert</span> <span class="n">factor</span> <span class="o">&gt;</span> <span class="mi">1</span>
  <span class="n">max_i</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">*</span> <span class="n">max_n</span> <span class="o">/</span> <span class="n">min_n</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">factor</span><span class="p">)))</span>
  <span class="k">return</span> <span class="p">[</span><span class="n">min_n</span> <span class="o">*</span> <span class="p">(</span><span class="n">factor</span> <span class="o">**</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">max_i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span></div>



<div class="viewcode-block" id="expected_rs">
<a class="viewcode-back" href="../../nolds.html#nolds.expected_rs">[docs]</a>
<span class="k">def</span> <span class="nf">expected_rs</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Calculates the expected (R/S)_n for white noise for a given n.</span>

<span class="sd">  This is used as a correction factor in the function hurst_rs. It uses the</span>
<span class="sd">  formula of Anis-Lloyd-Peters (see [h_3]_).</span>

<span class="sd">  Args:</span>
<span class="sd">    n (int):</span>
<span class="sd">      the value of n for which the expected (R/S)_n should be calculated</span>

<span class="sd">  Returns:</span>
<span class="sd">    float:</span>
<span class="sd">      expected (R/S)_n for white noise</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="n">front</span> <span class="o">=</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">/</span> <span class="n">n</span>
  <span class="n">i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
  <span class="n">back</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">n</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span> <span class="o">/</span> <span class="n">i</span><span class="p">))</span>
  <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">340</span><span class="p">:</span>
    <span class="n">middle</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">gamma</span><span class="p">((</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">/</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">/</span> <span class="n">math</span><span class="o">.</span><span class="n">gamma</span><span class="p">(</span><span class="n">n</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">middle</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">n</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">front</span> <span class="o">*</span> <span class="n">middle</span> <span class="o">*</span> <span class="n">back</span></div>



<div class="viewcode-block" id="expected_h">
<a class="viewcode-back" href="../../nolds.html#nolds.expected_h">[docs]</a>
<span class="k">def</span> <span class="nf">expected_h</span><span class="p">(</span><span class="n">nvals</span><span class="p">,</span> <span class="n">fit</span><span class="o">=</span><span class="s2">&quot;RANSAC&quot;</span><span class="p">):</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Uses expected_rs to calculate the expected value for the Hurst exponent h</span>
<span class="sd">  based on the values of n used for the calculation.</span>

<span class="sd">  Args:</span>
<span class="sd">    nvals (iterable of int):</span>
<span class="sd">      the values of n used to calculate the individual (R/S)_n</span>

<span class="sd">  KWargs:</span>
<span class="sd">    fit (str):</span>
<span class="sd">      the fitting method to use for the line fit, either &#39;poly&#39; for normal</span>
<span class="sd">      least squares polynomial fitting or &#39;RANSAC&#39; for RANSAC-fitting which</span>
<span class="sd">      is more robust to outliers</span>

<span class="sd">  Returns:</span>
<span class="sd">    float:</span>
<span class="sd">      expected h for white noise</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="n">rsvals</span> <span class="o">=</span> <span class="p">[</span><span class="n">expected_rs</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">nvals</span><span class="p">]</span>
  <span class="n">poly</span> <span class="o">=</span> <span class="n">poly_fit</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">nvals</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">rsvals</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">fit</span><span class="o">=</span><span class="n">fit</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">poly</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>



<span class="k">def</span> <span class="nf">rs</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">unbiased</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Calculates an individual R/S value in the rescaled range approach for</span>
<span class="sd">  a given n.</span>

<span class="sd">  Note: This is just a helper function for hurst_rs and should not be called</span>
<span class="sd">  directly.</span>

<span class="sd">  Args:</span>
<span class="sd">    data (array-like of float):</span>
<span class="sd">      time series</span>
<span class="sd">    n (float):</span>
<span class="sd">      size of the subseries in which data should be split</span>

<span class="sd">  Kwargs:</span>
<span class="sd">    unbiased (boolean):</span>
<span class="sd">      if True, the standard deviation based on the unbiased variance</span>
<span class="sd">      (1/(N-1) instead of 1/N) will be used. This should be the default choice,</span>
<span class="sd">      since the true mean of the sequences is not known. This parameter should</span>
<span class="sd">      only be changed to recreate results of other implementations.</span>

<span class="sd">  Returns:</span>
<span class="sd">    float:</span>
<span class="sd">      (R/S)_n</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
  <span class="n">total_N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
  <span class="n">m</span> <span class="o">=</span> <span class="n">total_N</span> <span class="o">//</span> <span class="n">n</span>  <span class="c1"># number of sequences</span>
  <span class="c1"># cut values at the end of data to make the array divisible by n</span>
  <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[:</span><span class="n">total_N</span> <span class="o">-</span> <span class="p">(</span><span class="n">total_N</span> <span class="o">%</span> <span class="n">n</span><span class="p">)]</span>
  <span class="c1"># split remaining data into subsequences of length n</span>
  <span class="n">seqs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>
  <span class="c1"># calculate means of subsequences</span>
  <span class="n">means</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">seqs</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
  <span class="c1"># normalize subsequences by substracting mean</span>
  <span class="n">y</span> <span class="o">=</span> <span class="n">seqs</span> <span class="o">-</span> <span class="n">means</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">m</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
  <span class="c1"># build cumulative sum of subsequences</span>
  <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
  <span class="c1"># find ranges</span>
  <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
  <span class="c1"># find standard deviation</span>
  <span class="c1"># we should use the unbiased estimator, since we do not know the true mean</span>
  <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">seqs</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">ddof</span><span class="o">=</span><span class="mi">1</span> <span class="k">if</span> <span class="n">unbiased</span> <span class="k">else</span> <span class="mi">0</span><span class="p">)</span>
  <span class="c1"># some ranges may be zero and have to be excluded from the analysis</span>
  <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">r</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
  <span class="n">r</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
  <span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
  <span class="c1"># it may happen that all ranges are zero (if all values in data are equal)</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="c1"># return mean of r/s along subsequence index</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">r</span> <span class="o">/</span> <span class="n">s</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">plot_histogram_matrix</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bin_range</span><span class="o">=</span><span class="s2">&quot;3sigma&quot;</span><span class="p">,</span> <span class="n">fname</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="c1"># local import to avoid dependency for non-debug use</span>
  <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
  <span class="n">nhists</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
  <span class="n">nbins</span> <span class="o">=</span> <span class="mi">25</span>
  <span class="n">ylim</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span>
  <span class="n">nrows</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">nhists</span><span class="p">)))</span>
  <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="n">nrows</span> <span class="o">*</span> <span class="mi">4</span><span class="p">,</span> <span class="n">nrows</span> <span class="o">*</span> <span class="mi">4</span><span class="p">))</span>
  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nhists</span><span class="p">):</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="n">nrows</span><span class="p">,</span> <span class="n">nrows</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">absmax</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">data</span><span class="p">[:,</span> <span class="n">i</span><span class="p">])),</span> <span class="nb">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">data</span><span class="p">[:,</span> <span class="n">i</span><span class="p">])))</span>
    <span class="k">if</span> <span class="n">bin_range</span> <span class="o">==</span> <span class="s2">&quot;absmax&quot;</span><span class="p">:</span>
      <span class="n">rng</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="n">absmax</span><span class="p">,</span> <span class="n">absmax</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">bin_range</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;sigma&quot;</span><span class="p">):</span>
      <span class="n">n</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">bin_range</span><span class="p">[:</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="s2">&quot;sigma&quot;</span><span class="p">)])</span>
      <span class="n">mu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">data</span><span class="p">[:,</span><span class="n">i</span><span class="p">])</span>
      <span class="n">sigma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">data</span><span class="p">[:,</span> <span class="n">i</span><span class="p">],</span> <span class="n">ddof</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
      <span class="n">rng</span> <span class="o">=</span> <span class="p">(</span><span class="n">mu</span> <span class="o">-</span> <span class="n">n</span> <span class="o">*</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">mu</span> <span class="o">+</span> <span class="n">n</span> <span class="o">*</span> <span class="n">sigma</span><span class="p">)</span>
    <span class="n">h</span><span class="p">,</span> <span class="n">bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">data</span><span class="p">[:,</span> <span class="n">i</span><span class="p">],</span> <span class="n">nbins</span><span class="p">,</span> <span class="n">rng</span><span class="p">)</span>
    <span class="n">bin_width</span> <span class="o">=</span> <span class="n">bins</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">bins</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">h</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">bar</span><span class="p">(</span><span class="n">bins</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">h</span><span class="p">,</span> <span class="n">bin_width</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">axvline</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">data</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]),</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">ylim</span><span class="p">(</span><span class="n">ylim</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{:s}</span><span class="s2">[</span><span class="si">{:d}</span><span class="s2">]&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">i</span><span class="p">))</span>
  <span class="k">if</span> <span class="n">fname</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>
  <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">plot_reg</span><span class="p">(</span><span class="n">xvals</span><span class="p">,</span> <span class="n">yvals</span><span class="p">,</span> <span class="n">poly</span><span class="p">,</span> <span class="n">x_label</span><span class="o">=</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="n">y_label</span><span class="o">=</span><span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="n">data_label</span><span class="o">=</span><span class="s2">&quot;data&quot;</span><span class="p">,</span>
             <span class="n">reg_label</span><span class="o">=</span><span class="s2">&quot;regression line&quot;</span><span class="p">,</span> <span class="n">fname</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Helper function to plot trend lines for line-fitting approaches. This</span>
<span class="sd">  function will show a plot through ``plt.show()`` and close it after the</span>
<span class="sd">  window has been closed by the user.</span>

<span class="sd">  Args:</span>
<span class="sd">    xvals (list/array of float):</span>
<span class="sd">      list of x-values</span>
<span class="sd">    yvals (list/array of float):</span>
<span class="sd">      list of y-values</span>
<span class="sd">    poly (list/array of float):</span>
<span class="sd">      polynomial parameters as accepted by ``np.polyval``</span>
<span class="sd">  Kwargs:</span>
<span class="sd">    x_label (str):</span>
<span class="sd">      label of the x-axis</span>
<span class="sd">    y_label (str):</span>
<span class="sd">      label of the y-axis</span>
<span class="sd">    data_label (str):</span>
<span class="sd">      label of the data</span>
<span class="sd">    reg_label(str):</span>
<span class="sd">      label of the regression line</span>
<span class="sd">    fname (str):</span>
<span class="sd">      file name (if not None, the plot will be saved to disc instead of</span>
<span class="sd">      showing it though ``plt.show()``)</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="c1"># local import to avoid dependency for non-debug use</span>
  <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
  <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xvals</span><span class="p">,</span> <span class="n">yvals</span><span class="p">,</span> <span class="s2">&quot;bo&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">data_label</span><span class="p">)</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">poly</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xvals</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">polyval</span><span class="p">(</span><span class="n">poly</span><span class="p">,</span> <span class="n">xvals</span><span class="p">),</span> <span class="s2">&quot;r-&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">reg_label</span><span class="p">)</span>
  <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="n">x_label</span><span class="p">)</span>
  <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="n">y_label</span><span class="p">)</span>
  <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s2">&quot;best&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">fname</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>
  <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">plot_reg_tiled</span><span class="p">(</span><span class="n">xvals</span><span class="p">,</span> <span class="n">yvals</span><span class="p">,</span> <span class="n">polys</span><span class="p">,</span> <span class="n">x_label</span><span class="o">=</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="n">y_label</span><span class="o">=</span><span class="s2">&quot;y&quot;</span><span class="p">,</span>
                   <span class="n">data_labels</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">reg_labels</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fname</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                   <span class="n">columns</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  TODO</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="c1"># local import to avoid dependency for non-debug use</span>
  <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
  <span class="n">max_span</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">yvals</span><span class="p">])</span>
  <span class="n">means</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">yvals</span><span class="p">]</span>
  <span class="k">if</span> <span class="n">columns</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">columns</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">xvals</span><span class="p">)))))</span>
  <span class="k">if</span> <span class="n">data_labels</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">data_labels</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;data&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">xvals</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">reg_labels</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">reg_labels</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;regression line&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">xvals</span><span class="p">)</span>
  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">xvals</span><span class="p">)):</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">xvals</span><span class="p">)</span> <span class="o">/</span> <span class="n">columns</span><span class="p">)),</span> <span class="n">columns</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xvals</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">yvals</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="s2">&quot;bo&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">data_labels</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">polys</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
      <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xvals</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">polyval</span><span class="p">(</span><span class="n">polys</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">xvals</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span> <span class="s2">&quot;r-&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">reg_labels</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="n">x_label</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="n">y_label</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">ylim</span><span class="p">(</span><span class="n">means</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">max_span</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">means</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">max_span</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s2">&quot;best&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">fname</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>
  <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">plot_reg_multiple</span><span class="p">(</span><span class="n">xvals</span><span class="p">,</span> <span class="n">yvals</span><span class="p">,</span> <span class="n">polys</span><span class="p">,</span> <span class="n">x_label</span><span class="o">=</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="n">y_label</span><span class="o">=</span><span class="s2">&quot;y&quot;</span><span class="p">,</span>
                      <span class="n">data_labels</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">reg_labels</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fname</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  TODO</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
  <span class="k">if</span> <span class="n">data_labels</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">data_labels</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;data&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">xvals</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">reg_labels</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">reg_labels</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;regression line&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">xvals</span><span class="p">)</span>
  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">xvals</span><span class="p">)):</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xvals</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">yvals</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="s2">&quot;+&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">data_labels</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">polys</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
      <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xvals</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">polyval</span><span class="p">(</span><span class="n">polys</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">xvals</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span> <span class="n">label</span><span class="o">=</span><span class="n">reg_labels</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
  <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="n">x_label</span><span class="p">)</span>
  <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="n">y_label</span><span class="p">)</span>
  <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s2">&quot;best&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">fname</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>
  <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>


<div class="viewcode-block" id="hurst_rs">
<a class="viewcode-back" href="../../nolds.html#nolds.hurst_rs">[docs]</a>
<span class="k">def</span> <span class="nf">hurst_rs</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">nvals</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fit</span><span class="o">=</span><span class="s2">&quot;RANSAC&quot;</span><span class="p">,</span> <span class="n">debug_plot</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
             <span class="n">debug_data</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">plot_file</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">corrected</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">unbiased</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Calculates the Hurst exponent by a standard rescaled range (R/S) approach.</span>

<span class="sd">  Explanation of Hurst exponent:</span>
<span class="sd">    The Hurst exponent is a measure for the &quot;long-term memory&quot; of a</span>
<span class="sd">    time series, meaning the long statistical dependencies in the data that do</span>
<span class="sd">    not originate from cycles.</span>

<span class="sd">    It originates from H.E. Hursts observations of the problem of long-term</span>
<span class="sd">    storage in water reservoirs. If x_i is the discharge of a river in year i</span>
<span class="sd">    and we observe this discharge for N years, we can calculate the storage</span>
<span class="sd">    capacity that would be required to keep the discharge steady at its mean</span>
<span class="sd">    value.</span>

<span class="sd">    To do so, we first subtract the mean over all x_i from the individual</span>
<span class="sd">    x_i to obtain the departures x&#39;_i from the mean for each year i. As the</span>
<span class="sd">    excess or deficit in discharge always carries over from year i to year i+1,</span>
<span class="sd">    we need to examine the cumulative sum of x&#39;_i, denoted by y_i. This</span>
<span class="sd">    cumulative sum represents the filling of our hypothetical storage. If the</span>
<span class="sd">    sum is above 0, we are storing excess discharge from the river, if it is</span>
<span class="sd">    below zero we have compensated a deficit in discharge by releasing</span>
<span class="sd">    water from the storage. The range (maximum - minimum) R of y_i therefore</span>
<span class="sd">    represents the total capacity required for the storage.</span>

<span class="sd">    Hurst showed that this value follows a steady trend for varying N if it</span>
<span class="sd">    is normalized by the standard deviation sigma over the x_i. Namely he</span>
<span class="sd">    obtained the following formula:</span>

<span class="sd">    R/sigma = (N/2)^K</span>

<span class="sd">    In this equation, K is called the Hurst exponent. Its value is 0.5 for</span>
<span class="sd">    white noise, but becomes greater for time series that exhibit some positive</span>
<span class="sd">    dependency on previous values. For negative dependencies it becomes less</span>
<span class="sd">    than 0.5.</span>

<span class="sd">  Explanation of the algorithm:</span>
<span class="sd">    The rescaled range (R/S) approach is directly derived from Hurst&#39;s</span>
<span class="sd">    definition. The time series of length N is split into non-overlapping</span>
<span class="sd">    subseries of length n. Then, R and S (S = sigma) are calculated for each</span>
<span class="sd">    subseries and the mean is taken over all subseries yielding (R/S)_n. This</span>
<span class="sd">    process is repeated for several lengths n. Finally, the exponent K is</span>
<span class="sd">    obtained by fitting a straight line to the plot of log((R/S)_n) vs log(n).</span>

<span class="sd">    There seems to be no consensus how to chose the subseries lenghts n.</span>
<span class="sd">    This function therefore leaves the choice to the user. The module provides</span>
<span class="sd">    some utility functions for &quot;typical&quot; values:</span>

<span class="sd">      * binary_n: N/2, N/4, N/8, ...</span>
<span class="sd">      * logarithmic_n: min_n, min_n * f, min_n * f^2, ...</span>

<span class="sd">  References:</span>
<span class="sd">    .. [h_1] H. E. Hurst, “The problem of long-term storage in reservoirs,”</span>
<span class="sd">       International Association of Scientific Hydrology. Bulletin, vol. 1,</span>
<span class="sd">       no. 3, pp. 13–27, 1956.</span>
<span class="sd">    .. [h_2] H. E. Hurst, “A suggested statistical model of some time series</span>
<span class="sd">       which occur in nature,” Nature, vol. 180, p. 494, 1957.</span>
<span class="sd">    .. [h_3] R. Weron, “Estimating long-range dependence: finite sample</span>
<span class="sd">       properties and confidence intervals,” Physica A: Statistical Mechanics</span>
<span class="sd">       and its Applications, vol. 312, no. 1, pp. 285–299, 2002.</span>

<span class="sd">  Reference Code:</span>
<span class="sd">    .. [h_a] &quot;hurst&quot; function in R-package &quot;pracma&quot;,</span>
<span class="sd">             url: https://cran.r-project.org/web/packages/pracma/pracma.pdf</span>

<span class="sd">             Note: Pracma yields several estimates of the Hurst exponent, which</span>
<span class="sd">             are listed below. Unless otherwise stated they use the divisors</span>
<span class="sd">             of the length of the sequence as n. The length is reduced by at</span>
<span class="sd">             most 1% to find the value that has the most divisors.</span>

<span class="sd">             * The &quot;Simple R/S&quot; estimate is just log((R/S)_n) / log(n) for</span>
<span class="sd">               n = N.</span>
<span class="sd">             * The &quot;theoretical Hurst exponent&quot; is the value that would be</span>
<span class="sd">               expected of an uncorrected rescaled range approach for random</span>
<span class="sd">               noise of the size of the input data.</span>
<span class="sd">             * The &quot;empirical Hurst exponent&quot; is the uncorrected Hurst exponent</span>
<span class="sd">               obtained by the rescaled range approach.</span>
<span class="sd">             * The &quot;corrected empirical Hurst exponent&quot; is the</span>
<span class="sd">               Anis-Lloyd-Peters corrected Hurst exponent, but with</span>
<span class="sd">               sqrt(1/2 * pi * n) added to the (R/S)_n before the log.</span>
<span class="sd">             * The &quot;corrected R over S Hurst exponent&quot; uses the R-function &quot;lm&quot;</span>
<span class="sd">               instead of pracmas own &quot;polyfit&quot; and uses n = N/2, N/4, N/8, ...</span>
<span class="sd">               by successively halving the subsequences (which means that some</span>
<span class="sd">               subsequences may be one element longer than others). In contrast</span>
<span class="sd">               to its name it does not use the Anis-Lloyd-Peters correction</span>
<span class="sd">               factor.</span>

<span class="sd">             If you want to compare the output of pracma to the output of</span>
<span class="sd">             nolds, the &quot;empirical hurst exponent&quot; is the only measure that</span>
<span class="sd">             exactly corresponds to the Hurst measure implemented in nolds</span>
<span class="sd">             (by choosing corrected=False, fit=&quot;poly&quot; and employing the same</span>
<span class="sd">             strategy for choosing n as the divisors of the (reduced)</span>
<span class="sd">             sequence length).</span>
<span class="sd">    .. [h_b] Rafael Weron, &quot;HURST: MATLAB function to compute the Hurst</span>
<span class="sd">             exponent using R/S Analysis&quot;,</span>
<span class="sd">             url: https://ideas.repec.org/c/wuu/hscode/m11003.html</span>

<span class="sd">             Note: When the same values for nvals are used and fit is set to</span>
<span class="sd">             &quot;poly&quot;, nolds yields exactly the same results as this</span>
<span class="sd">             implementation.</span>
<span class="sd">    .. [h_c] Bill Davidson, &quot;Hurst exponent&quot;,</span>
<span class="sd">             url: http://www.mathworks.com/matlabcentral/fileexchange/9842-hurst-exponent</span>

<span class="sd">  Args:</span>
<span class="sd">    data (array-like of float):</span>
<span class="sd">      time series</span>
<span class="sd">  Kwargs:</span>
<span class="sd">    nvals (iterable of int):</span>
<span class="sd">      sizes of subseries to use</span>
<span class="sd">      (default: logmid_n(total_N, ratio=1/4.0, nsteps=15) , that is 15</span>
<span class="sd">      logarithmically spaced values in the medium 25% of the logarithmic range)</span>

<span class="sd">      Generally, the choice for n is a trade-off between the length and the</span>
<span class="sd">      number of the subsequences that are used for the calculation of the</span>
<span class="sd">      (R/S)_n. Very low values of n lead to high variance in the ``r`` and</span>
<span class="sd">      ``s`` while very high values may leave too few subsequences that the mean</span>
<span class="sd">      along them is still meaningful. Logarithmic spacing makes sense, because</span>
<span class="sd">      it translates to even spacing in the log-log-plot.</span>
<span class="sd">    fit (str):</span>
<span class="sd">      the fitting method to use for the line fit, either &#39;poly&#39; for normal</span>
<span class="sd">      least squares polynomial fitting or &#39;RANSAC&#39; for RANSAC-fitting which</span>
<span class="sd">      is more robust to outliers</span>
<span class="sd">    debug_plot (boolean):</span>
<span class="sd">      if True, a simple plot of the final line-fitting step will be shown</span>
<span class="sd">    debug_data (boolean):</span>
<span class="sd">      if True, debugging data will be returned alongside the result</span>
<span class="sd">    plot_file (str):</span>
<span class="sd">      if debug_plot is True and plot_file is not None, the plot will be saved</span>
<span class="sd">      under the given file name instead of directly showing it through</span>
<span class="sd">      ``plt.show()``</span>
<span class="sd">    corrected (boolean):</span>
<span class="sd">      if True, the Anis-Lloyd-Peters correction factor will be applied to the</span>
<span class="sd">      output according to the expected value for the individual (R/S)_n</span>
<span class="sd">      (see [h_3]_)</span>
<span class="sd">    unbiased (boolean):</span>
<span class="sd">      if True, the standard deviation based on the unbiased variance</span>
<span class="sd">      (1/(N-1) instead of 1/N) will be used. This should be the default choice,</span>
<span class="sd">      since the true mean of the sequences is not known. This parameter should</span>
<span class="sd">      only be changed to recreate results of other implementations.</span>

<span class="sd">  Returns:</span>
<span class="sd">    float:</span>
<span class="sd">      estimated Hurst exponent K using a rescaled range approach (if K = 0.5</span>
<span class="sd">      there are no long-range correlations in the data, if K &lt; 0.5 there are</span>
<span class="sd">      negative long-range correlations, if K &gt; 0.5 there are positive</span>
<span class="sd">      long-range correlations)</span>
<span class="sd">    (1d-vector, 1d-vector, list):</span>
<span class="sd">      only present if debug_data is True: debug data of the form</span>
<span class="sd">      ``(nvals, rsvals, poly)`` where ``nvals`` are the values used for log(n),</span>
<span class="sd">      ``rsvals`` are the corresponding log((R/S)_n) and ``poly`` are the line</span>
<span class="sd">      coefficients (``[slope, intercept]``)</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
  <span class="n">total_N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">nvals</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="c1"># chooses a default value for nvals that will give 15 logarithmically</span>
    <span class="c1"># spaced datapoints leaning towards the middle of the logarithmic range</span>
    <span class="c1"># (since both too small and too large n introduce too much variance)</span>
    <span class="n">nvals</span> <span class="o">=</span> <span class="n">logmid_n</span><span class="p">(</span><span class="n">total_N</span><span class="p">,</span> <span class="n">ratio</span><span class="o">=</span><span class="mi">1</span><span class="o">/</span><span class="mf">4.0</span><span class="p">,</span> <span class="n">nsteps</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>
  <span class="c1"># get individual values for (R/S)_n</span>
  <span class="n">rsvals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">rs</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">unbiased</span><span class="o">=</span><span class="n">unbiased</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">nvals</span><span class="p">])</span>
  <span class="c1"># filter NaNs (zeros should not be possible, because if R is 0 then</span>
  <span class="c1"># S is also zero)</span>
  <span class="n">not_nan</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">rsvals</span><span class="p">))</span>
  <span class="n">rsvals</span> <span class="o">=</span> <span class="n">rsvals</span><span class="p">[</span><span class="n">not_nan</span><span class="p">]</span>
  <span class="n">nvals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">nvals</span><span class="p">)[</span><span class="n">not_nan</span><span class="p">]</span>
  <span class="c1"># it may happen that no rsvals are left (if all values of data are the same)</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">rsvals</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="n">poly</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">debug_plot</span><span class="p">:</span>
      <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
        <span class="s2">&quot;Cannot display debug plot, all (R/S)_n are NaN&quot;</span><span class="p">,</span>
        <span class="ne">RuntimeWarning</span>
      <span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="c1"># fit a line to the logarithm of the obtained (R/S)_n</span>
    <span class="n">xvals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">nvals</span><span class="p">)</span>
    <span class="n">yvals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">rsvals</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">corrected</span><span class="p">:</span>
      <span class="n">yvals</span> <span class="o">-=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">([</span><span class="n">expected_rs</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">nvals</span><span class="p">])</span>
    <span class="n">poly</span> <span class="o">=</span> <span class="n">poly_fit</span><span class="p">(</span><span class="n">xvals</span><span class="p">,</span> <span class="n">yvals</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">fit</span><span class="o">=</span><span class="n">fit</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">debug_plot</span><span class="p">:</span>
      <span class="n">plot_reg</span><span class="p">(</span><span class="n">xvals</span><span class="p">,</span> <span class="n">yvals</span><span class="p">,</span> <span class="n">poly</span><span class="p">,</span> <span class="s2">&quot;log(n)&quot;</span><span class="p">,</span> <span class="s2">&quot;log((R/S)_n)&quot;</span><span class="p">,</span>
               <span class="n">fname</span><span class="o">=</span><span class="n">plot_file</span><span class="p">)</span>
  <span class="c1"># account for correction if necessary</span>
  <span class="n">h</span> <span class="o">=</span> <span class="n">poly</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mf">0.5</span> <span class="k">if</span> <span class="n">corrected</span> <span class="k">else</span> <span class="n">poly</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
  <span class="c1"># return line slope (+ correction) as hurst exponent</span>
  <span class="k">if</span> <span class="n">debug_data</span><span class="p">:</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">nvals</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">rsvals</span><span class="p">),</span> <span class="n">poly</span><span class="p">))</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">h</span></div>


<span class="c1"># TODO implement MFDFA as second (more reliable) measure for multifractality</span>
<span class="c1"># NOTE: probably not needed, since mfhurst_b is already pretty reliable</span>


<div class="viewcode-block" id="mfhurst_b">
<a class="viewcode-back" href="../../nolds.html#nolds.mfhurst_b">[docs]</a>
<span class="k">def</span> <span class="nf">mfhurst_b</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">qvals</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dists</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fit</span><span class="o">=</span><span class="s1">&#39;poly&#39;</span><span class="p">,</span>
              <span class="n">debug_plot</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">debug_data</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">plot_file</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Calculates the Generalized Hurst Exponent H_q for different q according to</span>
<span class="sd">  A.-L. Barabási and T. Vicsek.</span>

<span class="sd">  Explanation of the Generalized Hurst Exponent:</span>
<span class="sd">    The Generalized Hurst Exponent (GHE, H_q or H(q)) can (as the name implies)</span>
<span class="sd">    be seen as a generalization of the Hurst exponent for data series with</span>
<span class="sd">    multifractal properties. It&#39;s origins are however not directly related</span>
<span class="sd">    to Hurst&#39;s rescaled range approach, but to the definition of self-affine</span>
<span class="sd">    functions.</span>

<span class="sd">    A single-valued self-affine function h by definition satisfies the relation</span>

<span class="sd">      h(x) ~= lambda^(-H) h(lambda x)</span>

<span class="sd">    for any positive real valued lambda and some positive real valued exponent</span>
<span class="sd">    H, which is called the Hurst, Hölder, Hurst-Hölder or roughness exponent</span>
<span class="sd">    in the literature. In other words you can view lambda as a scaling factor</span>
<span class="sd">    or &quot;step size&quot;. With lambda &lt; 1 we decrease the step size and zoom into our</span>
<span class="sd">    function. In this case lambda^(-H) becomes greater than one, meaning that</span>
<span class="sd">    h(lambda x) looks similar to a smaller version of h(x). With lambda &gt; 1 we</span>
<span class="sd">    zoom out and get lambda^(-H) &lt; 1.</span>

<span class="sd">    To calculate H, you can use the height-height correlation function (also</span>
<span class="sd">    called autocorrelation) c(d) = &lt;(h(x) - h(x + d))^2&gt;_x where &lt;...&gt;_x</span>
<span class="sd">    denotes the expected value over x. Here, the aforementioned self-affine</span>
<span class="sd">    property is equivalent to c(d) ~ d^(2H). You can also think of d as a step</span>
<span class="sd">    size. Increasing or decreasing d from 1 to some y is the same as setting</span>
<span class="sd">    lambda = y: It increases or decreases the scale of the function by a factor</span>
<span class="sd">    of 1/y^(-H) = y^H. Therefore the squared differences will be proportional</span>
<span class="sd">    to y^2H.</span>

<span class="sd">    A.-L. Barabási and T. Vicsek extended this notion to an infinite hierarchy</span>
<span class="sd">    of exponents H_q for the qth-order correlation function with</span>

<span class="sd">      c_q(d) = &lt;(h(x) - h(x + d))^q&gt;_x ~ d^(q H_q)</span>

<span class="sd">    With q = 1 you get a value H_1 that is closely related to the normal Hurst</span>
<span class="sd">    exponent, but with different q you either get a constant value H_q = H_0</span>
<span class="sd">    independent of q, which indicates that the function has no multifractal</span>
<span class="sd">    properties, or different H_q, which is a sign for multifractal behavior.</span>

<span class="sd">    T. Di Matteo, T. Aste and M. M. Dacorogna applied this technique to</span>
<span class="sd">    financial data series and gave it the name &quot;Generalized Hurst Exponent&quot;.</span>

<span class="sd">  Explanation of the Algorithm:</span>
<span class="sd">    Curiously, I could not find any algorithmic description how to calculate</span>
<span class="sd">    H_q in the literature. Researchers seem to just imply that you can obtain</span>
<span class="sd">    the exponent by a line fitting algorithm in a log-log plot, but they do not</span>
<span class="sd">    talk about the actual procedure or the required parameters.</span>

<span class="sd">    Essentially, we can calculate c_q(d) of a discrete evenly sampled time</span>
<span class="sd">    series Y = [y_0, y_1, y_2, ... y_(N-1)] by taking the absolute differences</span>
<span class="sd">    [|y_0 - y_d|, |y_1 - y_(d+1)|, ... , |y_(N-d-1) - y_(N-1)|] raising them to</span>
<span class="sd">    the qth power and taking the mean.</span>

<span class="sd">    Now we take the logarithm on both sides of our relation c_q(d) ~ d^(q H_q)</span>
<span class="sd">    and get</span>

<span class="sd">    log(c_q(d)) ~ log(d) * q H_q</span>

<span class="sd">    So in other words if we plot log(c_q(d)) against log(d) for several d we</span>
<span class="sd">    should get a straight line with slope q H_q. This enables us to use a</span>
<span class="sd">    linear least squares algorithm to obtain H_q.</span>

<span class="sd">    Note that we consider x as a discrete variable in the range 0 &lt;= x &lt; N.</span>
<span class="sd">    We can do this, because the actual sampling rate of our data series does</span>
<span class="sd">    not alter the result. After taking the logarithm any scaling factor delta_x</span>
<span class="sd">    would only result in an additive term since</span>
<span class="sd">    log(delta_x * x) = log(x) + log(delta_x) and we only care about the slope</span>
<span class="sd">    of the line and not the intercept.</span>

<span class="sd">  References:</span>
<span class="sd">    .. [mh_1] A.-L. Barabási and T. Vicsek, “Multifractality of self-affine</span>
<span class="sd">       fractals,” Physical Review A, vol. 44, no. 4, pp. 2730–2733, 1991.</span>

<span class="sd">  Args:</span>
<span class="sd">    data (array-like of float):</span>
<span class="sd">      time series of data points (should be evenly sampled)</span>

<span class="sd">  Kwargs:</span>
<span class="sd">    qvals (iterable of float or int):</span>
<span class="sd">      values of q for which H_q should be calculated (default: [1])</span>
<span class="sd">    dists (iterable of int):</span>
<span class="sd">      distances for which the height-height correlation should be calculated</span>
<span class="sd">      (determines the x-coordinates in the log-log plot)</span>
<span class="sd">      default: logarithmic_n(1, max(20, 0.02 * len(data)), 1.5) to ensure</span>
<span class="sd">      even spacing on the logarithmic axis</span>
<span class="sd">    fit (str):</span>
<span class="sd">      the fitting method to use for the line fit, either &#39;poly&#39; for normal</span>
<span class="sd">      least squares polynomial fitting or &#39;RANSAC&#39; for RANSAC-fitting which</span>
<span class="sd">      is more robust to outliers</span>
<span class="sd">    debug_plot (boolean):</span>
<span class="sd">      if True, a simple plot of the final line-fitting step will be shown</span>
<span class="sd">    debug_data (boolean):</span>
<span class="sd">      if True, debugging data will be returned alongside the result</span>
<span class="sd">    plot_file (str):</span>
<span class="sd">      if debug_plot is True and plot_file is not None, the plot will be saved</span>
<span class="sd">      under the given file name instead of directly showing it through</span>
<span class="sd">      ``plt.show()``</span>

<span class="sd">  Returns:</span>
<span class="sd">    array of float:</span>
<span class="sd">      list of H_q for every q given in ``qvals``</span>
<span class="sd">    (1d-vector, 2d-vector, 2d-vector):</span>
<span class="sd">      only present if debug_data is True: debug data of the form</span>
<span class="sd">      ``(xvals, yvals, poly)`` where ``xvals`` is the logarithm of ``dists``,</span>
<span class="sd">      ``yvals`` are the logarithms of the corresponding height-height-</span>
<span class="sd">      correlations for each distance (first dimension) and each q</span>
<span class="sd">      (second dimension) in the shape len(dists) x len(qvals) and ``poly`` are</span>
<span class="sd">      the line coefficients (``[slope, intercept]``) for each q in the shape</span>
<span class="sd">      len(qvals) x 2.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="c1"># transform to array if necessary</span>
  <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">qvals</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="c1"># actual default parameter would introduce shared list</span>
    <span class="c1"># see: http://pylint-messages.wikidot.com/messages:w0102</span>
    <span class="n">qvals</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>
  <span class="k">if</span> <span class="n">dists</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">dists</span> <span class="o">=</span> <span class="n">logarithmic_n</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mf">0.02</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)),</span> <span class="mf">1.5</span><span class="p">)</span>
  <span class="n">dists</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">dists</span><span class="p">)</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">60</span><span class="p">:</span>
    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
      <span class="s2">&quot;H(q) is not reliable for small time series (</span><span class="si">{}</span><span class="s2"> &lt; 60)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
    <span class="p">)</span>

  <span class="k">def</span> <span class="nf">hhcorr</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">q</span><span class="p">):</span>
    <span class="n">diffs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">data</span><span class="p">[:</span><span class="o">-</span><span class="n">d</span><span class="p">]</span> <span class="o">-</span> <span class="n">data</span><span class="p">[</span><span class="n">d</span><span class="p">:])</span>
    <span class="n">diffs</span> <span class="o">=</span> <span class="n">diffs</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">diffs</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)]</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">diffs</span> <span class="o">**</span> <span class="n">q</span><span class="p">)</span>

  <span class="c1"># calculate height-height correlations</span>
  <span class="n">corrvals</span> <span class="o">=</span> <span class="p">[</span><span class="n">hhcorr</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">dists</span> <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="n">qvals</span><span class="p">]</span>
  <span class="n">corrvals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">corrvals</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
  <span class="n">corrvals</span> <span class="o">=</span> <span class="n">corrvals</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dists</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">qvals</span><span class="p">))</span>

  <span class="c1"># line fitting</span>
  <span class="n">xvals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">dists</span><span class="p">)</span>
  <span class="n">yvals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">corrvals</span><span class="p">)</span>
  <span class="n">polys</span> <span class="o">=</span> <span class="p">[</span>
    <span class="n">poly_fit</span><span class="p">(</span><span class="n">xvals</span><span class="p">,</span> <span class="n">yvals</span><span class="p">[:,</span> <span class="n">qi</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span> <span class="n">fit</span><span class="o">=</span><span class="n">fit</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">qi</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">qvals</span><span class="p">))</span>
  <span class="p">]</span>
  <span class="n">H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">polys</span><span class="p">)[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">qvals</span>
  <span class="k">if</span> <span class="n">debug_plot</span><span class="p">:</span>
    <span class="n">plot_reg_multiple</span><span class="p">(</span>
      <span class="p">[</span><span class="n">xvals</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">qvals</span><span class="p">),</span>
      <span class="p">[</span><span class="n">yvals</span><span class="p">[:,</span> <span class="n">qi</span><span class="p">]</span> <span class="o">/</span> <span class="n">qvals</span><span class="p">[</span><span class="n">qi</span><span class="p">]</span> <span class="k">for</span> <span class="n">qi</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">qvals</span><span class="p">))],</span>
      <span class="p">[</span><span class="n">p</span> <span class="o">/</span> <span class="n">q</span> <span class="k">for</span> <span class="n">p</span><span class="p">,</span> <span class="n">q</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">polys</span><span class="p">,</span> <span class="n">qvals</span><span class="p">)],</span>
      <span class="n">x_label</span><span class="o">=</span><span class="s2">&quot;log(x)&quot;</span><span class="p">,</span> <span class="n">y_label</span><span class="o">=</span><span class="s2">&quot;$</span><span class="se">\\</span><span class="s2">log(c_q(x)) / q$&quot;</span><span class="p">,</span>
      <span class="n">data_labels</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;q = </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">q</span> <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="n">qvals</span><span class="p">],</span>
      <span class="n">reg_labels</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;reg. line (H = </span><span class="si">{:.3f}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">h</span><span class="p">)</span> <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">H</span><span class="p">],</span>
      <span class="n">fname</span><span class="o">=</span><span class="n">plot_file</span>
    <span class="p">)</span>
  <span class="k">if</span> <span class="n">debug_data</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">H</span><span class="p">,</span> <span class="p">(</span><span class="n">xvals</span><span class="p">,</span> <span class="n">yvals</span><span class="p">,</span> <span class="n">polys</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">H</span></div>



<span class="k">def</span> <span class="nf">_genhurst</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">q</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the generalized hurst exponent H_q for time series S.</span>

<span class="sd">    This function should not be used. It is only kept here to demonstrate that</span>
<span class="sd">    ``mfhurst_dm`` is implemented correctly. You can use the following call to</span>
<span class="sd">    get the exact same result:</span>

<span class="sd">    ``mfhurst_dm(S, [q])``</span>

<span class="sd">    Reference code:</span>
<span class="sd">      .. [gh_a] Tomaso Aste, &quot;Generalized Hurst exponent&quot;,</span>
<span class="sd">         url: http://de.mathworks.com/matlabcentral/fileexchange/30076-generalized-hurst-exponent</span>
<span class="sd">      .. [gh_b] Peter Rupprecht, &quot;GenHurst&quot;,</span>
<span class="sd">         url: https://github.com/PTRRupprecht/GenHurst</span>

<span class="sd">    Below you can find the original documentation by T. Aste:</span>

<span class="sd">    ####################################</span>
<span class="sd">    # Calculates the generalized Hurst exponent H(q) from the scaling</span>
<span class="sd">    # of the renormalized q-moments of the distribution</span>
<span class="sd">    #</span>
<span class="sd">    #       &lt;|x(t+r)-x(t)|^q&gt;/&lt;x(t)^q&gt; ~ r^[qH(q)]</span>
<span class="sd">    #</span>
<span class="sd">    ####################################</span>
<span class="sd">    # H = genhurst(S,q)</span>
<span class="sd">    # S is 1xT data series (T&gt;50 recommended)</span>
<span class="sd">    # calculates H, specifies the exponent q</span>
<span class="sd">    #</span>
<span class="sd">    # example:</span>
<span class="sd">    #   generalized Hurst exponent for a random vector</span>
<span class="sd">    #   H=genhurst(np.random.rand(10000,1),3)</span>
<span class="sd">    #</span>
<span class="sd">    ####################################</span>
<span class="sd">    # for the generalized Hurst exponent method please refer to:</span>
<span class="sd">    #</span>
<span class="sd">    #   T. Di Matteo et al. Physica A 324 (2003) 183-188</span>
<span class="sd">    #   T. Di Matteo et al. Journal of Banking &amp; Finance 29 (2005) 827-851</span>
<span class="sd">    #   T. Di Matteo Quantitative Finance, 7 (2007) 21-36</span>
<span class="sd">    #</span>
<span class="sd">    ####################################</span>
<span class="sd">    ##   written in Matlab : Tomaso Aste, 30/01/2013 ##</span>
<span class="sd">    ##   translated to Python (3.6) : Peter Rupprecht, p.t.r.rupprecht (AT) gmail.com, 25/05/2017 ##</span>
<span class="sd">    ##   formatting and datatype fixes : Christopher Schölzel, 17/02/2019 ##</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">L</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">L</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Data series very short!&#39;</span><span class="p">)</span>
    <span class="n">H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">20</span><span class="p">)),</span> <span class="mi">1</span><span class="p">))</span>
    <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">for</span> <span class="n">Tmax</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">20</span><span class="p">):</span>

        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">Tmax</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">mcord</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">Tmax</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">tt</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">Tmax</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">dV</span> <span class="o">=</span> <span class="n">S</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">tt</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">tt</span><span class="p">)]</span> <span class="o">-</span> <span class="n">S</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">tt</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">tt</span><span class="p">)</span><span class="o">-</span><span class="n">tt</span><span class="p">]</span>
            <span class="n">VV</span> <span class="o">=</span> <span class="n">S</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">tt</span><span class="p">,</span> <span class="n">L</span><span class="o">+</span><span class="n">tt</span><span class="p">,</span> <span class="n">tt</span><span class="p">)</span><span class="o">-</span><span class="n">tt</span><span class="p">]</span>
            <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dV</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
            <span class="n">Y</span> <span class="o">=</span> <span class="n">VV</span>
            <span class="n">mx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">X</span><span class="p">)</span><span class="o">/</span><span class="n">N</span>
            <span class="n">SSxx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">X</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="n">N</span><span class="o">*</span><span class="n">mx</span><span class="o">**</span><span class="mi">2</span>
            <span class="n">my</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">Y</span><span class="p">)</span><span class="o">/</span><span class="n">N</span>
            <span class="n">SSxy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">))</span> <span class="o">-</span> <span class="n">N</span><span class="o">*</span><span class="n">mx</span><span class="o">*</span><span class="n">my</span>
            <span class="n">cc1</span> <span class="o">=</span> <span class="n">SSxy</span><span class="o">/</span><span class="n">SSxx</span>
            <span class="n">cc2</span> <span class="o">=</span> <span class="n">my</span> <span class="o">-</span> <span class="n">cc1</span><span class="o">*</span><span class="n">mx</span>
            <span class="n">ddVd</span> <span class="o">=</span> <span class="n">dV</span> <span class="o">-</span> <span class="n">cc1</span>
            <span class="n">VVVd</span> <span class="o">=</span> <span class="n">VV</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">cc1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">))</span> \
                      <span class="o">-</span> <span class="n">cc2</span>
            <span class="n">mcord</span><span class="p">[</span><span class="n">tt</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">ddVd</span><span class="p">)</span><span class="o">**</span><span class="n">q</span><span class="p">)</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">VVVd</span><span class="p">)</span><span class="o">**</span><span class="n">q</span><span class="p">)</span>
        <span class="n">mx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
        <span class="n">SSxx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="n">Tmax</span><span class="o">*</span><span class="n">mx</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">my</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">mcord</span><span class="p">))</span>
        <span class="n">SSxy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
          <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">mcord</span><span class="p">))</span>
          <span class="p">)</span>
        <span class="p">)</span> <span class="o">-</span> <span class="n">Tmax</span><span class="o">*</span><span class="n">mx</span><span class="o">*</span><span class="n">my</span>
        <span class="n">H</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">SSxy</span><span class="o">/</span><span class="n">SSxx</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">mH</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">H</span><span class="p">)</span><span class="o">/</span><span class="n">q</span>

    <span class="k">return</span> <span class="n">mH</span>


<span class="k">def</span> <span class="nf">_aste_line_fit</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Simple linear regression with ordinary least squares</span>
<span class="sd">  https://en.wikipedia.org/wiki/Simple_linear_regression</span>

<span class="sd">  NOTE: this function is left here to demonstrate the correctness of</span>
<span class="sd">  T. Aste&#39;s MATLAB code for hurst_multifractal_dm. You can get the same</span>
<span class="sd">  results with a call to ``np.polyfit(x, y, 1)[::-1]``.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="c1"># convert to float to avoid integer overflow problems</span>
  <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
  <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
  <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
  <span class="n">mx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
  <span class="n">my</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
  <span class="c1"># calculate the variance in x</span>
  <span class="c1"># sum((x - mx) ^ 2) = sum(x ^ 2) - 2 * sum(x * mx) + N * mx ^ 2</span>
  <span class="c1">#                   = sum(x ^ 2) - 2 * mx * sum(x) + N * mx ^ 2</span>
  <span class="c1">#                   = sum(x ^ 2) - 2 * mx * N * mx + N * mx ^ 2</span>
  <span class="c1">#                   = sum(x ^ 2) - N * mx ^ 2</span>
  <span class="n">var</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">x</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="n">N</span> <span class="o">*</span> <span class="n">mx</span> <span class="o">*</span> <span class="n">mx</span>
  <span class="c1"># corvariance of x and y</span>
  <span class="c1"># sum((x - mx) * (y - my))</span>
  <span class="c1">#   = sum(xy) - sum(mx * y) - sum(my * x) + N * mx * my</span>
  <span class="c1">#   = sum(xy) - mx * sum(y) - my * sum(x) + N * mx * my</span>
  <span class="c1">#   = sum(xy) - mx * my * N - my * mx * N + N * mx * my</span>
  <span class="c1">#   = sum(xy) - N * mx * my</span>
  <span class="c1"># NOTE: T. Aste&#39;s code is a little confusing here</span>
  <span class="c1">#    X = 1:N;</span>
  <span class="c1">#    Y = S(((tt+1):tt:(L+tt))-tt)&#39;;</span>
  <span class="c1">#    ...</span>
  <span class="c1">#    SSxy = sum(X.*Y) - N*mx*my;</span>
  <span class="c1"># Here, Y is transposed and the multiplication for SSxy uses .* instead of *.</span>
  <span class="c1"># This suggests that we have a matrix multiplication with (possible)</span>
  <span class="c1"># broadcasting. If X was an array and not a range, we would have a NxN array</span>
  <span class="c1"># as a result since size(X) = [1, N] and size(Y) = [N, 1]. Ranges behave</span>
  <span class="c1"># differently in MATLAB and this is the only reason why we get the correct</span>
  <span class="c1"># result here.</span>
  <span class="n">cov</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="n">y</span><span class="p">)</span> <span class="o">-</span> <span class="n">N</span> <span class="o">*</span> <span class="n">mx</span> <span class="o">*</span> <span class="n">my</span>
  <span class="c1"># calculate slope and intercept (this is correct again)</span>
  <span class="n">slope</span> <span class="o">=</span> <span class="n">cov</span> <span class="o">/</span> <span class="n">var</span>
  <span class="n">intercept</span> <span class="o">=</span> <span class="n">my</span> <span class="o">-</span> <span class="n">slope</span> <span class="o">*</span> <span class="n">mx</span>
  <span class="k">return</span> <span class="p">[</span><span class="n">intercept</span><span class="p">,</span> <span class="n">slope</span><span class="p">]</span>


<div class="viewcode-block" id="mfhurst_dm">
<a class="viewcode-back" href="../../nolds.html#nolds.mfhurst_dm">[docs]</a>
<span class="k">def</span> <span class="nf">mfhurst_dm</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">qvals</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">max_dists</span><span class="o">=</span><span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">20</span><span class="p">),</span> <span class="n">detrend</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
               <span class="n">fit</span><span class="o">=</span><span class="s2">&quot;poly&quot;</span><span class="p">,</span> <span class="n">debug_plot</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">debug_data</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">plot_file</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Calculates the Generalized Hurst Exponent H_q for different q according to</span>
<span class="sd">  the MATLAB code of Tomaso Aste - one of the authors that introduced this</span>
<span class="sd">  measure.</span>

<span class="sd">  Explanation of the General Hurst Exponent:</span>
<span class="sd">    See mfhurst_b.</span>

<span class="sd">  Warning: I do not recommend to use this function unless you want to reproduce</span>
<span class="sd">  examples from Di Matteo et al.. From my experiments and a critical code</span>
<span class="sd">  analysis it seems that mfhurst_b should provide more robust results.</span>

<span class="sd">  The design choices that make mfhurst_dm different than mfhurst_d are the</span>
<span class="sd">  following:</span>

<span class="sd">  - By default, a linear trend is removed from the data. This can be sensible</span>
<span class="sd">      in some application areas (such as stock market analysis), but I think</span>
<span class="sd">      this should be an additional preprocessing step and not part of this</span>
<span class="sd">      algorithm.</span>
<span class="sd">  - In the calculation of the height-height correlations, the differences</span>
<span class="sd">      (h(x) - h(x + d) are not calculated for every possible x from 0 to N-d-1,</span>
<span class="sd">      but instead d is used as a step size for x. I see no justification for</span>
<span class="sd">      this choice. It makes the algorithm run faster, but it also takes away</span>
<span class="sd">      a lot of statistical robustness, especially for large values of d.</span>
<span class="sd">      This effect can be clearly seen when setting `debug_plot` to `True`.</span>
<span class="sd">  - The algorithm uses a linear scale for the distance values d = 1, 2, 3,</span>
<span class="sd">      ..., tau_max. This is counter intuitive, since we later plot log(d)</span>
<span class="sd">      against log(c_q(d)). A linear scale will have a bias towards larger</span>
<span class="sd">      values in the logarithmic scale. A logarithmic scale for d seems to be</span>
<span class="sd">      a more natural fit. If low values of d yield statistically unstable</span>
<span class="sd">      results, they should simply be omitted.</span>
<span class="sd">  - The algorithm tests multiple values for tau_max, which is the maximum</span>
<span class="sd">      distance that will be calculated. In [mhd_1]_ the authors state that this</span>
<span class="sd">      is done to test the robustness of the approach. However, taking the</span>
<span class="sd">      mean of several runs with different tau_max will not produce any more</span>
<span class="sd">      information than performing one run with the largest tau_max. Instead</span>
<span class="sd">      it will only introduce a bias towards low values for d.</span>

<span class="sd">  References:</span>
<span class="sd">    .. [mhd_1] T. Di Matteo, T. Aste, and M. M. Dacorogna, “Scaling behaviors</span>
<span class="sd">       in differently developed markets,” Physica A: Statistical Mechanics</span>
<span class="sd">       and its Applications, vol. 324, no. 1–2, pp. 183–188, 2003.</span>

<span class="sd">  Reference code:</span>
<span class="sd">    .. [mhd_a] Tomaso Aste, &quot;Generalized Hurst exponent&quot;,</span>
<span class="sd">       url: http://de.mathworks.com/matlabcentral/fileexchange/30076-generalized-hurst-exponent</span>

<span class="sd">  Args:</span>
<span class="sd">    data (1d-vector of float):</span>
<span class="sd">      input data (should be evenly sampled)</span>
<span class="sd">    qvals (1d-vector of float)</span>
<span class="sd">      values of q for which H_q should be calculated (default: [1])</span>

<span class="sd">  Kwargs:</span>
<span class="sd">    max_dists (1d-vector of int):</span>
<span class="sd">      different values to test for tau_max, the maximum value for the distance</span>
<span class="sd">      d. The resulting H_q will be a mean of all H_q calculated with tau_max</span>
<span class="sd">      = max_dists[0], max_dists[1], ... .</span>
<span class="sd">    detrend (boolean):</span>
<span class="sd">      if True, a linear trend will be removed from the data before H_q will</span>
<span class="sd">      be calculated</span>
<span class="sd">    fit (str):</span>
<span class="sd">      the fitting method to use for the line fit, either &#39;poly&#39; for normal</span>
<span class="sd">      least squares polynomial fitting or &#39;RANSAC&#39; for RANSAC-fitting which</span>
<span class="sd">      is more robust to outliers</span>
<span class="sd">    debug_plot (boolean):</span>
<span class="sd">      if True, a simple plot of the final line-fitting step will be shown</span>
<span class="sd">    debug_data (boolean):</span>
<span class="sd">      if True, debugging data will be returned alongside the result</span>
<span class="sd">    plot_file (str):</span>
<span class="sd">      if debug_plot is True and plot_file is not None, the plot will be saved</span>
<span class="sd">      under the given file name instead of directly showing it through</span>
<span class="sd">      ``plt.show()``</span>

<span class="sd">  Returns:</span>
<span class="sd">    array of float:</span>
<span class="sd">      array of mH_q for every q given in ``qvals`` where mH_q is the mean of</span>
<span class="sd">      all H_q calculated for different max distances in max_dists.</span>
<span class="sd">    array of float:</span>
<span class="sd">      array of standard deviations sH_q for each mH_q returned</span>
<span class="sd">    (1d-vector, 2d-vector, 2d-vector):</span>
<span class="sd">      only present if debug_data is True: debug data of the form</span>
<span class="sd">      ``(xvals, yvals, poly)`` where ``xvals`` is the logarithm of ``dists``,</span>
<span class="sd">      ``yvals`` are the logarithms of the corresponding height-height-</span>
<span class="sd">      correlations for each distance (first dimension) and each q</span>
<span class="sd">      (second dimension) in the shape len(dists) x len(qvals) and ``poly`` are</span>
<span class="sd">      the line coefficients (``[slope, intercept]``) for each q in the shape</span>
<span class="sd">      len(qvals) x 2.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="c1"># transform to array if necessary</span>
  <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">qvals</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="c1"># actual default parameter would introduce shared list</span>
    <span class="c1"># see: http://pylint-messages.wikidot.com/messages:w0102</span>
    <span class="n">qvals</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">60</span><span class="p">:</span>
    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
      <span class="s2">&quot;H(q) is not reliable for small time series (</span><span class="si">{}</span><span class="s2"> &lt; 60)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
    <span class="p">)</span>
  <span class="n">max_max_dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">max_dists</span><span class="p">)</span>
  <span class="n">hhcorr</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="c1"># NOTE: I don&#39;t think it&#39;s a good idea to use a linear scale for the distance</span>
  <span class="c1"># values. Our fit is in logarithmic space, so this will place more weight on</span>
  <span class="c1"># the higher distance. This is not bad per se, but if you think that the</span>
  <span class="c1"># first values are unreliable, it would be better to skip them alltogether.</span>
  <span class="k">for</span> <span class="n">dist</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">max_max_dist</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
    <span class="c1"># NOTE: I don&#39;t think applying a step size to the input data is reasonable.</span>
    <span class="c1"># I cannot find any justification for this in the papers and reduces the</span>
    <span class="c1"># number of points that we can use to make our mean statistically stable.</span>
    <span class="n">step_size</span> <span class="o">=</span> <span class="n">dist</span>
    <span class="n">stepdata</span> <span class="o">=</span> <span class="n">data</span><span class="p">[::</span><span class="n">step_size</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">detrend</span><span class="p">:</span>
      <span class="n">stepdata</span> <span class="o">=</span> <span class="n">detrend_data</span><span class="p">(</span><span class="n">stepdata</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">diffs</span> <span class="o">=</span> <span class="n">stepdata</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="n">stepdata</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">hhcorr</span><span class="o">.</span><span class="n">append</span><span class="p">([</span>
      <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">diffs</span><span class="p">)</span> <span class="o">**</span> <span class="n">q</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">stepdata</span><span class="p">)</span> <span class="o">**</span> <span class="n">q</span><span class="p">)</span>
      <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="n">qvals</span>
    <span class="p">])</span>
  <span class="n">hhcorr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">hhcorr</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
  <span class="n">xvals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">max_max_dist</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
  <span class="n">yvals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">hhcorr</span><span class="p">)</span>
  <span class="c1"># NOTE: Using several maximum distances seems to be a strange way to</span>
  <span class="c1"># introduce stability, since it only places emphasis on the lower distance</span>
  <span class="c1"># ranges and does not introduce any new information.</span>
  <span class="n">H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
    <span class="n">poly_fit</span><span class="p">(</span><span class="n">xvals</span><span class="p">[:</span><span class="n">md</span><span class="p">],</span> <span class="n">yvals</span><span class="p">[:</span><span class="n">md</span><span class="p">,</span> <span class="n">qi</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span> <span class="n">fit</span><span class="o">=</span><span class="n">fit</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">qi</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">qvals</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">md</span> <span class="ow">in</span> <span class="n">max_dists</span>
  <span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">qvals</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">max_dists</span><span class="p">))</span>
  <span class="k">if</span> <span class="n">debug_plot</span><span class="p">:</span>
    <span class="n">polys</span> <span class="o">=</span> <span class="p">[</span>
      <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">poly_fit</span><span class="p">(</span><span class="n">xvals</span><span class="p">,</span> <span class="n">yvals</span><span class="p">[:,</span> <span class="n">qi</span><span class="p">],</span> <span class="mi">1</span><span class="p">))</span> <span class="o">/</span> <span class="n">qvals</span><span class="p">[</span><span class="n">qi</span><span class="p">]</span>
      <span class="k">for</span> <span class="n">qi</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">qvals</span><span class="p">))</span>
    <span class="p">]</span>
    <span class="n">plot_reg_multiple</span><span class="p">(</span>
      <span class="p">[</span><span class="n">xvals</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">qvals</span><span class="p">),</span>
      <span class="p">[</span><span class="n">yvals</span><span class="p">[:,</span> <span class="n">qi</span><span class="p">]</span> <span class="o">/</span> <span class="n">qvals</span><span class="p">[</span><span class="n">qi</span><span class="p">]</span> <span class="k">for</span> <span class="n">qi</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">qvals</span><span class="p">))],</span>
      <span class="n">polys</span><span class="p">,</span>
      <span class="n">x_label</span><span class="o">=</span><span class="s2">&quot;log(x)&quot;</span><span class="p">,</span> <span class="n">y_label</span><span class="o">=</span><span class="s2">&quot;$</span><span class="se">\\</span><span class="s2">log(c_q(x)) / q$&quot;</span><span class="p">,</span>
      <span class="n">data_labels</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;q = </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">q</span> <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="n">qvals</span><span class="p">],</span>
      <span class="n">reg_labels</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;reg. line (H = </span><span class="si">{:.3f}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">h</span><span class="p">)</span> <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">H</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">qvals</span><span class="p">],</span>
      <span class="n">fname</span><span class="o">=</span><span class="n">plot_file</span>
    <span class="p">)</span>
  <span class="n">mH</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">qvals</span>
  <span class="n">sH</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">qvals</span>
  <span class="k">if</span> <span class="n">debug_data</span><span class="p">:</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">mH</span><span class="p">,</span> <span class="n">sH</span><span class="p">,</span> <span class="p">(</span><span class="n">xvals</span><span class="p">,</span> <span class="n">yvals</span><span class="p">,</span> <span class="n">polys</span><span class="p">)]</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">mH</span><span class="p">,</span> <span class="n">sH</span><span class="p">]</span></div>



<div class="viewcode-block" id="corr_dim">
<a class="viewcode-back" href="../../nolds.html#nolds.corr_dim">[docs]</a>
<span class="k">def</span> <span class="nf">corr_dim</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">emb_dim</span><span class="p">,</span> <span class="n">lag</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">rvals</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dist</span><span class="o">=</span><span class="n">rowwise_euclidean</span><span class="p">,</span>
             <span class="n">fit</span><span class="o">=</span><span class="s2">&quot;RANSAC&quot;</span><span class="p">,</span> <span class="n">debug_plot</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">debug_data</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">plot_file</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Calculates the correlation dimension with the Grassberger-Procaccia algorithm</span>

<span class="sd">  Explanation of correlation dimension:</span>
<span class="sd">    The correlation dimension is a characteristic measure that can be used</span>
<span class="sd">    to describe the geometry of chaotic attractors. It is defined using the</span>
<span class="sd">    correlation sum C(r) which is the fraction of pairs of points X_i in the</span>
<span class="sd">    phase space whose distance is smaller than r.</span>

<span class="sd">    If the relation between C(r) and r can be described by the power law</span>

<span class="sd">    C(r) ~ r^D</span>

<span class="sd">    then D is called the correlation dimension of the system.</span>

<span class="sd">    In a d-dimensional system, the maximum value for D is d. This value is</span>
<span class="sd">    obtained for systems that expand uniformly in each dimension with time.</span>
<span class="sd">    The lowest possible value is 0 for a system with constant C(r) (i.e. a</span>
<span class="sd">    system that visits just one point in the phase space). Generally if D is</span>
<span class="sd">    lower than d and the system has an attractor, this attractor is called</span>
<span class="sd">    &quot;strange&quot; and D is a measure of this &quot;strangeness&quot;.</span>

<span class="sd">  Explanation of the algorithm:</span>
<span class="sd">    The Grassberger-Procaccia algorithm calculates C(r) for a range of</span>
<span class="sd">    different r and then fits a straight line into the plot of log(C(r))</span>
<span class="sd">    versus log(r).</span>

<span class="sd">    This version of the algorithm is created for one-dimensional (scalar) time</span>
<span class="sd">    series. Therefore, before calculating C(r), a delay embedding of the time</span>
<span class="sd">    series is performed to yield emb_dim dimensional vectors</span>
<span class="sd">    Y_i = [X_i, X_(i+1*lag), X_(i+2*lag), ... X_(i+(embd_dim-1)*lag)]. Choosing</span>
<span class="sd">    a higher value for emb_dim allows to reconstruct higher dimensional dynamics</span>
<span class="sd">    and avoids &quot;systematic errors due to corrections to scaling&quot;. Choosing a</span>
<span class="sd">    higher value for lag allows to avoid overestimating correlation because</span>
<span class="sd">    X_i ~= X_i+1, but it should also not be set too high to not underestimate</span>
<span class="sd">    correlation due to exponential divergence of trajectories in chaotic systems.</span>

<span class="sd">  References:</span>
<span class="sd">    .. [cd_1] P. Grassberger and I. Procaccia, “Characterization of strange</span>
<span class="sd">              attractors,” Physical review letters, vol. 50, no. 5, p. 346,</span>
<span class="sd">              1983.</span>
<span class="sd">    .. [cd_2] P. Grassberger and I. Procaccia, “Measuring the strangeness of</span>
<span class="sd">              strange attractors,” Physica D: Nonlinear Phenomena, vol. 9,</span>
<span class="sd">              no. 1, pp. 189–208, 1983.</span>
<span class="sd">    .. [cd_3] P. Grassberger, “Grassberger-Procaccia algorithm,”</span>
<span class="sd">              Scholarpedia, vol. 2, no. 5, p. 3043.</span>
<span class="sd">              urL: http://www.scholarpedia.org/article/Grassberger-Procaccia_algorithm</span>

<span class="sd">  Reference Code:</span>
<span class="sd">    .. [cd_a] &quot;corrDim&quot; function in R package &quot;fractal&quot;,</span>
<span class="sd">              url: https://cran.r-project.org/web/packages/fractal/fractal.pdf</span>
<span class="sd">    .. [cd_b] Peng Yuehua, &quot;Correlation dimension&quot;,</span>
<span class="sd">              url: http://de.mathworks.com/matlabcentral/fileexchange/24089-correlation-dimension</span>

<span class="sd">  Args:</span>
<span class="sd">    data (array-like of float):</span>
<span class="sd">      time series of data points</span>
<span class="sd">    emb_dim (int):</span>
<span class="sd">      embedding dimension</span>
<span class="sd">  Kwargs:</span>
<span class="sd">    rvals (iterable of float):</span>
<span class="sd">      list of values for to use for r</span>
<span class="sd">      (default: logarithmic_r(0.1 * std, 0.5 * std, 1.03))</span>
<span class="sd">    dist (function (2d-array, 1d-array) -&gt; 1d-array):</span>
<span class="sd">      row-wise difference function</span>
<span class="sd">    fit (str):</span>
<span class="sd">      the fitting method to use for the line fit, either &#39;poly&#39; for normal</span>
<span class="sd">      least squares polynomial fitting or &#39;RANSAC&#39; for RANSAC-fitting which</span>
<span class="sd">      is more robust to outliers</span>
<span class="sd">    debug_plot (boolean):</span>
<span class="sd">      if True, a simple plot of the final line-fitting step will be shown</span>
<span class="sd">    debug_data (boolean):</span>
<span class="sd">      if True, debugging data will be returned alongside the result</span>
<span class="sd">    plot_file (str):</span>
<span class="sd">      if debug_plot is True and plot_file is not None, the plot will be saved</span>
<span class="sd">      under the given file name instead of directly showing it through</span>
<span class="sd">      ``plt.show()``</span>

<span class="sd">  Returns:</span>
<span class="sd">    float:</span>
<span class="sd">      correlation dimension as slope of the line fitted to log(r) vs log(C(r))</span>
<span class="sd">    (1d-vector, 1d-vector, list):</span>
<span class="sd">      only present if debug_data is True: debug data of the form</span>
<span class="sd">      ``(rvals, csums, poly)`` where ``rvals`` are the values used for log(r),</span>
<span class="sd">      ``csums`` are the corresponding log(C(r)) and ``poly`` are the line</span>
<span class="sd">      coefficients (``[slope, intercept]``)</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="c1"># TODO determine lag in units of time instead of number of datapoints</span>
  <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

  <span class="c1"># TODO what are good values for r?</span>
  <span class="c1"># TODO do this for multiple values of emb_dim?</span>
  <span class="k">if</span> <span class="n">rvals</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">sd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">ddof</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">rvals</span> <span class="o">=</span> <span class="n">logarithmic_r</span><span class="p">(</span><span class="mf">0.1</span> <span class="o">*</span> <span class="n">sd</span><span class="p">,</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">sd</span><span class="p">,</span> <span class="mf">1.03</span><span class="p">)</span>
  <span class="n">orbit</span> <span class="o">=</span> <span class="n">delay_embedding</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">emb_dim</span><span class="p">,</span> <span class="n">lag</span><span class="o">=</span><span class="n">lag</span><span class="p">)</span>
  <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">orbit</span><span class="p">)</span>
  <span class="n">dists</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">orbit</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">orbit</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">orbit</span><span class="p">)):</span>
    <span class="c1"># calculate distances between X_i and X_i+1, X_i+2, ... , X_n-1</span>
    <span class="c1"># NOTE: strictly speaking, [cd_1] does not specify to exclude self-matches</span>
    <span class="c1"># however, since both [cd_2] and [cd_3] specify to only compare i with j != i</span>
    <span class="c1"># or j &gt; i respectively, it is safe to assume that this was an oversight in</span>
    <span class="c1"># [cd_1]</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">dist</span><span class="p">(</span><span class="n">orbit</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">:],</span> <span class="n">orbit</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    <span class="n">dists</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">:,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span>  <span class="c1"># fill column i</span>
    <span class="n">dists</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">d</span>  <span class="c1"># fill row i</span>
  <span class="n">csums</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">rvals</span><span class="p">:</span>
    <span class="c1"># NOTE: The [cd_1] and [cd_2] both use the factor 1/N^2 here.</span>
    <span class="c1"># However, since we only use these values to fit a line in a log-log plot</span>
    <span class="c1"># any multiplicative constant doesn&#39;t change the result since it will</span>
    <span class="c1"># only result in an offset on the y-axis. Also, [cd_3] has a point here</span>
    <span class="c1"># in that if we exclude self-matches in the numerator, it makes sense to</span>
    <span class="c1"># also exclude self-matches from the denominator.</span>
    <span class="n">s</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="n">n</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dists</span> <span class="o">&lt;=</span> <span class="n">r</span><span class="p">)</span>
    <span class="n">csums</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
  <span class="n">csums</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">csums</span><span class="p">)</span>
  <span class="c1"># filter zeros from csums</span>
  <span class="n">nonzero</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">csums</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
  <span class="n">rvals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">rvals</span><span class="p">)[</span><span class="n">nonzero</span><span class="p">]</span>
  <span class="n">csums</span> <span class="o">=</span> <span class="n">csums</span><span class="p">[</span><span class="n">nonzero</span><span class="p">]</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">csums</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="c1"># all sums are zero =&gt; we cannot fit a line</span>
    <span class="n">poly</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">]</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">poly</span> <span class="o">=</span> <span class="n">poly_fit</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">rvals</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">csums</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">fit</span><span class="o">=</span><span class="n">fit</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">debug_plot</span><span class="p">:</span>
    <span class="n">plot_reg</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">rvals</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">csums</span><span class="p">),</span> <span class="n">poly</span><span class="p">,</span> <span class="s2">&quot;log(r)&quot;</span><span class="p">,</span> <span class="s2">&quot;log(C(r))&quot;</span><span class="p">,</span>
             <span class="n">fname</span><span class="o">=</span><span class="n">plot_file</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">debug_data</span><span class="p">:</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">poly</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">rvals</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">csums</span><span class="p">),</span> <span class="n">poly</span><span class="p">))</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">poly</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>



<span class="k">def</span> <span class="nf">detrend_data</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">fit</span><span class="o">=</span><span class="s2">&quot;poly&quot;</span><span class="p">):</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Removes a trend of given order from the data.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="c1"># TODO also use this function in dfa</span>
  <span class="n">xvals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
  <span class="n">trend</span> <span class="o">=</span> <span class="n">poly_fit</span><span class="p">(</span><span class="n">xvals</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">fit</span><span class="o">=</span><span class="n">fit</span><span class="p">)</span>
  <span class="n">detrended</span> <span class="o">=</span> <span class="n">data</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">polyval</span><span class="p">(</span><span class="n">trend</span><span class="p">,</span> <span class="n">xvals</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">detrended</span>


<div class="viewcode-block" id="dfa">
<a class="viewcode-back" href="../../nolds.html#nolds.dfa">[docs]</a>
<span class="k">def</span> <span class="nf">dfa</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">nvals</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">overlap</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">fit_trend</span><span class="o">=</span><span class="s2">&quot;poly&quot;</span><span class="p">,</span>
        <span class="n">fit_exp</span><span class="o">=</span><span class="s2">&quot;RANSAC&quot;</span><span class="p">,</span> <span class="n">debug_plot</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">debug_data</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">plot_file</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Performs a detrended fluctuation analysis (DFA) on the given data</span>

<span class="sd">  Recommendations for parameter settings by Hardstone et al.:</span>
<span class="sd">    * nvals should be equally spaced on a logarithmic scale so that each window</span>
<span class="sd">      scale hase the same weight</span>
<span class="sd">    * min(nvals) &lt; 4 does not make much sense as fitting a polynomial (even if</span>
<span class="sd">      it is only of order 1) to 3 or less data points is very prone to errors.</span>
<span class="sd">    * max(nvals) &gt; len(data) / 10 does not make much sense as we will then have</span>
<span class="sd">      less than 10 windows to calculate the average fluctuation</span>
<span class="sd">    * use overlap=True to obtain more windows and therefore better statistics</span>
<span class="sd">      (at an increased computational cost)</span>

<span class="sd">  Explanation of DFA:</span>
<span class="sd">    Detrended fluctuation analysis, much like the Hurst exponent, is used to</span>
<span class="sd">    find long-term statistical dependencies in time series. However, while the</span>
<span class="sd">    Hurst exponent will indicate long-term correlations for any non-stationary</span>
<span class="sd">    process (i.e. a stochastic process whose probability distribution changes</span>
<span class="sd">    when shifted in time, such as a random walk whose mean changes over time),</span>
<span class="sd">    DFA was designed to distinguish between correlations that are purely an</span>
<span class="sd">    artifact of non-stationarity and those that show inherent long-term</span>
<span class="sd">    behavior of the studied system.</span>

<span class="sd">    Mathematically, the long-term correlations that we are interested in can</span>
<span class="sd">    be characterized using the autocorrelation function C(s). For a time series</span>
<span class="sd">    (x_i) with i = 1, ..., N it is defined as follows:</span>

<span class="sd">    C(s) = 1/(N-s) * (y_1 * y_1+s + y_2 * y_2+s + ... y_(N-s) * y_N)</span>

<span class="sd">    with y_i = x_i - mean(x). If there are no correlations at all, C(s) would</span>
<span class="sd">    be zero for s &gt; 0. For short-range correlations, C(s) will decline</span>
<span class="sd">    exponentially, but for long-term correlations the decline follows a power</span>
<span class="sd">    law of the form C(s) ~ s^(-gamma) instead with 0 &lt; gamma &lt; 1.</span>

<span class="sd">    Due to noise and underlying trends, calculating C(s) directly is usually not</span>
<span class="sd">    feasible. The main idea of DFA is therefore to remove trends up to a given</span>
<span class="sd">    order from the input data and analyze the remaining fluctuations. Trends</span>
<span class="sd">    in this sense are smooth signals with monotonous or slowly oscillating</span>
<span class="sd">    behavior that are caused by external effects and not the dynamical system</span>
<span class="sd">    under study.</span>
<span class="sd">  </span>
<span class="sd">    To get a hold of these trends, the first step is to calculate the &quot;profile&quot;</span>
<span class="sd">    of our time series as the cumulative sum of deviations from the mean,</span>
<span class="sd">    effectively integrating our data. This both smoothes out measurement noise</span>
<span class="sd">    and makes it easier to distinguish the fractal properties of bounded time</span>
<span class="sd">    series (i.e. time series whose values cannot grow or shrink beyond certain</span>
<span class="sd">    bounds such as most biological or physical signals) by applying random walk</span>
<span class="sd">    theory (see [dfa_3]_ and [dfa_4]_).</span>

<span class="sd">    y_i = x_1 - mean(x) + x_2 - mean(x) + ... + x_i - mean(x).</span>

<span class="sd">    After that, we split Y(i) into (usually non-overlapping) windows of length</span>
<span class="sd">    n to calculate local trends at this given scale. The ith window of this</span>
<span class="sd">    size has the form</span>

<span class="sd">    W_(n,i) = [y_i, y_(i+1), y_(i+2), ... y_(i+n-1)]</span>
<span class="sd">    </span>
<span class="sd">    The local trends are then removed for each window separately by fitting a</span>
<span class="sd">    polynomial p_(n,i) to the window W_(n,i) and then calculating</span>
<span class="sd">    W&#39;_(n,i) = W_(n,i) - p_(n,i) (element-wise subtraction).</span>

<span class="sd">    This leaves us with the deviations from the trend - the &quot;fluctuations&quot; -</span>
<span class="sd">    that we are interested in. To quantify them, we take the root mean square</span>
<span class="sd">    of these fluctuations. It is important to note that we have to sum up all</span>
<span class="sd">    individual fluctuations across all windows and divide by the total number</span>
<span class="sd">    of fluctuations here before finally taking the root as last step. Some</span>
<span class="sd">    implementations apply another root per window, which skews the result.</span>

<span class="sd">    The resulting fluctuation F(n) is then only dependent on the window size n,</span>
<span class="sd">    the scale at which we observe our data. It behaves similar to the</span>
<span class="sd">    autocorrelation function in that it follows a power-law for long-term</span>
<span class="sd">    correlations:</span>

<span class="sd">    F(n) ~ n^alpha</span>

<span class="sd">    Where alpha is the Hurst parameter, which we can obtain from fitting a line</span>
<span class="sd">    into the plot of log(n) versus log(F(n)) and taking the slope.</span>

<span class="sd">    The result can be interpreted as follows: For alpha &lt; 1 the underlying</span>
<span class="sd">    process is stationary and can be modelled as fractional Gaussian noise with</span>
<span class="sd">    H = alpha. This means for alpha = 0.5 we have no long-term correlation or</span>
<span class="sd">    &quot;memory&quot;, for 0.5 &lt; alpha &lt; 1 we have positive long-term correlations and</span>
<span class="sd">    for alpha &lt; 0.5 the long-term correlations are negative.</span>

<span class="sd">    For alpha &gt; 1 the underlying process is non-stationary and can be modeled</span>
<span class="sd">    as fractional Brownian motion with H = alpha - 1.</span>

<span class="sd">  References:</span>
<span class="sd">    .. [dfa_1] C.-K. Peng, S. V. Buldyrev, S. Havlin, M. Simons,</span>
<span class="sd">               H. E. Stanley, and A. L. Goldberger, “Mosaic organization of</span>
<span class="sd">               DNA nucleotides,” Physical Review E, vol. 49, no. 2, 1994.</span>
<span class="sd">    .. [dfa_2] J. W. Kantelhardt, E. Koscielny-Bunde, H. H. A. Rego, S.</span>
<span class="sd">               Havlin, and A. Bunde, “Detecting long-range correlations with</span>
<span class="sd">               detrended fluctuation analysis,” Physica A: Statistical</span>
<span class="sd">               Mechanics and its Applications, vol. 295, no. 3–4, pp. 441–454,</span>
<span class="sd">               Jun. 2001, doi: 10.1016/S0378-4371(01)00144-3.</span>
<span class="sd">    .. [dfa_3] C. Peng, J. M. Hausdorff, and A. L. Goldberger, “Fractal</span>
<span class="sd">               mechanisms in neuronal control: human heartbeat and gait</span>
<span class="sd">               dynamics in health and disease,” in Self-Organized Biological</span>
<span class="sd">               Dynamics and Nonlinear Control, 1st ed., J. Walleczek, Ed.,</span>
<span class="sd">               Cambridge University Press, 2000, pp. 66–96.</span>
<span class="sd">               doi: 10.1017/CBO9780511535338.006.</span>
<span class="sd">    .. [dfa_4] A. Bashan, R. Bartsch, J. W. Kantelhardt, and S. Havlin,</span>
<span class="sd">               “Comparison of detrending methods for fluctuation analysis,”</span>
<span class="sd">               Physica A: Statistical Mechanics and its Applications, vol. 387,</span>
<span class="sd">               no. 21, pp. 5080–5090, Sep. 2008,</span>
<span class="sd">               doi: 10.1016/j.physa.2008.04.023.</span>
<span class="sd">    .. [dfa_5] R. Hardstone, S.-S. Poil, G. Schiavone, R. Jansen,</span>
<span class="sd">               V. V. Nikulin, H. D. Mansvelder, and K. Linkenkaer-Hansen,</span>
<span class="sd">               “Detrended fluctuation analysis: A scale-free view on neuronal</span>
<span class="sd">               oscillations,” Frontiers in Physiology, vol. 30, 2012.</span>

<span class="sd">  Reference code:</span>
<span class="sd">    .. [dfa_a] Peter Jurica, &quot;Introduction to MDFA in Python&quot;,</span>
<span class="sd">       url: http://bsp.brain.riken.jp/~juricap/mdfa/mdfaintro.html</span>
<span class="sd">    .. [dfa_b] JE Mietus, &quot;dfa&quot;,</span>
<span class="sd">       url: https://www.physionet.org/physiotools/dfa/dfa-1.htm</span>
<span class="sd">    .. [dfa_c] &quot;DFA&quot; function in R package &quot;fractal&quot;</span>

<span class="sd">  Args:</span>
<span class="sd">    data (array-like of float):</span>
<span class="sd">      time series</span>
<span class="sd">  Kwargs:</span>
<span class="sd">    nvals (iterable of int):</span>
<span class="sd">      subseries sizes at which to calculate fluctuation</span>
<span class="sd">      (default: logarithmic_n(4, 0.1*len(data), 1.2))</span>
<span class="sd">    overlap (boolean):</span>
<span class="sd">      if True, the windows W_(n,i) will have a 50% overlap,</span>
<span class="sd">      otherwise non-overlapping windows will be used</span>
<span class="sd">    order (int):</span>
<span class="sd">      (polynomial) order of trend to remove</span>
<span class="sd">    fit_trend (str):</span>
<span class="sd">      the fitting method to use for fitting the trends, either &#39;poly&#39;</span>
<span class="sd">      for normal least squares polynomial fitting or &#39;RANSAC&#39; for</span>
<span class="sd">      RANSAC-fitting which is more robust to outliers but also tends to</span>
<span class="sd">      lead to unstable results</span>
<span class="sd">    fit_exp (str):</span>
<span class="sd">      the fitting method to use for the line fit, either &#39;poly&#39; for normal</span>
<span class="sd">      least squares polynomial fitting or &#39;RANSAC&#39; for RANSAC-fitting which</span>
<span class="sd">      is more robust to outliers</span>
<span class="sd">    debug_plot (boolean):</span>
<span class="sd">      if True, a simple plot of the final line-fitting step will be shown</span>
<span class="sd">    debug_data (boolean):</span>
<span class="sd">      if True, debugging data will be returned alongside the result</span>
<span class="sd">    plot_file (str):</span>
<span class="sd">      if debug_plot is True and plot_file is not None, the plot will be saved</span>
<span class="sd">      under the given file name instead of directly showing it through</span>
<span class="sd">      ``plt.show()``</span>
<span class="sd">  Returns:</span>
<span class="sd">    float:</span>
<span class="sd">      the estimate alpha for the Hurst parameter (alpha &lt; 1: stationary</span>
<span class="sd">      process similar to fractional Gaussian noise with H = alpha,</span>
<span class="sd">      alpha &gt; 1: non-stationary process similar to fractional Brownian</span>
<span class="sd">      motion with H = alpha - 1)</span>
<span class="sd">    (1d-vector, 1d-vector, list):</span>
<span class="sd">      only present if debug_data is True: debug data of the form</span>
<span class="sd">      ``(nvals, fluctuations, poly)`` where ``nvals`` are the values used for</span>
<span class="sd">      log(n), ``fluctuations`` are the corresponding log(std(X,n)) and ``poly``</span>
<span class="sd">      are the line coefficients (``[slope, intercept]``)</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
  <span class="n">total_N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">nvals</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">total_N</span> <span class="o">&gt;</span> <span class="mi">70</span><span class="p">:</span>
      <span class="n">nvals</span> <span class="o">=</span> <span class="n">logarithmic_n</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mf">0.1</span> <span class="o">*</span> <span class="n">total_N</span><span class="p">,</span> <span class="mf">1.2</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">total_N</span> <span class="o">&gt;</span> <span class="mi">10</span><span class="p">:</span>
      <span class="n">nvals</span> <span class="o">=</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">nvals</span> <span class="o">=</span> <span class="p">[</span><span class="n">total_N</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="n">total_N</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
      <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;choosing nvals = </span><span class="si">{}</span><span class="s2"> , DFA with less than ten data points is &quot;</span> \
          <span class="o">+</span> <span class="s2">&quot;extremely unreliable&quot;</span>
      <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">nvals</span><span class="p">),</span> <span class="ne">RuntimeWarning</span><span class="p">)</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nvals</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;at least two nvals are needed&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">nvals</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;nvals must be at least two&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">nvals</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">total_N</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;nvals cannot be larger than the input size&quot;</span><span class="p">)</span>
  <span class="c1"># create the signal profile</span>
  <span class="c1"># (cumulative sum of deviations from the mean =&gt; &quot;walk&quot;)</span>
  <span class="n">walk</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">data</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
  <span class="n">fluctuations</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">nvals</span><span class="p">:</span>
    <span class="k">assert</span> <span class="n">n</span> <span class="o">&gt;=</span> <span class="mi">2</span>
    <span class="c1"># subdivide data into chunks of size n</span>
    <span class="k">if</span> <span class="n">overlap</span><span class="p">:</span>
      <span class="c1"># step size n/2 instead of n</span>
      <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">walk</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span> <span class="o">+</span> <span class="n">n</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">walk</span><span class="p">)</span> <span class="o">-</span> <span class="n">n</span><span class="p">,</span> <span class="n">n</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)])</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="c1"># non-overlapping windows =&gt; we can simply do a reshape</span>
      <span class="n">d</span> <span class="o">=</span> <span class="n">walk</span><span class="p">[:</span><span class="n">total_N</span> <span class="o">-</span> <span class="p">(</span><span class="n">total_N</span> <span class="o">%</span> <span class="n">n</span><span class="p">)]</span>
      <span class="n">d</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">total_N</span> <span class="o">//</span> <span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>
    <span class="c1"># calculate local trends as polynomes</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="n">tpoly</span> <span class="o">=</span> <span class="p">[</span><span class="n">poly_fit</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">order</span><span class="p">,</span> <span class="n">fit</span><span class="o">=</span><span class="n">fit_trend</span><span class="p">)</span>
             <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">d</span><span class="p">))]</span>
    <span class="n">tpoly</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">tpoly</span><span class="p">)</span>
    <span class="n">trend</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">polyval</span><span class="p">(</span><span class="n">tpoly</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">d</span><span class="p">))])</span>
    <span class="c1"># calculate mean-square differences for each walk in d around trend</span>
    <span class="n">flucs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">d</span> <span class="o">-</span> <span class="n">trend</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">n</span>
    <span class="c1"># take another mean across all walks and finally take the square root of that</span>
    <span class="c1"># NOTE: To map this to the formula in Peng1995, observe that this simplifies</span>
    <span class="c1"># to np.sqrt(np.sum((d - trend) ** 2) / total_N) if we have non-overlapping</span>
    <span class="c1"># windows and the last window matches the end of the data perfectly.</span>
    <span class="n">f_n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">flucs</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">flucs</span><span class="p">))</span>
    <span class="n">fluctuations</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">f_n</span><span class="p">)</span>
  <span class="n">fluctuations</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">fluctuations</span><span class="p">)</span>
  <span class="c1"># filter zeros from fluctuations</span>
  <span class="n">nonzero</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">fluctuations</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
  <span class="n">nvals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">nvals</span><span class="p">)[</span><span class="n">nonzero</span><span class="p">]</span>
  <span class="n">fluctuations</span> <span class="o">=</span> <span class="n">fluctuations</span><span class="p">[</span><span class="n">nonzero</span><span class="p">]</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">fluctuations</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="c1"># all fluctuations are zero =&gt; we cannot fit a line</span>
    <span class="n">poly</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">]</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">poly</span> <span class="o">=</span> <span class="n">poly_fit</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">nvals</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">fluctuations</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span>
                    <span class="n">fit</span><span class="o">=</span><span class="n">fit_exp</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">debug_plot</span><span class="p">:</span>
    <span class="n">plot_reg</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">nvals</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">fluctuations</span><span class="p">),</span> <span class="n">poly</span><span class="p">,</span> <span class="s2">&quot;log(n)&quot;</span><span class="p">,</span> <span class="s2">&quot;std(X,n)&quot;</span><span class="p">,</span>
             <span class="n">fname</span><span class="o">=</span><span class="n">plot_file</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">debug_data</span><span class="p">:</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">poly</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">nvals</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">fluctuations</span><span class="p">),</span> <span class="n">poly</span><span class="p">))</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">poly</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>

</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">Nolds</a></h1>









<search id="searchbox" style="display: none" role="search">
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" placeholder="Search"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script><h3>Navigation</h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../nolds.html"><code class="docutils literal notranslate"><span class="pre">nolds</span></code> module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples.html">Nolds examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tests.html">Nolds Unittests</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  <li><a href="../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;2016-2024, Christopher Schölzel.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 8.0.2</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 1.0.0</a>
      
    </div>

    

    
  </body>
</html>