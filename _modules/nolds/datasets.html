<!DOCTYPE html>

<html lang="en" data-content_root="../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>nolds.datasets &#8212; Nolds 0.6.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../../_static/basic.css?v=c058f7c8" />
    <link rel="stylesheet" type="text/css" href="../../_static/alabaster.css?v=19a2ea7e" />
    <script src="../../_static/documentation_options.js?v=8fa8b3e9"></script>
    <script src="../../_static/doctools.js?v=9a2dae69"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for nolds.datasets</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="p">(</span><span class="n">absolute_import</span><span class="p">,</span> <span class="n">division</span><span class="p">,</span>
                        <span class="n">print_function</span><span class="p">,</span> <span class="n">unicode_literals</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">builtins</span> <span class="kn">import</span> <span class="p">(</span>
  <span class="nb">bytes</span><span class="p">,</span> <span class="nb">dict</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">list</span><span class="p">,</span> <span class="nb">object</span><span class="p">,</span> <span class="nb">range</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="n">ascii</span><span class="p">,</span> <span class="nb">chr</span><span class="p">,</span> <span class="nb">hex</span><span class="p">,</span> <span class="nb">input</span><span class="p">,</span> <span class="nb">next</span><span class="p">,</span>
  <span class="nb">oct</span><span class="p">,</span> <span class="nb">open</span><span class="p">,</span> <span class="nb">pow</span><span class="p">,</span> <span class="nb">round</span><span class="p">,</span> <span class="nb">super</span><span class="p">,</span> <span class="nb">filter</span><span class="p">,</span> <span class="nb">map</span><span class="p">,</span> <span class="nb">zip</span>
<span class="p">)</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pkg_resources</span>
<span class="kn">import</span> <span class="nn">datetime</span>


<span class="k">def</span> <span class="nf">lorenz_euler</span><span class="p">(</span><span class="n">length</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">rho</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]):</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Simulates the Lorenz system using a simple Euler method</span>

<span class="sd">  The Lorenz system is a three dimensional dynamical system given</span>
<span class="sd">  by the following equations:</span>

<span class="sd">  dx/dt = sigma * (y - x)</span>
<span class="sd">  dy/dt = rho * x - y - x * z</span>
<span class="sd">  dz/dt = x * y - beta * z</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="k">def</span> <span class="nf">lorenz</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">rho</span><span class="p">,</span> <span class="n">beta</span><span class="p">):</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">state</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
      <span class="n">sigma</span> <span class="o">*</span> <span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="n">x</span><span class="p">),</span>
      <span class="n">rho</span> <span class="o">*</span> <span class="n">x</span> <span class="o">-</span> <span class="n">y</span> <span class="o">-</span> <span class="n">x</span> <span class="o">*</span> <span class="n">z</span><span class="p">,</span>
      <span class="n">x</span> <span class="o">*</span> <span class="n">y</span> <span class="o">-</span> <span class="n">beta</span> <span class="o">*</span> <span class="n">z</span>
    <span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float32&quot;</span><span class="p">)</span>
  <span class="n">trajectory</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">length</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float32&quot;</span><span class="p">)</span>
  <span class="n">trajectory</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">start</span>
  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">length</span><span class="p">):</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="n">dt</span>
    <span class="n">trajectory</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">trajectory</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">lorenz</span><span class="p">(</span><span class="n">trajectory</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">rho</span><span class="p">,</span> <span class="n">beta</span><span class="p">)</span> <span class="o">*</span> <span class="n">dt</span>
  <span class="k">return</span> <span class="n">trajectory</span>

<span class="k">def</span> <span class="nf">lorenz_lyap</span><span class="p">(</span><span class="n">sigma</span><span class="p">,</span> <span class="n">rho</span><span class="p">,</span> <span class="n">beta</span><span class="p">):</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Calculates the exact Lyapunov dimension of the Lorenz system according to</span>
<span class="sd">  Leonov 2015 [ll_1]_.</span>

<span class="sd">  References:</span>
<span class="sd">    .. [ll_1] G. A. Leonov and N. V. Kuznetsov, “On differences and similarities in the</span>
<span class="sd">       analysis of Lorenz, Chen, and Lu systems,” Applied Mathematics and Computation,</span>
<span class="sd">       vol. 256, pp. 334–343, Apr. 2015, doi: 10.1016/j.amc.2014.12.132.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="k">return</span> <span class="mi">3</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">sigma</span> <span class="o">+</span> <span class="n">beta</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">sigma</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">sigma</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">sigma</span> <span class="o">*</span> <span class="n">rho</span><span class="p">))</span>


<div class="viewcode-block" id="fbm">
<a class="viewcode-back" href="../../nolds.html#nolds.fbm">[docs]</a>
<span class="k">def</span> <span class="nf">fbm</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">H</span><span class="o">=</span><span class="mf">0.75</span><span class="p">):</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Generates fractional brownian motions of desired length.</span>

<span class="sd">  Author:</span>
<span class="sd">    Christian Thomae</span>

<span class="sd">  References:</span>
<span class="sd">    .. [fbm_1] https://en.wikipedia.org/wiki/Fractional_Brownian_motion#Method_1_of_simulation</span>

<span class="sd">  Args:</span>
<span class="sd">    n (int):</span>
<span class="sd">      length of sequence to generate</span>
<span class="sd">  Kwargs:</span>
<span class="sd">    H (float):</span>
<span class="sd">      hurst parameter</span>

<span class="sd">  Returns:</span>
<span class="sd">    array of float:</span>
<span class="sd">      simulated fractional brownian motion</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="c1"># TODO more detailed description of fbm</span>
  <span class="k">assert</span> <span class="n">H</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">H</span> <span class="o">&lt;</span> <span class="mi">1</span>

  <span class="k">def</span> <span class="nf">R</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
    <span class="n">twoH</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">H</span>
    <span class="k">return</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">s</span><span class="o">**</span><span class="n">twoH</span> <span class="o">+</span> <span class="n">t</span><span class="o">**</span><span class="n">twoH</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">t</span> <span class="o">-</span> <span class="n">s</span><span class="p">)</span><span class="o">**</span><span class="n">twoH</span><span class="p">)</span>
  <span class="c1"># form the matrix tau</span>
  <span class="n">gamma</span> <span class="o">=</span> <span class="n">R</span><span class="p">(</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">mgrid</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">n</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">n</span><span class="p">])</span>  <span class="c1"># apply R to every element in matrix</span>
  <span class="n">w</span><span class="p">,</span> <span class="n">P</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eigh</span><span class="p">(</span><span class="n">gamma</span><span class="p">)</span>
  <span class="n">L</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
  <span class="n">sigma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">L</span><span class="p">)),</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">P</span><span class="p">))</span>
  <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">sigma</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span></div>



<div class="viewcode-block" id="fgn">
<a class="viewcode-back" href="../../nolds.html#nolds.fgn">[docs]</a>
<span class="k">def</span> <span class="nf">fgn</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">H</span><span class="o">=</span><span class="mf">0.75</span><span class="p">):</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Generates fractional gaussian noise of desired length.</span>

<span class="sd">  References:</span>
<span class="sd">    .. [fgn_1] https://en.wikipedia.org/wiki/Fractional_Brownian_motion</span>

<span class="sd">  Args:</span>
<span class="sd">    n (int):</span>
<span class="sd">      length of sequence to generate</span>

<span class="sd">  Kwargs:</span>
<span class="sd">    H (float):</span>
<span class="sd">      hurst parameter</span>

<span class="sd">  Returns:</span>
<span class="sd">    array of float:</span>
<span class="sd">      simulated fractional gaussian noise</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">fbm</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">H</span><span class="o">=</span><span class="n">H</span><span class="p">))</span></div>



<div class="viewcode-block" id="qrandom">
<a class="viewcode-back" href="../../nolds.html#nolds.qrandom">[docs]</a>
<span class="k">def</span> <span class="nf">qrandom</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Creates an array of n true random numbers obtained from the quantum random</span>
<span class="sd">  number generator at qrng.anu.edu.au</span>

<span class="sd">  This function requires the package quantumrandom and an internet connection.</span>

<span class="sd">  Args:</span>
<span class="sd">    n (int):</span>
<span class="sd">      length of the random array</span>

<span class="sd">  Return:</span>
<span class="sd">    array of ints:</span>
<span class="sd">      array of truly random unsigned 16 bit int values</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="kn">import</span> <span class="nn">quantumrandom</span>
  <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span>
    <span class="n">quantumrandom</span><span class="o">.</span><span class="n">get_data</span><span class="p">(</span><span class="n">data_type</span><span class="o">=</span><span class="s1">&#39;uint16&#39;</span><span class="p">,</span> <span class="n">array_length</span><span class="o">=</span><span class="mi">1024</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">n</span><span class="o">/</span><span class="mf">1024.0</span><span class="p">)))</span>
  <span class="p">])[:</span><span class="n">n</span><span class="p">]</span></div>



<div class="viewcode-block" id="load_qrandom">
<a class="viewcode-back" href="../../nolds.html#nolds.load_qrandom">[docs]</a>
<span class="k">def</span> <span class="nf">load_qrandom</span><span class="p">():</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Loads a set of 10000 random numbers generated by qrandom.</span>

<span class="sd">  This dataset can be used when you want to do some limited tests with &quot;true&quot;</span>
<span class="sd">  random data without an internet connection.</span>

<span class="sd">  Returns:</span>
<span class="sd">    int array</span>
<span class="sd">      the dataset</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="n">fname</span> <span class="o">=</span> <span class="s2">&quot;datasets/qrandom.npy&quot;</span>
  <span class="k">with</span> <span class="n">pkg_resources</span><span class="o">.</span><span class="n">resource_stream</span><span class="p">(</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">fname</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span></div>



<span class="k">def</span> <span class="nf">load_brown72</span><span class="p">():</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Loads the dataset brown72 with a prescribed Hurst exponent of 0.72</span>

<span class="sd">  Source: http://bearcave.com/misl/misl_tech/wavelets/hurst/index.html</span>

<span class="sd">  Returns:</span>
<span class="sd">    float array:</span>
<span class="sd">      the dataset</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="n">fname</span> <span class="o">=</span> <span class="s2">&quot;datasets/brown72.npy&quot;</span>
  <span class="k">with</span> <span class="n">pkg_resources</span><span class="o">.</span><span class="n">resource_stream</span><span class="p">(</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">fname</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">load_lorenz_physionet</span><span class="p">():</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Loads a dataset containing the X variable of the Lorenz system</span>
<span class="sd">    as well as the output of PhysioNet&#39;s dfa implementation on that dataset.</span>

<span class="sd">  The input data was created with the following code:</span>

<span class="sd">      data = datasets.lorenz_euler(</span>
<span class="sd">        3000, 10, 28, 8/3.0, start=[0.1,0.1,0.1], dt=0.012</span>
<span class="sd">      )[1000:,0]</span>

<span class="sd">  The ouptut from PhysioNet was created by calling:</span>

<span class="sd">      dfa &lt; lorenz.txt &gt; lorenz_physionet.txt</span>
<span class="sd"> </span>
<span class="sd">  Returns:</span>
<span class="sd">    1d float array:</span>
<span class="sd">      time series of the X variable of the Lorenz system that was used as input</span>
<span class="sd">    2d float array:</span>
<span class="sd">      x- and y-coordinates of the line fitting step in the PhysioNet output</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="n">fname</span> <span class="o">=</span> <span class="s2">&quot;datasets/lorenz.txt&quot;</span>
  <span class="k">with</span> <span class="n">pkg_resources</span><span class="o">.</span><span class="n">resource_stream</span><span class="p">(</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">fname</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="n">data_in</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
  <span class="n">fname</span> <span class="o">=</span> <span class="s2">&quot;datasets/lorenz_physionet.txt&quot;</span>
  <span class="k">with</span> <span class="n">pkg_resources</span><span class="o">.</span><span class="n">resource_stream</span><span class="p">(</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">fname</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="n">data_out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">data_in</span><span class="p">,</span> <span class="n">data_out</span>


<div class="viewcode-block" id="tent_map">
<a class="viewcode-back" href="../../nolds.html#nolds.tent_map">[docs]</a>
<span class="k">def</span> <span class="nf">tent_map</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">steps</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Generates a time series of the tent map.</span>

<span class="sd">  Characteristics and Background:</span>
<span class="sd">    The name of the tent map is derived from the fact that the plot of x_i vs</span>
<span class="sd">    x_i+1 looks like a tent. For mu &gt; 1 one application of the mapping function</span>
<span class="sd">    can be viewed as stretching the surface on which the value is located and</span>
<span class="sd">    then folding the area that is greater than one back towards the zero. This</span>
<span class="sd">    corresponds nicely to the definition of chaos as expansion in one dimension</span>
<span class="sd">    which is counteracted by a compression in another dimension.</span>

<span class="sd">  Calculating the Lyapunov exponent:</span>
<span class="sd">    The lyapunov exponent of the tent map can be easily calculated as due to</span>
<span class="sd">    this stretching behavior a small difference delta between two neighboring</span>
<span class="sd">    points will indeed grow exponentially by a factor of mu in each iteration.</span>
<span class="sd">    We thus can assume that:</span>

<span class="sd">    delta_n = delta_0 * mu^n</span>

<span class="sd">    We now only have to change the basis to e to obtain the exact formula that</span>
<span class="sd">    is used for the definition of the lyapunov exponent:</span>

<span class="sd">    delta_n = delta_0 * e^(ln(mu) * n)</span>

<span class="sd">    Therefore the lyapunov exponent of the tent map is:</span>

<span class="sd">    lambda = ln(mu)</span>

<span class="sd">  References:</span>
<span class="sd">    .. [tm_1] https://en.wikipedia.org/wiki/Tent_map</span>

<span class="sd">  Args:</span>
<span class="sd">    x (float):</span>
<span class="sd">      starting point</span>
<span class="sd">    steps (int):</span>
<span class="sd">      number of steps for which the generator should run</span>

<span class="sd">  Kwargs:</span>
<span class="sd">    mu (int):</span>
<span class="sd">      parameter mu that controls the behavior of the map</span>

<span class="sd">  Returns:</span>
<span class="sd">    generator object:</span>
<span class="sd">      the generator that creates the time series</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">steps</span><span class="p">):</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">mu</span> <span class="o">*</span> <span class="n">x</span> <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mf">0.5</span> <span class="k">else</span> <span class="n">mu</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">x</span><span class="p">)</span>
    <span class="k">yield</span> <span class="n">x</span></div>


<span class="c1"># TODO should all math be formatted like this, or should the documentation of</span>
<span class="c1"># logistic_map revert to a version that is more readable as plain text</span>


<div class="viewcode-block" id="logistic_map">
<a class="viewcode-back" href="../../nolds.html#nolds.logistic_map">[docs]</a>
<span class="k">def</span> <span class="nf">logistic_map</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">steps</span><span class="p">,</span> <span class="n">r</span><span class="o">=</span><span class="mi">4</span><span class="p">):</span>
<span class="w">  </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Generates a time series of the logistic map.</span>

<span class="sd">  Characteristics and Background:</span>
<span class="sd">    The logistic map is among the simplest examples for a time series that can</span>
<span class="sd">    exhibit chaotic behavior depending on the parameter r. For r between 2 and</span>
<span class="sd">    3, the series quickly becomes static. At r=3 the first bifurcation point is</span>
<span class="sd">    reached after which the series starts to oscillate. Beginning with r = 3.6</span>
<span class="sd">    it shows chaotic behavior with a few islands of stability until perfect</span>
<span class="sd">    chaos is achieved at r = 4.</span>

<span class="sd">  Calculating the Lyapunov exponent:</span>
<span class="sd">    To calculate the &quot;true&quot; Lyapunov exponent of the logistic map, we first</span>
<span class="sd">    have to make a few observations for maps in general that are repeated</span>
<span class="sd">    applications of a function to a starting value.</span>

<span class="sd">    If we have two starting values that differ by some infinitesimal</span>
<span class="sd">    :math:`delta_0` then according to the definition of the lyapunov exponent</span>
<span class="sd">    we will have an exponential divergence:</span>

<span class="sd">    .. math::</span>
<span class="sd">      |\delta_n| = |\delta_0| e^{\lambda n}</span>

<span class="sd">    We can now write that:</span>

<span class="sd">    .. math::</span>
<span class="sd">      e^{\lambda n} = \lim_{\delta_0 -&gt; 0} |\frac{\delta_n}{\delta_0}|</span>

<span class="sd">    This is the definition of the derivative :math:`\frac{dx_n}{dx_0}` of a</span>
<span class="sd">    point :math:`x_n` in the time series with respect to the starting point</span>
<span class="sd">    :math:`x_0` (or rather the absolute value of that derivative). Now we can</span>
<span class="sd">    use the fact that due to the definition of our map as repetitive</span>
<span class="sd">    application of some f we have:</span>

<span class="sd">    .. math::</span>
<span class="sd">      f^{n\prime}(x) = f(f(f(...f(x_0)...))) = f&#39;(x_n-1) \cdot f&#39;(x_n-2)</span>
<span class="sd">      \cdot ... \cdot f&#39;(x_0)</span>

<span class="sd">    with</span>

<span class="sd">    .. math::</span>
<span class="sd">      e^{\lambda n} = |f^{n\prime}(x)|</span>

<span class="sd">    we now have</span>

<span class="sd">    .. math::</span>

<span class="sd">      e^{\lambda n} &amp;= |f&#39;(x_n-1) \cdot f&#39;(x_n-2) \cdot ... \cdot f&#39;(x_0)| \\</span>
<span class="sd">      \Leftrightarrow \\</span>
<span class="sd">      \lambda n &amp;= \ln |f&#39;(x_n-1) \cdot f&#39;(x_n-2) \cdot ... \cdot f&#39;(x_0)| \\</span>
<span class="sd">      \Leftrightarrow \\</span>
<span class="sd">      \lambda &amp;= \frac{1}{n} \ln |f&#39;(x_n-1) \cdot f&#39;(x_n-2) \cdot ... \cdot f&#39;(x_0)| \\</span>
<span class="sd">             &amp;= \frac{1}{n} \sum_{k=0}^{n-1} \ln |f&#39;(x_k)|</span>

<span class="sd">    With this sum we can now calculate the lyapunov exponent for any map.</span>
<span class="sd">    For the logistic map we simply have to calculate :math:`f&#39;(x)` and as we</span>
<span class="sd">    have</span>

<span class="sd">    .. math::</span>
<span class="sd">      f(x) = r x (1-x) = rx - rx²</span>

<span class="sd">    we now get</span>

<span class="sd">    .. math::</span>
<span class="sd">      f&#39;(x) = r - 2 rx</span>



<span class="sd">  References:</span>
<span class="sd">    .. [lm_1] https://en.wikipedia.org/wiki/Tent_map</span>
<span class="sd">    .. [lm_2] https://blog.abhranil.net/2015/05/15/lyapunov-exponent-of-the-logistic-map-mathematica-code/</span>

<span class="sd">  Args:</span>
<span class="sd">    x (float):</span>
<span class="sd">      starting point</span>
<span class="sd">    steps (int):</span>
<span class="sd">      number of steps for which the generator should run</span>

<span class="sd">  Kwargs:</span>
<span class="sd">    r (int):</span>
<span class="sd">      parameter r that controls the behavior of the map</span>

<span class="sd">  Returns:</span>
<span class="sd">    generator object:</span>
<span class="sd">      the generator that creates the time series</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">steps</span><span class="p">):</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">r</span> <span class="o">*</span> <span class="n">x</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">x</span><span class="p">)</span>
    <span class="k">yield</span> <span class="n">x</span></div>



<div class="viewcode-block" id="load_financial">
<a class="viewcode-back" href="../../nolds.html#nolds.load_financial">[docs]</a>
<span class="k">def</span> <span class="nf">load_financial</span><span class="p">():</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Loads the following datasets from CSV files in this package:</span>

<span class="sd">  - jkse: Jakarta Composite Index, downloaded on 2019-02-12 from https://finance.yahoo.com/quote/%5EJKSE/history?period1=631148400&amp;period2=988668000&amp;interval=1d&amp;filter=history&amp;frequency=1d</span>
<span class="sd">  - n225: Nikkei 225, downloaded on 2019-02-12 from https://finance.yahoo.com/quote/%5EN225/history?period1=631148400&amp;period2=988668000&amp;interval=1d&amp;filter=history&amp;frequency=1d</span>
<span class="sd">  - ndx: NASDAQ 100, downloaded on 2019-02-12 from https://finance.yahoo.com/quote/%5ENDX/history?period1=631148400&amp;period2=988668000&amp;interval=1d&amp;filter=history&amp;frequency=1d</span>

<span class="sd">  All datasets are daily prices from the period from 1990-01-01 to 2001-05-01</span>
<span class="sd">  missing values are NaN except for opening values which are treated as</span>
<span class="sd">  follows:</span>

<span class="sd">  - If the first opening value is missing, the first *existing* opening value</span>
<span class="sd">      is used for the first day.</span>
<span class="sd">  - All other missing opening values are filled by the close value of the last</span>
<span class="sd">      day where data was available.</span>

<span class="sd">  Returns:</span>
<span class="sd">    list of tuple(1d-array, 2d-array):</span>
<span class="sd">      datasets with days as array of date objects and 2d-array with the columns</span>
<span class="sd">      &quot;Open&quot;, &quot;High&quot;, &quot;Low&quot;, &quot;Close&quot;, &quot;Adj Close&quot;, and &quot;Volume&quot;. Note that</span>
<span class="sd">      &quot;Open&quot; values have been padded to ensure that there are no NaNs left.</span>
<span class="sd">  &quot;&quot;&quot;</span>

  <span class="k">def</span> <span class="nf">load_finance_yahoo_data</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
    <span class="n">f</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
    <span class="n">days</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">values</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">f</span><span class="p">:</span>
      <span class="n">fields</span> <span class="o">=</span> <span class="n">l</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s2">&quot;utf-8&quot;</span><span class="p">)</span>
      <span class="n">fields</span> <span class="o">=</span> <span class="n">fields</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="p">)</span>
      <span class="n">d</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">strptime</span><span class="p">(</span><span class="n">fields</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s2">&quot;%Y-%m-</span><span class="si">%d</span><span class="s2">&quot;</span><span class="p">)</span>
      <span class="n">v</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span> <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;null&quot;</span> <span class="k">else</span> <span class="nb">float</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">fields</span><span class="p">[</span><span class="mi">1</span><span class="p">:]]</span>
      <span class="n">days</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
      <span class="n">values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">days</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">pad_opening_values</span><span class="p">(</span><span class="n">values</span><span class="p">):</span>
    <span class="c1"># fill first value from future if required</span>
    <span class="n">first</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="n">first</span><span class="p">,</span> <span class="mi">0</span><span class="p">]):</span>
      <span class="n">first</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">values</span><span class="p">[</span><span class="n">first</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="c1"># iterate over all indices where data is missing</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">values</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]))[</span><span class="mi">0</span><span class="p">]:</span>
      <span class="n">j</span> <span class="o">=</span> <span class="n">i</span>
      <span class="c1"># pad opening value with close value of previous data</span>
      <span class="k">while</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">3</span><span class="p">]):</span>
        <span class="n">j</span> <span class="o">-=</span> <span class="mi">1</span>
      <span class="n">values</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">values</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>

  <span class="n">data</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;^JKSE&quot;</span><span class="p">,</span> <span class="s2">&quot;^N225&quot;</span><span class="p">,</span> <span class="s2">&quot;^NDX&quot;</span><span class="p">]:</span>
    <span class="n">fname</span> <span class="o">=</span> <span class="s2">&quot;datasets/</span><span class="si">{}</span><span class="s2">.csv&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
    <span class="k">with</span> <span class="n">pkg_resources</span><span class="o">.</span><span class="n">resource_stream</span><span class="p">(</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">fname</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
      <span class="n">days</span><span class="p">,</span> <span class="n">values</span> <span class="o">=</span> <span class="n">load_finance_yahoo_data</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
      <span class="n">pad_opening_values</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
      <span class="n">data</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">days</span><span class="p">,</span> <span class="n">values</span><span class="p">))</span>
  <span class="k">return</span> <span class="n">data</span></div>



<div class="viewcode-block" id="barabasi1991_fractal">
<a class="viewcode-back" href="../../nolds.html#nolds.barabasi1991_fractal">[docs]</a>
<span class="k">def</span> <span class="nf">barabasi1991_fractal</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">iterations</span><span class="p">,</span> <span class="n">b1</span><span class="o">=</span><span class="mf">0.8</span><span class="p">,</span> <span class="n">b2</span><span class="o">=</span><span class="mf">0.5</span><span class="p">):</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Generates the simple fractal described in [bf]_.</span>

<span class="sd">  The fractal divides a rectangular segment starting at (x0, y0) with width w</span>
<span class="sd">  and height h along the x axis into four line segments of equal size with the</span>
<span class="sd">  boundary points [x0, x1, x2, x3, x4]. It has two parameters b1 and b2 that</span>
<span class="sd">  allow to choose the value for y(x1) and y(x3) while it always holds that</span>
<span class="sd">  y(x0) = y0, y(x2) = y0 and y(x4) = y0 + h.</span>

<span class="sd">  The process starts with a single line segment of height 1 spanning the whole</span>
<span class="sd">  data range. In each iteration, the rectangles spanning the line segments</span>
<span class="sd">  from the previous iteration are subdivided according to the same rule.</span>

<span class="sd">  References:</span>
<span class="sd">    .. [bf] A.-L. Barabási and T. Vicsek, “Multifractality of self-affine</span>
<span class="sd">       fractals,” Physical Review A, vol. 44, no. 4, pp. 2730–2733, 1991.</span>

<span class="sd">  Args:</span>
<span class="sd">    size (int):</span>
<span class="sd">      number of data points in the resulting array</span>
<span class="sd">    iterations (int):</span>
<span class="sd">      number of iterations to perform</span>

<span class="sd">  Kwargs:</span>
<span class="sd">    b1 (float):</span>
<span class="sd">      relative height at x1 (between 0 and 1)</span>
<span class="sd">    b2 (float):</span>
<span class="sd">      relative height at x3 (between 0 and 1)</span>

<span class="sd">  Returns:</span>
<span class="sd">    (1d-array of float):</span>
<span class="sd">      generated fractal</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="k">def</span> <span class="nf">b1991</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">h</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
      <span class="c1"># for a segment with negative slope we have flip the x-axis</span>
      <span class="n">d</span><span class="p">,</span> <span class="n">nxtp</span> <span class="o">=</span> <span class="n">b1991</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">y0</span> <span class="o">+</span> <span class="n">h</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="o">-</span><span class="n">h</span><span class="p">)</span>
      <span class="k">return</span> <span class="n">d</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">nxtp</span>
    <span class="n">x1</span> <span class="o">=</span> <span class="n">x0</span> <span class="o">+</span> <span class="n">w</span> <span class="o">//</span> <span class="mi">4</span>
    <span class="n">x2</span> <span class="o">=</span> <span class="n">x0</span> <span class="o">+</span> <span class="n">w</span> <span class="o">//</span> <span class="mi">2</span>
    <span class="n">x3</span> <span class="o">=</span> <span class="n">x2</span> <span class="o">+</span> <span class="n">w</span> <span class="o">//</span> <span class="mi">4</span>
    <span class="n">x4</span> <span class="o">=</span> <span class="n">x0</span> <span class="o">+</span> <span class="n">w</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
    <span class="n">data</span><span class="p">[</span><span class="n">x0</span> <span class="o">-</span> <span class="n">x0</span><span class="p">:</span><span class="n">x1</span> <span class="o">-</span> <span class="n">x0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x1</span> <span class="o">-</span> <span class="n">x0</span><span class="p">)</span> <span class="o">*</span> <span class="n">b1</span> <span class="o">*</span> <span class="n">h</span> <span class="o">+</span> <span class="n">y0</span>
    <span class="n">data</span><span class="p">[</span><span class="n">x1</span> <span class="o">-</span> <span class="n">x0</span><span class="p">:</span><span class="n">x2</span> <span class="o">-</span> <span class="n">x0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">x2</span> <span class="o">-</span> <span class="n">x1</span><span class="p">)</span> <span class="o">*</span> <span class="n">b1</span> <span class="o">*</span> <span class="n">h</span> <span class="o">+</span> <span class="n">y0</span>
    <span class="n">data</span><span class="p">[</span><span class="n">x2</span> <span class="o">-</span> <span class="n">x0</span><span class="p">:</span><span class="n">x3</span> <span class="o">-</span> <span class="n">x0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x3</span> <span class="o">-</span> <span class="n">x2</span><span class="p">)</span> <span class="o">*</span> <span class="n">b2</span> <span class="o">*</span> <span class="n">h</span> <span class="o">+</span> <span class="n">y0</span>
    <span class="n">data</span><span class="p">[</span><span class="n">x3</span> <span class="o">-</span> <span class="n">x0</span><span class="p">:</span><span class="n">x4</span> <span class="o">-</span> <span class="n">x0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x4</span> <span class="o">-</span> <span class="n">x3</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">b2</span><span class="p">)</span> <span class="o">*</span> <span class="n">h</span> \
                          <span class="o">+</span> <span class="n">y0</span> <span class="o">+</span> <span class="n">b2</span> <span class="o">*</span> <span class="n">h</span>
    <span class="k">return</span> <span class="n">data</span><span class="p">,</span> <span class="p">[</span><span class="n">x0</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">x3</span><span class="p">,</span> <span class="n">x4</span><span class="p">]</span>
  <span class="n">fractal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>
  <span class="n">intervals</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="n">size</span><span class="p">)]</span>
  <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">iterations</span><span class="p">):</span>
    <span class="n">next_intervals</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span> <span class="ow">in</span> <span class="n">intervals</span><span class="p">:</span>
      <span class="n">d</span><span class="p">,</span> <span class="n">nxtp</span> <span class="o">=</span> <span class="n">b1991</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">fractal</span><span class="p">[</span><span class="n">x1</span><span class="p">],</span> <span class="n">x2</span> <span class="o">-</span> <span class="n">x1</span><span class="p">,</span> <span class="n">fractal</span><span class="p">[</span><span class="n">x2</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">fractal</span><span class="p">[</span><span class="n">x1</span><span class="p">])</span>
      <span class="n">fractal</span><span class="p">[</span><span class="n">x1</span><span class="p">:</span><span class="n">x2</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span>
      <span class="n">next_intervals</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
        <span class="p">[(</span><span class="n">np1</span><span class="p">,</span> <span class="n">np2</span><span class="p">)</span> <span class="k">for</span> <span class="n">np1</span><span class="p">,</span> <span class="n">np2</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">nxtp</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">nxtp</span><span class="p">[</span><span class="mi">1</span><span class="p">:])]</span>
      <span class="p">)</span>
    <span class="n">intervals</span> <span class="o">=</span> <span class="n">next_intervals</span>
  <span class="k">return</span> <span class="n">fractal</span></div>



<span class="n">brown72</span> <span class="o">=</span> <span class="n">load_brown72</span><span class="p">()</span>
<span class="n">jkse</span><span class="p">,</span> <span class="n">n225</span><span class="p">,</span> <span class="n">ndx</span> <span class="o">=</span> <span class="n">load_financial</span><span class="p">()</span>
</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">Nolds</a></h1>









<search id="searchbox" style="display: none" role="search">
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" placeholder="Search"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script><h3>Navigation</h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../nolds.html"><code class="docutils literal notranslate"><span class="pre">nolds</span></code> module</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples.html">Nolds examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tests.html">Nolds Unittests</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  <li><a href="../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;2016-2024, Christopher Schölzel.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 8.0.2</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 1.0.0</a>
      
    </div>

    

    
  </body>
</html>