
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>nolds module &#8212; Nolds 0.5.1 documentation</title>
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0.5.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Nolds examples" href="examples.html" />
    <link rel="prev" title="Welcome to Nolds’ documentation!" href="index.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head>
  <body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="nolds-module">
<h1><code class="docutils literal"><span class="pre">nolds</span></code> module<a class="headerlink" href="#nolds-module" title="Permalink to this headline">¶</a></h1>
<p>Nolds only consists of to single module called <code class="docutils literal"><span class="pre">nolds</span></code> which contains all
relevant algorithms and helper functions.</p>
<p>Internally these functions are subdivided into different modules such as
<code class="docutils literal"><span class="pre">measures</span></code> and <code class="docutils literal"><span class="pre">datasets</span></code>, but you should not need to import these modules
directly unless you want access to some internal helper functions.</p>
<div class="section" id="algorithms">
<h2>Algorithms<a class="headerlink" href="#algorithms" title="Permalink to this headline">¶</a></h2>
<div class="section" id="lyapunov-exponent-rosenstein-et-al">
<h3>Lyapunov exponent (Rosenstein et al.)<a class="headerlink" href="#lyapunov-exponent-rosenstein-et-al" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="nolds.lyap_r">
<code class="descclassname">nolds.</code><code class="descname">lyap_r</code><span class="sig-paren">(</span><em>data</em>, <em>emb_dim=10</em>, <em>lag=None</em>, <em>min_tsep=None</em>, <em>tau=1</em>, <em>min_neighbors=20</em>, <em>trajectory_len=20</em>, <em>fit='RANSAC'</em>, <em>debug_plot=False</em>, <em>debug_data=False</em>, <em>plot_file=None</em>, <em>fit_offset=0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nolds/measures.html#lyap_r"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nolds.lyap_r" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimates the largest Lyapunov exponent using the algorithm of Rosenstein
et al. <a class="reference internal" href="#lr-1" id="id1">[lr_1]</a>.</p>
<dl class="docutils">
<dt>Explanation of Lyapunov exponents:</dt>
<dd>See lyap_e.</dd>
<dt>Explanation of the algorithm:</dt>
<dd><p class="first">The algorithm of Rosenstein et al. is only able to recover the largest
Lyapunov exponent, but behaves rather robust to parameter choices.</p>
<p>The idea for the algorithm relates closely to the definition of Lyapunov
exponents. First, the dynamics of the data are reconstructed using a delay
embedding method with a lag, such that each value x_i of the data is mapped
to the vector</p>
<p>X_i = [x_i, x_(i+lag), x_(i+2*lag), …, x_(i+(emb_dim-1) * lag)]</p>
<p>For each such vector X_i, we find the closest neighbor X_j using the
euclidean distance. We know that as we follow the trajectories from X_i and
X_j in time in a chaotic system the distances between X_(i+k) and X_(j+k)
denoted as d_i(k) will increase according to a power law
d_i(k) = c * e^(lambda * k) where lambda is a good approximation of the
highest Lyapunov exponent, because the exponential expansion along the axis
associated with this exponent will quickly dominate the expansion or
contraction along other axes.</p>
<p class="last">To calculate lambda, we look at the logarithm of the distance trajectory,
because log(d_i(k)) = log(c) + lambda * k. This gives a set of lines
(one for each index i) whose slope is an approximation of lambda. We
therefore extract the mean log trajectory d’(k) by taking the mean of
log(d_i(k)) over all orbit vectors X_i. We then fit a straight line to
the plot of d’(k) versus k. The slope of the line gives the desired
parameter lambda.</p>
</dd>
<dt>Method for choosing min_tsep:</dt>
<dd>Usually we want to find neighbors between points that are close in phase
space but not too close in time, because we want to avoid spurious
correlations between the obtained trajectories that originate from temporal
dependencies rather than the dynamic properties of the system. Therefore it
is critical to find a good value for min_tsep. One rather plausible
estimate for this value is to set min_tsep to the mean period of the
signal, which can be obtained by calculating the mean frequency using the
fast fourier transform. This procedure is used by default if the user sets
min_tsep = None.</dd>
<dt>Method for choosing lag:</dt>
<dd>Another parameter that can be hard to choose by instinct alone is the lag
between individual values in a vector of the embedded orbit. Here,
Rosenstein et al. suggest to set the lag to the distance where the
autocorrelation function drops below 1 - 1/e times its original (maximal)
value. This procedure is used by default if the user sets lag = None.</dd>
<dt>References:</dt>
<dd><table class="first last docutils citation" frame="void" id="lr-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[lr_1]</a></td><td>M. T. Rosenstein, J. J. Collins, and C. J. De Luca,
“A practical method for calculating largest Lyapunov exponents from
small data sets,” Physica D: Nonlinear Phenomena, vol. 65, no. 1,
pp. 117–134, 1993.</td></tr>
</tbody>
</table>
</dd>
<dt>Reference Code:</dt>
<dd><table class="first docutils citation" frame="void" id="lr-a" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[lr_a]</td><td>mirwais, “Largest Lyapunov Exponent with Rosenstein’s Algorithm”,
url: <a class="reference external" href="http://www.mathworks.com/matlabcentral/fileexchange/38424-largest-lyapunov-exponent-with-rosenstein-s-algorithm">http://www.mathworks.com/matlabcentral/fileexchange/38424-largest-lyapunov-exponent-with-rosenstein-s-algorithm</a></td></tr>
</tbody>
</table>
<table class="last docutils citation" frame="void" id="lr-b" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[lr_b]</td><td>Shapour Mohammadi, “LYAPROSEN: MATLAB function to calculate
Lyapunov exponent”,
url: <a class="reference external" href="https://ideas.repec.org/c/boc/bocode/t741502.html">https://ideas.repec.org/c/boc/bocode/t741502.html</a></td></tr>
</tbody>
</table>
</dd>
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>data (iterable of float):</dt>
<dd>(one-dimensional) time series</dd>
</dl>
</dd>
<dt>Kwargs:</dt>
<dd><dl class="first last docutils">
<dt>emb_dim (int):</dt>
<dd>embedding dimension for delay embedding</dd>
<dt>lag (float):</dt>
<dd>lag for delay embedding</dd>
<dt>min_tsep (float):</dt>
<dd>minimal temporal separation between two “neighbors” (default:
find a suitable value by calculating the mean period of the data)</dd>
<dt>tau (float):</dt>
<dd>step size between data points in the time series in seconds
(normalization scaling factor for exponents)</dd>
<dt>min_neighbors (int):</dt>
<dd>if lag=None, the search for a suitable lag will be stopped when the
number of potential neighbors for a vector drops below min_neighbors</dd>
<dt>trajectory_len (int):</dt>
<dd>the time (in number of data points) to follow the distance
trajectories between two neighboring points</dd>
<dt>fit (str):</dt>
<dd>the fitting method to use for the line fit, either ‘poly’ for normal
least squares polynomial fitting or ‘RANSAC’ for RANSAC-fitting which
is more robust to outliers</dd>
<dt>debug_plot (boolean):</dt>
<dd>if True, a simple plot of the final line-fitting step will
be shown</dd>
<dt>debug_data (boolean):</dt>
<dd>if True, debugging data will be returned alongside the result</dd>
<dt>plot_file (str):</dt>
<dd>if debug_plot is True and plot_file is not None, the plot will be saved
under the given file name instead of directly showing it through
<code class="docutils literal"><span class="pre">plt.show()</span></code></dd>
<dt>fit_offset (int):</dt>
<dd>neglect the first fit_offset steps when fitting</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>float:</dt>
<dd>an estimate of the largest Lyapunov exponent (a positive exponent is
a strong indicator for chaos)</dd>
<dt>(1d-vector, 1d-vector, list):</dt>
<dd>only present if debug_data is True: debug data of the form
<code class="docutils literal"><span class="pre">(ks,</span> <span class="pre">div_traj,</span> <span class="pre">poly)</span></code> where <code class="docutils literal"><span class="pre">ks</span></code> are the x-values of the line fit, 
<code class="docutils literal"><span class="pre">div_traj</span></code> are the y-values and <code class="docutils literal"><span class="pre">poly</span></code> are the line coefficients
(<code class="docutils literal"><span class="pre">[slope,</span> <span class="pre">intercept]</span></code>).</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="lyapunov-exponent-eckmann-et-al">
<h3>Lyapunov exponent (Eckmann et al.)<a class="headerlink" href="#lyapunov-exponent-eckmann-et-al" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="nolds.lyap_e">
<code class="descclassname">nolds.</code><code class="descname">lyap_e</code><span class="sig-paren">(</span><em>data</em>, <em>emb_dim=10</em>, <em>matrix_dim=4</em>, <em>min_nb=None</em>, <em>min_tsep=0</em>, <em>tau=1</em>, <em>debug_plot=False</em>, <em>debug_data=False</em>, <em>plot_file=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nolds/measures.html#lyap_e"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nolds.lyap_e" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimates the Lyapunov exponents for the given data using the algorithm of
Eckmann et al. <a class="reference internal" href="#le-1" id="id2">[le_1]</a>.</p>
<dl class="docutils">
<dt>Recommendations for parameter settings by Eckmann et al.:</dt>
<dd><ul class="first last simple">
<li>long recording time improves accuracy, small tau does not</li>
<li>use large values for emb_dim</li>
<li>matrix_dim should be ‘somewhat larger than the expected number of
positive Lyapunov exponents’</li>
<li>min_nb = min(2 * matrix_dim, matrix_dim + 4)</li>
</ul>
</dd>
<dt>Explanation of Lyapunov exponents:</dt>
<dd><p class="first">The Lyapunov exponent describes the rate of separation of two
infinitesimally close trajectories of a dynamical system in phase space.
In a chaotic system, these trajectories diverge exponentially following
the equation:</p>
<p>|X(t, X_0) - X(t, X_0 + eps)| = e^(lambda * t) * |eps|</p>
<p class="last">In this equation X(t, X_0) is the trajectory of the system X starting at
the point X_0 in phase space at time t. eps is the (infinitesimal)
difference vector and lambda is called the Lyapunov exponent. If the
system has more than one free variable, the phase space is
multidimensional and each dimension has its own Lyapunov exponent. The
existence of at least one positive Lyapunov exponent is generally seen as
a strong indicator for chaos.</p>
</dd>
<dt>Explanation of the Algorithm:</dt>
<dd><p class="first">To calculate the Lyapunov exponents analytically, the Jacobian of the
system is required. The algorithm of Eckmann et al. therefore tries to
estimate this Jacobian by reconstructing the dynamics of the system from
which the time series was obtained. For this, several steps are required:</p>
<ul class="last simple">
<li>Embed the time series [x_1, x_2, …, x_(N-1)] in an orbit of emb_dim
dimensions (map each point x_i of the time series to a vector
[x_i, x_(i+1), x_(i+2), … x_(i+emb_dim-1)]).</li>
<li>For each vector X_i in this orbit find a radius r_i so that at least
min_nb other vectors lie within (chebyshev-)distance r_i around X_i.
These vectors will be called “neighbors” of X_i.</li>
<li>Find the Matrix T_i that sends points from the neighborhood of X_i to
the neighborhood of X_(i+1). To avoid undetermined values in T_i, we
construct T_i not with size (emb_dim x emb_dim) but with size
(matrix_dim x matrix_dim), so that we have a larger “step size” m in the
X_i, which are now defined as X’_i = [x_i, x_(i+m), x_(i+2m),
… x_(i+(matrix_dim-1)*m)]. This means that emb_dim-1 must be divisible
by matrix_dim-1. The T_i are then found by a linear least squares fit,
assuring that T_i (X_j - X_i) ~= X_(j+m) - X_(i+m) for any X_j in the
neighborhood of X_i.</li>
<li>Starting with i = 1 and Q_0 = identity successively decompose the matrix
T_i * Q_(i-1) into the matrices Q_i and R_i by a QR-decomposition.</li>
<li>Calculate the Lyapunov exponents from the mean of the logarithm of the
diagonal elements of the matrices R_i. To normalize the Lyapunov
exponents, they have to be divided by m and by the step size tau of the
original time series.</li>
</ul>
</dd>
<dt>References:</dt>
<dd><table class="first last docutils citation" frame="void" id="le-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[le_1]</a></td><td>J. P. Eckmann, S. O. Kamphorst, D. Ruelle, and S. Ciliberto,
“Liapunov exponents from time series,” Physical Review A,
vol. 34, no. 6, pp. 4971–4979, 1986.</td></tr>
</tbody>
</table>
</dd>
<dt>Reference code:</dt>
<dd><table class="first docutils citation" frame="void" id="le-a" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[le_a]</td><td>Manfred Füllsack, “Lyapunov exponent”,
url: <a class="reference external" href="http://systems-sciences.uni-graz.at/etextbook/sw2/lyapunov.html">http://systems-sciences.uni-graz.at/etextbook/sw2/lyapunov.html</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="le-b" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[le_b]</td><td>Steve SIU, Lyapunov Exponents Toolbox (LET),
url: <a class="reference external" href="http://www.mathworks.com/matlabcentral/fileexchange/233-let/content/LET/findlyap.m">http://www.mathworks.com/matlabcentral/fileexchange/233-let/content/LET/findlyap.m</a></td></tr>
</tbody>
</table>
<table class="last docutils citation" frame="void" id="le-c" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[le_c]</td><td>Rainer Hegger, Holger Kantz, and Thomas Schreiber, TISEAN,
url: <a class="reference external" href="http://www.mpipks-dresden.mpg.de/~tisean/Tisean_3.0.1/index.html">http://www.mpipks-dresden.mpg.de/~tisean/Tisean_3.0.1/index.html</a></td></tr>
</tbody>
</table>
</dd>
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>data (array-like of float):</dt>
<dd>(scalar) data points</dd>
</dl>
</dd>
<dt>Kwargs:</dt>
<dd><dl class="first last docutils">
<dt>emb_dim (int):</dt>
<dd>embedding dimension</dd>
<dt>matrix_dim (int):</dt>
<dd>matrix dimension (emb_dim - 1 must be divisible by matrix_dim - 1)</dd>
<dt>min_nb (int):</dt>
<dd>minimal number of neighbors
(default: min(2 * matrix_dim, matrix_dim + 4))</dd>
<dt>min_tsep (int):</dt>
<dd>minimal temporal separation between two “neighbors”</dd>
<dt>tau (float):</dt>
<dd>step size of the data in seconds
(normalization scaling factor for exponents)</dd>
<dt>debug_plot (boolean):</dt>
<dd>if True, a histogram matrix of the individual estimates will be shown</dd>
<dt>debug_data (boolean):</dt>
<dd>if True, debugging data will be returned alongside the result</dd>
<dt>plot_file (str):</dt>
<dd>if debug_plot is True and plot_file is not None, the plot will be saved
under the given file name instead of directly showing it through
<code class="docutils literal"><span class="pre">plt.show()</span></code></dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>float array:</dt>
<dd>array of matrix_dim Lyapunov exponents (positive exponents are indicators
for chaos)</dd>
<dt>2d-array of floats:</dt>
<dd>only present if debug_data is True: all estimates for the matrix_dim
Lyapunov exponents from the x iterations of R_i. The shape of this debug
data is (x, matrix_dim).</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="sample-entropy">
<h3>Sample entropy<a class="headerlink" href="#sample-entropy" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="nolds.sampen">
<code class="descclassname">nolds.</code><code class="descname">sampen</code><span class="sig-paren">(</span><em>data</em>, <em>emb_dim=2</em>, <em>tolerance=None</em>, <em>dist=&lt;function rowwise_chebyshev&gt;</em>, <em>debug_plot=False</em>, <em>debug_data=False</em>, <em>plot_file=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nolds/measures.html#sampen"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nolds.sampen" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the sample entropy of the given data.</p>
<dl class="docutils">
<dt>Explanation of the sample entropy:</dt>
<dd><p class="first">The sample entropy of a time series is defined as the negative natural
logarithm of the conditional probability that two sequences similar for
emb_dim points remain similar at the next point, excluding self-matches.</p>
<p class="last">A lower value for the sample entropy therefore corresponds to a higher
probability indicating more self-similarity.</p>
</dd>
<dt>Explanation of the algorithm:</dt>
<dd>The algorithm constructs all subsequences of length emb_dim
[s_1, s_2, s_3, …] and then counts each pair (s_i, s_j) with i != j
where dist(s_i, s_j) &lt; tolerance. The same process is repeated for all
subsequences of length emb_dim + 1. The sum of similar sequence pairs
with length emb_dim + 1 is divided by the sum of similar sequence pairs
with length emb_dim. The result of the algorithm is the negative logarithm
of this ratio/probability.</dd>
<dt>References:</dt>
<dd><table class="first last docutils citation" frame="void" id="se-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[se_1]</td><td>J. S. Richman and J. R. Moorman, “Physiological time-series
analysis using approximate entropy and sample entropy,”
American Journal of Physiology-Heart and Circulatory Physiology,
vol. 278, no. 6, pp. H2039–H2049, 2000.</td></tr>
</tbody>
</table>
</dd>
<dt>Reference code:</dt>
<dd><table class="first last docutils citation" frame="void" id="se-a" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[se_a]</td><td>“sample_entropy” function in R-package “pracma”,
url: <a class="reference external" href="https://cran.r-project.org/web/packages/pracma/pracma.pdf">https://cran.r-project.org/web/packages/pracma/pracma.pdf</a></td></tr>
</tbody>
</table>
</dd>
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>data (array-like of float):</dt>
<dd>input data</dd>
</dl>
</dd>
<dt>Kwargs:</dt>
<dd><dl class="first last docutils">
<dt>emb_dim (int):</dt>
<dd>the embedding dimension (length of vectors to compare)</dd>
<dt>tolerance (float):</dt>
<dd>distance threshold for two template vectors to be considered equal
(default: 0.2 * std(data))</dd>
<dt>dist (function (2d-array, 1d-array) -&gt; 1d-array):</dt>
<dd>distance function used to calculate the distance between template
vectors. Sampen is defined using <code class="docutils literal"><span class="pre">rowwise_chebyshev</span></code>. You should only use
something else, if you are sure that you need it.</dd>
<dt>debug_plot (boolean):</dt>
<dd>if True, a histogram of the individual distances for m and m+1</dd>
<dt>debug_data (boolean):</dt>
<dd>if True, debugging data will be returned alongside the result</dd>
<dt>plot_file (str):</dt>
<dd>if debug_plot is True and plot_file is not None, the plot will be saved
under the given file name instead of directly showing it through
<code class="docutils literal"><span class="pre">plt.show()</span></code></dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>float:</dt>
<dd>the sample entropy of the data (negative logarithm of ratio between
similar template vectors of length emb_dim + 1 and emb_dim)</dd>
<dt>[float list, float list]:</dt>
<dd>Lists of lists of the form <code class="docutils literal"><span class="pre">[dists_m,</span> <span class="pre">dists_m1]</span></code> containing the distances
between template vectors for m (dists_m) and for m + 1 (dists_m1).</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="hurst-exponent">
<h3>Hurst exponent<a class="headerlink" href="#hurst-exponent" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="nolds.hurst_rs">
<code class="descclassname">nolds.</code><code class="descname">hurst_rs</code><span class="sig-paren">(</span><em>data</em>, <em>nvals=None</em>, <em>fit='RANSAC'</em>, <em>debug_plot=False</em>, <em>debug_data=False</em>, <em>plot_file=None</em>, <em>corrected=True</em>, <em>unbiased=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nolds/measures.html#hurst_rs"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nolds.hurst_rs" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the Hurst exponent by a standard rescaled range (R/S) approach.</p>
<dl class="docutils">
<dt>Explanation of Hurst exponent:</dt>
<dd><p class="first">The Hurst exponent is a measure for the “long-term memory” of a
time series, meaning the long statistical dependencies in the data that do
not originate from cycles.</p>
<p>It originates from H.E. Hursts observations of the problem of long-term
storage in water reservoirs. If x_i is the discharge of a river in year i
and we observe this discharge for N years, we can calculate the storage
capacity that would be required to keep the discharge steady at its mean
value.</p>
<p>To do so, we first substract the mean over all x_i from the individual
x_i to obtain the departures x’_i from the mean for each year i. As the
excess or deficit in discharge always carrys over from year i to year i+1,
we need to examine the cumulative sum of x’_i, denoted by y_i. This
cumulative sum represents the filling of our hypothetical storage. If the
sum is above 0, we are storing excess discharge from the river, if it is
below zero we have compensated a deficit in discharge by releasing
water from the storage. The range (maximum - minimum) R of y_i therefore
represents the total capacity required for the storage.</p>
<p>Hurst showed that this value follows a steady trend for varying N if it
is normalized by the standard deviation sigma over the x_i. Namely he
obtained the following formula:</p>
<p>R/sigma = (N/2)^K</p>
<p class="last">In this equation, K is called the Hurst exponent. Its value is 0.5 for
white noise, but becomes greater for time series that exhibit some positive
dependency on previous values. For negative dependencies it becomes less
than 0.5.</p>
</dd>
<dt>Explanation of the algorithm:</dt>
<dd><p class="first">The rescaled range (R/S) approach is directly derived from Hurst’s
definition. The time series of length N is split into non-overlapping
subseries of length n. Then, R and S (S = sigma) are calculated for each
subseries and the mean is taken over all subseries yielding (R/S)_n. This
process is repeated for several lengths n. Finally, the exponent K is
obtained by fitting a straight line to the plot of log((R/S)_n) vs log(n).</p>
<p>There seems to be no consensus how to chose the subseries lenghts n.
This function therefore leaves the choice to the user. The module provides
some utility functions for “typical” values:</p>
<blockquote class="last">
<div><ul class="simple">
<li>binary_n: N/2, N/4, N/8, …</li>
<li>logarithmic_n: min_n, min_n * f, min_n * f^2, …</li>
</ul>
</div></blockquote>
</dd>
<dt>References:</dt>
<dd><table class="first docutils citation" frame="void" id="h-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[h_1]</td><td>H. E. Hurst, “The problem of long-term storage in reservoirs,”
International Association of Scientific Hydrology. Bulletin, vol. 1,
no. 3, pp. 13–27, 1956.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="h-2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[h_2]</td><td>H. E. Hurst, “A suggested statistical model of some time series
which occur in nature,” Nature, vol. 180, p. 494, 1957.</td></tr>
</tbody>
</table>
<table class="last docutils citation" frame="void" id="h-3" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[h_3]</td><td><em>(<a class="fn-backref" href="#id3">1</a>, <a class="fn-backref" href="#id4">2</a>)</em> R. Weron, “Estimating long-range dependence: finite sample
properties and confidence intervals,” Physica A: Statistical Mechanics
and its Applications, vol. 312, no. 1, pp. 285–299, 2002.</td></tr>
</tbody>
</table>
</dd>
<dt>Reference Code:</dt>
<dd><table class="first docutils citation" frame="void" id="h-a" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[h_a]</td><td><p class="first">“hurst” function in R-package “pracma”,
url: <a class="reference external" href="https://cran.r-project.org/web/packages/pracma/pracma.pdf">https://cran.r-project.org/web/packages/pracma/pracma.pdf</a></p>
<p>Note: Pracma yields several estimates of the Hurst exponent, which
are listed below. Unless otherwise stated they use the divisors
of the length of the sequence as n. The length is reduced by at
most 1% to find the value that has the most divisors.</p>
<ul class="simple">
<li>The “Simple R/S” estimate is just log((R/S)_n) / log(n) for 
n = N.</li>
<li>The “theoretical Hurst exponent” is the value that would be
expected of an uncorrected rescaled range approach for random
noise of the size of the input data.</li>
<li>The “empirical Hurst exponent” is the uncorrected Hurst exponent
obtained by the rescaled range approach.</li>
<li>The “corrected empirical Hurst exponent” is the Anis-Lloyd-Peters
corrected Hurst exponent, but with sqrt(1/2 * pi * n) added to
the (R/S)_n before the log.</li>
<li>The “corrected R over S Hurst exponent” uses the R-function “lm”
instead of pracmas own “polyfit” and uses n = N/2, N/4, N/8, …
by successively halving the subsequences (which means that some
subsequences may be one element longer than others). In contrast
to its name it does not use the Anis-Lloyd-Peters correction
factor.</li>
</ul>
<p class="last">If you want to compare the output of pracma to the output of
nolds, the “empirical hurst exponent” is the only measure that
exactly corresponds to the Hurst measure implemented in nolds
(by choosing corrected=False, fit=”poly” and employing the same
strategy for choosing n as the divisors of the (reduced)
sequence length).</p>
</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="h-b" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[h_b]</td><td><p class="first">Rafael Weron, “HURST: MATLAB function to compute the Hurst
exponent using R/S Analysis”,
url: <a class="reference external" href="https://ideas.repec.org/c/wuu/hscode/m11003.html">https://ideas.repec.org/c/wuu/hscode/m11003.html</a></p>
<p class="last">Note: When the same values for nvals are used and fit is set to
“poly”, nolds yields exactly the same results as this
implementation.</p>
</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="h-c" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[h_c]</td><td>Bill Davidson, “Hurst exponent”,
url: <a class="reference external" href="http://www.mathworks.com/matlabcentral/fileexchange/9842-hurst-exponent">http://www.mathworks.com/matlabcentral/fileexchange/9842-hurst-exponent</a></td></tr>
</tbody>
</table>
<table class="last docutils citation" frame="void" id="h-d" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[h_d]</td><td>Tomaso Aste, “Generalized Hurst exponent”,
url: <a class="reference external" href="http://de.mathworks.com/matlabcentral/fileexchange/30076-generalized-hurst-exponent">http://de.mathworks.com/matlabcentral/fileexchange/30076-generalized-hurst-exponent</a></td></tr>
</tbody>
</table>
</dd>
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>data (array-like of float):</dt>
<dd>time series</dd>
</dl>
</dd>
<dt>Kwargs:</dt>
<dd><dl class="first last docutils">
<dt>nvals (iterable of int):</dt>
<dd><p class="first">sizes of subseries to use
(default: logmid_n(total_N, ratio=1/4.0, nsteps=15) , that is 15
logarithmically spaced values in the medium 25% of the logarithmic range)</p>
<p class="last">Generally, the choice for n is a trade-off between the length and the
number of the subsequences that are used for the calculation of the
(R/S)_n. Very low values of n lead to high variance in the <code class="docutils literal"><span class="pre">r</span></code> and <code class="docutils literal"><span class="pre">s</span></code>
while very high values may leave too few subsequences that the mean along
them is still meaningful. Logarithmic spacing makes sense, because it 
translates to even spacing in the log-log-plot.</p>
</dd>
<dt>fit (str):</dt>
<dd>the fitting method to use for the line fit, either ‘poly’ for normal
least squares polynomial fitting or ‘RANSAC’ for RANSAC-fitting which
is more robust to outliers</dd>
<dt>debug_plot (boolean):</dt>
<dd>if True, a simple plot of the final line-fitting step will be shown</dd>
<dt>debug_data (boolean):</dt>
<dd>if True, debugging data will be returned alongside the result</dd>
<dt>plot_file (str):</dt>
<dd>if debug_plot is True and plot_file is not None, the plot will be saved
under the given file name instead of directly showing it through
<code class="docutils literal"><span class="pre">plt.show()</span></code></dd>
<dt>corrected (boolean):</dt>
<dd>if True, the Anis-Lloyd-Peters correction factor will be applied to the
output according to the expected value for the individual (R/S)_n
(see <a class="reference internal" href="#h-3" id="id3">[h_3]</a>)</dd>
<dt>unbiased (boolean):</dt>
<dd>if True, the standard deviation based on the unbiased variance
(1/(N-1) instead of 1/N) will be used. This should be the default choice,
since the true mean of the sequences is not known. This parameter should
only be changed to recreate results of other implementations.</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>float:</dt>
<dd>estimated Hurst exponent K using a rescaled range approach (if K = 0.5
there are no long-range correlations in the data, if K &lt; 0.5 there are
negative long-range correlations, if K &gt; 0.5 there are positive
long-range correlations)</dd>
<dt>(1d-vector, 1d-vector, list):</dt>
<dd>only present if debug_data is True: debug data of the form
<code class="docutils literal"><span class="pre">(nvals,</span> <span class="pre">rsvals,</span> <span class="pre">poly)</span></code> where <code class="docutils literal"><span class="pre">nvals</span></code> are the values used for log(n), 
<code class="docutils literal"><span class="pre">rsvals</span></code> are the corresponding log((R/S)_n) and <code class="docutils literal"><span class="pre">poly</span></code> are the line 
coefficients (<code class="docutils literal"><span class="pre">[slope,</span> <span class="pre">intercept]</span></code>)</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="correlation-dimension">
<h3>Correlation dimension<a class="headerlink" href="#correlation-dimension" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="nolds.corr_dim">
<code class="descclassname">nolds.</code><code class="descname">corr_dim</code><span class="sig-paren">(</span><em>data</em>, <em>emb_dim</em>, <em>rvals=None</em>, <em>dist=&lt;function rowwise_euclidean&gt;</em>, <em>fit='RANSAC'</em>, <em>debug_plot=False</em>, <em>debug_data=False</em>, <em>plot_file=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nolds/measures.html#corr_dim"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nolds.corr_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the correlation dimension with the Grassberger-Procaccia algorithm</p>
<dl class="docutils">
<dt>Explanation of correlation dimension:</dt>
<dd><p class="first">The correlation dimension is a characteristic measure that can be used
to describe the geometry of chaotic attractors. It is defined using the
correlation sum C(r) which is the fraction of pairs of points X_i in the
phase space whose distance is smaller than r.</p>
<p>If the relation between C(r) and r can be described by the power law</p>
<p>C(r) ~ r^D</p>
<p>then D is called the correlation dimension of the system.</p>
<p class="last">In a d-dimensional system, the maximum value for D is d. This value is
obtained for systems that expand uniformly in each dimension with time.
The lowest possible value is 0 for a system with constant C(r) (i.e. a
system that visits just one point in the phase space). Generally if D is
lower than d and the system has an attractor, this attractor is called
“strange” and D is a measure of this “strangeness”.</p>
</dd>
<dt>Explanation of the algorithm:</dt>
<dd><p class="first">The Grassberger-Procaccia algorithm calculates C(r) for a range of
different r and then fits a straight line into the plot of log(C(r))
versus log(r).</p>
<p class="last">This version of the algorithm is created for one-dimensional (scalar) time
series. Therefore, before calculating C(r), a delay embedding of the time
series is performed to yield emb_dim dimensional vectors
Y_i = [X_i, X_(i+1), X_(i+2), … X_(i+embd_dim-1)]. Choosing a higher
value for emb_dim allows to reconstruct higher dimensional dynamics and
avoids “systematic errors due to corrections to scaling”.</p>
</dd>
<dt>References:</dt>
<dd><table class="first docutils citation" frame="void" id="cd-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[cd_1]</td><td>P. Grassberger and I. Procaccia, “Characterization of strange
attractors,” Physical review letters, vol. 50, no. 5, p. 346,
1983.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="cd-2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[cd_2]</td><td>P. Grassberger and I. Procaccia, “Measuring the strangeness of
strange attractors,” Physica D: Nonlinear Phenomena, vol. 9,
no. 1, pp. 189–208, 1983.</td></tr>
</tbody>
</table>
<table class="last docutils citation" frame="void" id="cd-3" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[cd_3]</td><td>P. Grassberger, “Grassberger-Procaccia algorithm,”
Scholarpedia, vol. 2, no. 5, p. 3043.
urL: <a class="reference external" href="http://www.scholarpedia.org/article/Grassberger-Procaccia_algorithm">http://www.scholarpedia.org/article/Grassberger-Procaccia_algorithm</a></td></tr>
</tbody>
</table>
</dd>
<dt>Reference Code:</dt>
<dd><table class="first docutils citation" frame="void" id="cd-a" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[cd_a]</td><td>“corrDim” function in R package “fractal”,
url: <a class="reference external" href="https://cran.r-project.org/web/packages/fractal/fractal.pdf">https://cran.r-project.org/web/packages/fractal/fractal.pdf</a></td></tr>
</tbody>
</table>
<table class="last docutils citation" frame="void" id="cd-b" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[cd_b]</td><td>Peng Yuehua, “Correlation dimension”,
url: <a class="reference external" href="http://de.mathworks.com/matlabcentral/fileexchange/24089-correlation-dimension">http://de.mathworks.com/matlabcentral/fileexchange/24089-correlation-dimension</a></td></tr>
</tbody>
</table>
</dd>
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>data (array-like of float):</dt>
<dd>time series of data points</dd>
<dt>emb_dim (int):</dt>
<dd>embedding dimension</dd>
</dl>
</dd>
<dt>Kwargs:</dt>
<dd><dl class="first last docutils">
<dt>rvals (iterable of float):</dt>
<dd>list of values for to use for r
(default: logarithmic_r(0.1 * std, 0.5 * std, 1.03))</dd>
<dt>dist (function (2d-array, 1d-array) -&gt; 1d-array):</dt>
<dd>row-wise difference function</dd>
<dt>fit (str):</dt>
<dd>the fitting method to use for the line fit, either ‘poly’ for normal
least squares polynomial fitting or ‘RANSAC’ for RANSAC-fitting which
is more robust to outliers</dd>
<dt>debug_plot (boolean):</dt>
<dd>if True, a simple plot of the final line-fitting step will be shown</dd>
<dt>debug_data (boolean):</dt>
<dd>if True, debugging data will be returned alongside the result</dd>
<dt>plot_file (str):</dt>
<dd>if debug_plot is True and plot_file is not None, the plot will be saved
under the given file name instead of directly showing it through
<code class="docutils literal"><span class="pre">plt.show()</span></code></dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>float:</dt>
<dd>correlation dimension as slope of the line fitted to log(r) vs log(C(r))</dd>
<dt>(1d-vector, 1d-vector, list):</dt>
<dd>only present if debug_data is True: debug data of the form
<code class="docutils literal"><span class="pre">(rvals,</span> <span class="pre">csums,</span> <span class="pre">poly)</span></code> where <code class="docutils literal"><span class="pre">rvals</span></code> are the values used for log(r), 
<code class="docutils literal"><span class="pre">csums</span></code> are the corresponding log(C(r)) and <code class="docutils literal"><span class="pre">poly</span></code> are the line 
coefficients (<code class="docutils literal"><span class="pre">[slope,</span> <span class="pre">intercept]</span></code>)</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="detrended-fluctuation-analysis">
<h3>Detrended fluctuation analysis<a class="headerlink" href="#detrended-fluctuation-analysis" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="nolds.dfa">
<code class="descclassname">nolds.</code><code class="descname">dfa</code><span class="sig-paren">(</span><em>data</em>, <em>nvals=None</em>, <em>overlap=True</em>, <em>order=1</em>, <em>fit_trend='poly'</em>, <em>fit_exp='RANSAC'</em>, <em>debug_plot=False</em>, <em>debug_data=False</em>, <em>plot_file=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nolds/measures.html#dfa"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nolds.dfa" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs a detrended fluctuation analysis (DFA) on the given data</p>
<dl class="docutils">
<dt>Recommendations for parameter settings by Hardstone et al.:</dt>
<dd><ul class="first last simple">
<li>nvals should be equally spaced on a logarithmic scale so that each window
scale hase the same weight</li>
<li>min(nvals) &lt; 4 does not make much sense as fitting a polynomial (even if
it is only of order 1) to 3 or less data points is very prone.</li>
<li>max(nvals) &gt; len(data) / 10 does not make much sense as we will then have
less than 10 windows to calculate the average fluctuation</li>
<li>use overlap=True to obtain more windows and therefore better statistics
(at an increased computational cost)</li>
</ul>
</dd>
<dt>Explanation of DFA:</dt>
<dd><p class="first">Detrended fluctuation analysis, much like the Hurst exponent, is used to
find long-term statistical dependencies in time series.</p>
<p>The idea behind DFA originates from the definition of self-affine
processes. A process X is said to be self-affine if the standard deviation
of the values within a window of length n changes with the window length
factor L in a power law:</p>
<p>std(X,L * n) = L^H * std(X, n)</p>
<p>where std(X, k) is the standard deviation of the process X calculated over
windows of size k. In this equation, H is called the Hurst parameter, which
behaves indeed very similar to the Hurst exponent.</p>
<p>Like the Hurst exponent, H can be obtained from a time series by
calculating std(X,n) for different n and fitting a straight line to the
plot of log(std(X,n)) versus log(n).</p>
<p>To calculate a single std(X,n), the time series is split into windows of
equal length n, so that the ith window of this size has the form</p>
<p>W_(n,i) = [x_i, x_(i+1), x_(i+2), … x_(i+n-1)]</p>
<p>The value std(X,n) is then obtained by calculating std(W_(n,i)) for each i
and averaging the obtained values over i.</p>
<p>The aforementioned definition of self-affinity, however, assumes that the
process is  non-stationary (i.e. that the standard deviation changes over
time) and it is highly influenced by local and global trends of the time
series.</p>
<p>To overcome these problems, an estimate alpha of H is calculated by using a
“walk” or “signal profile” instead of the raw time series. This walk is
obtained by substracting the mean and then taking the cumulative sum of the
original time series. The local trends are removed for each window
separately by fitting a polynomial p_(n,i) to the window W_(n,i) and then
calculating W’_(n,i) = W_(n,i) - p_(n,i) (element-wise substraction).</p>
<p>We then calculate std(X,n) as before only using the “detrended” window
W’_(n,i) instead of W_(n,i). Instead of H we obtain the parameter alpha
from the line fitting.</p>
<p>For alpha &lt; 1 the underlying process is stationary and can be modelled as
fractional Gaussian noise with H = alpha. This means for alpha = 0.5 we
have no correlation or “memory”, for 0.5 &lt; alpha &lt; 1 we have a memory with
positive correlation and for alpha &lt; 0.5 the correlation is negative.</p>
<p class="last">For alpha &gt; 1 the underlying process is non-stationary and can be modeled
as fractional Brownian motion with H = alpha - 1.</p>
</dd>
<dt>References:</dt>
<dd><table class="first docutils citation" frame="void" id="dfa-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[dfa_1]</td><td>C.-K. Peng, S. V. Buldyrev, S. Havlin, M. Simons,
H. E. Stanley, and A. L. Goldberger, “Mosaic organization of
DNA nucleotides,” Physical Review E, vol. 49, no. 2, 1994.</td></tr>
</tbody>
</table>
<table class="last docutils citation" frame="void" id="dfa-2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[dfa_2]</td><td>R. Hardstone, S.-S. Poil, G. Schiavone, R. Jansen,
V. V. Nikulin, H. D. Mansvelder, and K. Linkenkaer-Hansen,
“Detrended fluctuation analysis: A scale-free view on neuronal
oscillations,” Frontiers in Physiology, vol. 30, 2012.</td></tr>
</tbody>
</table>
</dd>
<dt>Reference code:</dt>
<dd><table class="first docutils citation" frame="void" id="dfa-a" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[dfa_a]</td><td>Peter Jurica, “Introduction to MDFA in Python”,
url: <a class="reference external" href="http://bsp.brain.riken.jp/~juricap/mdfa/mdfaintro.html">http://bsp.brain.riken.jp/~juricap/mdfa/mdfaintro.html</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="dfa-b" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[dfa_b]</td><td>JE Mietus, “dfa”,
url: <a class="reference external" href="https://www.physionet.org/physiotools/dfa/dfa-1.htm">https://www.physionet.org/physiotools/dfa/dfa-1.htm</a></td></tr>
</tbody>
</table>
<table class="last docutils citation" frame="void" id="dfa-c" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[dfa_c]</td><td>“DFA” function in R package “fractal”</td></tr>
</tbody>
</table>
</dd>
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>data (array-like of float):</dt>
<dd>time series</dd>
</dl>
</dd>
<dt>Kwargs:</dt>
<dd><dl class="first last docutils">
<dt>nvals (iterable of int):</dt>
<dd>subseries sizes at which to calculate fluctuation
(default: logarithmic_n(4, 0.1*len(data), 1.2))</dd>
<dt>overlap (boolean):</dt>
<dd>if True, the windows W_(n,i) will have a 50% overlap,
otherwise non-overlapping windows will be used</dd>
<dt>order (int):</dt>
<dd>(polynomial) order of trend to remove</dd>
<dt>fit_trend (str):</dt>
<dd>the fitting method to use for fitting the trends, either ‘poly’
for normal least squares polynomial fitting or ‘RANSAC’ for
RANSAC-fitting which is more robust to outliers but also tends to
lead to unstable results</dd>
<dt>fit_exp (str):</dt>
<dd>the fitting method to use for the line fit, either ‘poly’ for normal
least squares polynomial fitting or ‘RANSAC’ for RANSAC-fitting which
is more robust to outliers</dd>
<dt>debug_plot (boolean):</dt>
<dd>if True, a simple plot of the final line-fitting step will be shown</dd>
<dt>debug_data (boolean):</dt>
<dd>if True, debugging data will be returned alongside the result</dd>
<dt>plot_file (str):</dt>
<dd>if debug_plot is True and plot_file is not None, the plot will be saved
under the given file name instead of directly showing it through
<code class="docutils literal"><span class="pre">plt.show()</span></code></dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>float:</dt>
<dd>the estimate alpha for the Hurst parameter (alpha &lt; 1: stationary
process similar to fractional Gaussian noise with H = alpha,
alpha &gt; 1: non-stationary process similar to fractional Brownian
motion with H = alpha - 1)</dd>
<dt>(1d-vector, 1d-vector, list):</dt>
<dd>only present if debug_data is True: debug data of the form
<code class="docutils literal"><span class="pre">(nvals,</span> <span class="pre">fluctuations,</span> <span class="pre">poly)</span></code> where <code class="docutils literal"><span class="pre">nvals</span></code> are the values used for
log(n), <code class="docutils literal"><span class="pre">fluctuations</span></code> are the corresponding log(std(X,n)) and <code class="docutils literal"><span class="pre">poly</span></code>
are the line coefficients (<code class="docutils literal"><span class="pre">[slope,</span> <span class="pre">intercept]</span></code>)</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
</div>
<div class="section" id="helper-functions">
<h2>Helper functions<a class="headerlink" href="#helper-functions" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="nolds.binary_n">
<code class="descclassname">nolds.</code><code class="descname">binary_n</code><span class="sig-paren">(</span><em>total_N</em>, <em>min_n=50</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nolds/measures.html#binary_n"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nolds.binary_n" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a list of values by successively halving the total length total_N
until the resulting value is less than min_n.</p>
<p>Non-integer results are rounded down.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>total_N (int):</dt>
<dd>total length</dd>
</dl>
</dd>
<dt>Kwargs:</dt>
<dd><dl class="first last docutils">
<dt>min_n (int):</dt>
<dd>minimal length after division</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>list of integers:</dt>
<dd>total_N/2, total_N/4, total_N/8, … until total_N/2^i &lt; min_n</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="nolds.logarithmic_n">
<code class="descclassname">nolds.</code><code class="descname">logarithmic_n</code><span class="sig-paren">(</span><em>min_n</em>, <em>max_n</em>, <em>factor</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nolds/measures.html#logarithmic_n"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nolds.logarithmic_n" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a list of values by successively multiplying a minimum value min_n by
a factor &gt; 1 until a maximum value max_n is reached.</p>
<p>Non-integer results are rounded down.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>min_n (float):</dt>
<dd>minimum value (must be &lt; max_n)</dd>
<dt>max_n (float):</dt>
<dd>maximum value (must be &gt; min_n)</dd>
<dt>factor (float):</dt>
<dd>factor used to increase min_n (must be &gt; 1)</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>list of integers:</dt>
<dd>min_n, min_n * factor, min_n * factor^2, … min_n * factor^i &lt; max_n
without duplicates</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="nolds.logarithmic_r">
<code class="descclassname">nolds.</code><code class="descname">logarithmic_r</code><span class="sig-paren">(</span><em>min_n</em>, <em>max_n</em>, <em>factor</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nolds/measures.html#logarithmic_r"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nolds.logarithmic_r" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a list of values by successively multiplying a minimum value min_n by
a factor &gt; 1 until a maximum value max_n is reached.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>min_n (float):</dt>
<dd>minimum value (must be &lt; max_n)</dd>
<dt>max_n (float):</dt>
<dd>maximum value (must be &gt; min_n)</dd>
<dt>factor (float):</dt>
<dd>factor used to increase min_n (must be &gt; 1)</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>list of floats:</dt>
<dd>min_n, min_n * factor, min_n * factor^2, … min_n * factor^i &lt; max_n</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="nolds.expected_h">
<code class="descclassname">nolds.</code><code class="descname">expected_h</code><span class="sig-paren">(</span><em>nvals</em>, <em>fit='RANSAC'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nolds/measures.html#expected_h"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nolds.expected_h" title="Permalink to this definition">¶</a></dt>
<dd><p>Uses expected_rs to calculate the expected value for the Hurst exponent h
based on the values of n used for the calculation.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>nvals (iterable of int):</dt>
<dd>the values of n used to calculate the individual (R/S)_n</dd>
</dl>
</dd>
<dt>KWargs:</dt>
<dd><dl class="first last docutils">
<dt>fit (str):</dt>
<dd>the fitting method to use for the line fit, either ‘poly’ for normal
least squares polynomial fitting or ‘RANSAC’ for RANSAC-fitting which
is more robust to outliers</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>float:</dt>
<dd>expected h for white noise</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="nolds.expected_rs">
<code class="descclassname">nolds.</code><code class="descname">expected_rs</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nolds/measures.html#expected_rs"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nolds.expected_rs" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the expected (R/S)_n for white noise for a given n.</p>
<p>This is used as a correction factor in the function hurst_rs. It uses the
formula of Anis-Lloyd-Peters (see <a class="reference internal" href="#h-3" id="id4">[h_3]</a>).</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>n (int):</dt>
<dd>the value of n for which the expected (R/S)_n should be calculated</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>float:</dt>
<dd>expected (R/S)_n for white noise</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="nolds.logmid_n">
<code class="descclassname">nolds.</code><code class="descname">logmid_n</code><span class="sig-paren">(</span><em>max_n</em>, <em>ratio=0.25</em>, <em>nsteps=15</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nolds/measures.html#logmid_n"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nolds.logmid_n" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates an array of integers that lie evenly spaced in the “middle” of the
logarithmic scale from 0 to log(max_n).</p>
<p>If max_n is very small and/or nsteps is very large, this may lead to
duplicate values which will be removed from the output.</p>
<p>This function has benefits in hurst_rs, because it cuts away both very small
and very large n, which both can cause problems, and still produces a
logarithmically spaced sequence.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>max_n (int):</dt>
<dd>largest possible output value (should be the sequence length when used in
hurst_rs)</dd>
</dl>
</dd>
<dt>Kwargs:</dt>
<dd><dl class="first last docutils">
<dt>ratio (float):</dt>
<dd>width of the “middle” of the logarithmic interval relative to log(max_n).
For example, for ratio=1/2.0 the logarithm of the resulting values will
lie between 0.25 * log(max_n) and 0.75 * log(max_n).</dd>
<dt>nsteps (float):</dt>
<dd>(maximum) number of values to take from the specified range</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>array of int:</dt>
<dd>a logarithmically spaced sequence of at most nsteps values (may be less,
because only unique values are returned)</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="nolds.lyap_r_len">
<code class="descclassname">nolds.</code><code class="descname">lyap_r_len</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nolds/measures.html#lyap_r_len"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nolds.lyap_r_len" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper function that calculates the minimum number of data points required
to use lyap_r.</p>
<p>Note that none of the required parameters may be set to None.</p>
<dl class="docutils">
<dt>Kwargs:</dt>
<dd><dl class="first last docutils">
<dt>kwargs(dict):</dt>
<dd>arguments used for lyap_r (required: emb_dim, lag, trajectory_len and
min_tsep)</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>minimum number of data points required to call lyap_r with the given
parameters</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="nolds.lyap_e_len">
<code class="descclassname">nolds.</code><code class="descname">lyap_e_len</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nolds/measures.html#lyap_e_len"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nolds.lyap_e_len" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper function that calculates the minimum number of data points required
to use lyap_e.</p>
<p>Note that none of the required parameters may be set to None.</p>
<dl class="docutils">
<dt>Kwargs:</dt>
<dd><dl class="first last docutils">
<dt>kwargs(dict):</dt>
<dd>arguments used for lyap_e (required: emb_dim, matrix_dim, min_nb
and min_tsep)</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>minimum number of data points required to call lyap_e with the given
parameters</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="datasets">
<h2>Datasets<a class="headerlink" href="#datasets" title="Permalink to this headline">¶</a></h2>
<div class="section" id="benchmark-dataset-for-hurst-exponent">
<h3>Benchmark dataset for hurst exponent<a class="headerlink" href="#benchmark-dataset-for-hurst-exponent" title="Permalink to this headline">¶</a></h3>
<dl class="data">
<dt id="nolds.brown72">
<code class="descclassname">nolds.</code><code class="descname">brown72</code><em class="property"> = array([45.47422, 42.55601, 46.5188 , ..., 42.78297, 44.34307, 40.70655])</em><a class="headerlink" href="#nolds.brown72" title="Permalink to this definition">¶</a></dt>
<dd><p>The brown72 dataset has a prescribed (uncorrected) Hurst exponent of 0.7270.
It is a synthetic dataset from the book “Chaos and Order in the Capital
markets”<a class="reference internal" href="#b7-a" id="id5">[b7_a]</a>.</p>
<p>It is included here, because the dataset can be found online <a class="reference internal" href="#b7-b" id="id6">[b7_b]</a> and is
used by other software packages such as the R-package <code class="docutils literal"><span class="pre">pracma</span></code> <a class="reference internal" href="#b7-c" id="id7">[b7_c]</a>.
As such it can be used to compare different implementations.</p>
<p>However, it should be noted that the idea that the “true” Hurst exponent of
this series is indeed 0.7270 is problematic for several reasons:</p>
<ol class="arabic simple">
<li>This value does not take into account the Anis-Lloyd-Peters correction
factor.</li>
<li>It was obtained using the biased version of the standard deviation.</li>
<li>It depends (as always for the Hurst exponent) on the choice of the length
of the subsequences.</li>
</ol>
<p>If you want to reproduce the prescribed value, you can use the following
code:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">nolds</span><span class="o">.</span><span class="n">hurst_rs</span><span class="p">(</span>
   <span class="n">nolds</span><span class="o">.</span><span class="n">brown72</span><span class="p">,</span>
   <span class="n">nvals</span><span class="o">=</span><span class="mi">2</span><span class="o">**</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">11</span><span class="p">),</span>
   <span class="n">fit</span><span class="o">=</span><span class="s2">&quot;poly&quot;</span><span class="p">,</span> <span class="n">corrected</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">unbiased</span><span class="o">=</span><span class="bp">False</span>
<span class="p">)</span>
</pre></div>
</div>
<p>References:</p>
<table class="docutils citation" frame="void" id="b7-a" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id5">[b7_a]</a></td><td>Edgar Peters, “Chaos and Order in the Capital Markets: A New
View of Cycles, Prices, and Market Volatility”, Wiley: Hoboken,
2nd Edition, 1996.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="b7-b" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id6">[b7_b]</a></td><td>Ian L. Kaplan, “Estimating the Hurst Exponent”,
url: <a class="reference external" href="http://www.bearcave.com/misl/misl_tech/wavelets/hurst/">http://www.bearcave.com/misl/misl_tech/wavelets/hurst/</a></td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="b7-c" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id7">[b7_c]</a></td><td>HwB, “Pracma: brown72”,
url: <a class="reference external" href="https://www.rdocumentation.org/packages/pracma/versions/1.9.9/topics/brown72">https://www.rdocumentation.org/packages/pracma/versions/1.9.9/topics/brown72</a></td></tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="tent-map">
<h3>Tent map<a class="headerlink" href="#tent-map" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="nolds.tent_map">
<code class="descclassname">nolds.</code><code class="descname">tent_map</code><span class="sig-paren">(</span><em>x</em>, <em>steps</em>, <em>mu=2</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nolds/datasets.html#tent_map"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nolds.tent_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates a time series of the tent map.</p>
<dl class="docutils">
<dt>Characteristics and Background:</dt>
<dd>The name of the tent map is derived from the fact that the plot of x_i vs
x_i+1 looks like a tent. For mu &gt; 1 one application of the mapping function
can be viewed as stretching the surface on which the value is located and
then folding the area that is greater than one back towards the zero. This
corresponds nicely to the definition of chaos as expansion in one dimension
which is counteracted by a compression in another dimension.</dd>
<dt>Calculating the Lyapunov exponent:</dt>
<dd><p class="first">The lyapunov exponent of the tent map can be easily calculated as due to
this stretching behavior a small difference delta between two neighboring
points will indeed grow exponentially by a factor of mu in each iteration.
We thus can assume that:</p>
<p>delta_n = delta_0 * mu^n</p>
<p>We now only have to change the basis to e to obtain the exact formula that
is used for the definition of the lyapunov exponent:</p>
<p>delta_n = delta_0 * e^(ln(mu) * n)</p>
<p>Therefore the lyapunov exponent of the tent map is:</p>
<p class="last">lambda = ln(mu)</p>
</dd>
<dt>References:</dt>
<dd><table class="first last docutils citation" frame="void" id="tm-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[tm_1]</td><td><a class="reference external" href="https://en.wikipedia.org/wiki/Tent_map">https://en.wikipedia.org/wiki/Tent_map</a></td></tr>
</tbody>
</table>
</dd>
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>x (float):</dt>
<dd>starting point</dd>
<dt>steps (int):</dt>
<dd>number of steps for which the generator should run</dd>
</dl>
</dd>
<dt>Kwargs:</dt>
<dd><dl class="first last docutils">
<dt>mu (int):</dt>
<dd>parameter mu that controls the behavior of the map</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>generator object:</dt>
<dd>the generator that creates the time series</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="logistic-map">
<h3>Logistic map<a class="headerlink" href="#logistic-map" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="nolds.logistic_map">
<code class="descclassname">nolds.</code><code class="descname">logistic_map</code><span class="sig-paren">(</span><em>x</em>, <em>steps</em>, <em>r=4</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nolds/datasets.html#logistic_map"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nolds.logistic_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates a time series of the logistic map.</p>
<dl class="docutils">
<dt>Characteristics and Background:</dt>
<dd>The logistic map is among the simplest examples for a time series that can
exhibit chaotic behavior depending on the parameter r. For r between 2 and 
3, the series quickly becomes static. At r=3 the first bifurcation point is
reached after which the series starts to oscillate. Beginning with r = 3.6
it shows chaotic behavior with a few islands of stability until perfect
chaos is achieved at r = 4.</dd>
<dt>Calculating the Lyapunov exponent:</dt>
<dd><p class="first">To calculate the “true” Lyapunov exponent of the logistic map, we first
have to make a few observations for maps in general that are repeated
applications of a function to a starting value.</p>
<p>If we have two starting values that differ by some infinitesimal 
<span class="math">\(delta_0\)</span> then according to the definition of the lyapunov exponent
we will have an exponential divergence:</p>
<div class="math">
\[|\delta_n| = |\delta_0| e^{\lambda n}\]</div>
<p>We can now write that:</p>
<div class="math">
\[e^{\lambda n} = \lim_{\delta_0 -&gt; 0} |\frac{\delta_n}{\delta_0}|\]</div>
<p>This is the definition of the derivative <span class="math">\(\frac{dx_n}{dx_0}\)</span> of a
point <span class="math">\(x_n\)</span> in the time series with respect to the starting point
<span class="math">\(x_0\)</span> (or rather the absolute value of that derivative). Now we can
use the fact that due to the definition of our map as repetitive
application of some f we have:</p>
<div class="math">
\[f^{n\prime}(x) = f(f(f(...f(x_0)...))) = f'(x_n-1) \cdot f'(x_n-2)
\cdot ... \cdot f'(x_0)\]</div>
<p>with</p>
<div class="math">
\[e^{\lambda n} = |f^{n\prime}(x)|\]</div>
<p>we now have</p>
<div class="math">
\[\begin{split}e^{\lambda n} &amp;= |f'(x_n-1) \cdot f'(x_n-2) \cdot ... \cdot f'(x_0)| \\
\Leftrightarrow \\
\lambda n &amp;= \ln |f'(x_n-1) \cdot f'(x_n-2) \cdot ... \cdot f'(x_0)| \\
\Leftrightarrow \\
\lambda &amp;= \frac{1}{n} \ln |f'(x_n-1) \cdot f'(x_n-2) \cdot ... \cdot f'(x_0)| \\
       &amp;= \frac{1}{n} \sum_{k=0}^{n-1} \ln |f'(x_k)|\end{split}\]</div>
<p>With this sum we can now calculate the lyapunov exponent for any map.
For the logistic map we simply have to calculate <span class="math">\(f'(x)\)</span> and as we
have</p>
<div class="math">
\[f(x) = r x (1-x) = rx - rx²\]</div>
<p>we now get</p>
<div class="last math">
\[f'(x) = r - 2 rx\]</div>
</dd>
<dt>References:</dt>
<dd><table class="first docutils citation" frame="void" id="lm-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[lm_1]</td><td><a class="reference external" href="https://en.wikipedia.org/wiki/Tent_map">https://en.wikipedia.org/wiki/Tent_map</a></td></tr>
</tbody>
</table>
<table class="last docutils citation" frame="void" id="lm-2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[lm_2]</td><td><a class="reference external" href="https://blog.abhranil.net/2015/05/15/lyapunov-exponent-of-the-logistic-map-mathematica-code/">https://blog.abhranil.net/2015/05/15/lyapunov-exponent-of-the-logistic-map-mathematica-code/</a></td></tr>
</tbody>
</table>
</dd>
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>x (float):</dt>
<dd>starting point</dd>
<dt>steps (int):</dt>
<dd>number of steps for which the generator should run</dd>
</dl>
</dd>
<dt>Kwargs:</dt>
<dd><dl class="first last docutils">
<dt>r (int):</dt>
<dd>parameter r that controls the behavior of the map</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>generator object:</dt>
<dd>the generator that creates the time series</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="fractional-brownian-motion">
<h3>Fractional brownian motion<a class="headerlink" href="#fractional-brownian-motion" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="nolds.fbm">
<code class="descclassname">nolds.</code><code class="descname">fbm</code><span class="sig-paren">(</span><em>n</em>, <em>H=0.75</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nolds/datasets.html#fbm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nolds.fbm" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates fractional brownian motions of desired length.</p>
<dl class="docutils">
<dt>Author:</dt>
<dd>Christian Thomae</dd>
<dt>References:</dt>
<dd><table class="first last docutils citation" frame="void" id="fbm-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[fbm_1]</td><td><a class="reference external" href="https://en.wikipedia.org/wiki/Fractional_Brownian_motion#Method_1_of_simulation">https://en.wikipedia.org/wiki/Fractional_Brownian_motion#Method_1_of_simulation</a></td></tr>
</tbody>
</table>
</dd>
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>n (int):</dt>
<dd>length of sequence to generate</dd>
</dl>
</dd>
<dt>Kwargs:</dt>
<dd><dl class="first last docutils">
<dt>H (float):</dt>
<dd>hurst parameter</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>array of float:</dt>
<dd>simulated fractional brownian motion</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="fractional-gaussian-noise">
<h3>Fractional gaussian noise<a class="headerlink" href="#fractional-gaussian-noise" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="nolds.fgn">
<code class="descclassname">nolds.</code><code class="descname">fgn</code><span class="sig-paren">(</span><em>n</em>, <em>H=0.75</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nolds/datasets.html#fgn"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nolds.fgn" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates fractional gaussian noise of desired length.</p>
<dl class="docutils">
<dt>References:</dt>
<dd><table class="first last docutils citation" frame="void" id="fgn-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[fgn_1]</td><td><a class="reference external" href="https://en.wikipedia.org/wiki/Fractional_Brownian_motion">https://en.wikipedia.org/wiki/Fractional_Brownian_motion</a></td></tr>
</tbody>
</table>
</dd>
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>n (int):</dt>
<dd>length of sequence to generate</dd>
</dl>
</dd>
<dt>Kwargs:</dt>
<dd><dl class="first last docutils">
<dt>H (float):</dt>
<dd>hurst parameter</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>array of float:</dt>
<dd>simulated fractional gaussian noise</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="quantum-random-numbers">
<h3>Quantum random numbers<a class="headerlink" href="#quantum-random-numbers" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="nolds.qrandom">
<code class="descclassname">nolds.</code><code class="descname">qrandom</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/nolds/datasets.html#qrandom"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nolds.qrandom" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates an array of n true random numbers obtained from the quantum random
number generator at qrng.anu.edu.au</p>
<p>This function requires the package quantumrandom and an internet connection.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>n (int):</dt>
<dd>length of the random array</dd>
</dl>
</dd>
<dt>Return:</dt>
<dd><dl class="first last docutils">
<dt>array of ints:</dt>
<dd>array of truly random unsigned 16 bit int values</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="nolds.load_qrandom">
<code class="descclassname">nolds.</code><code class="descname">load_qrandom</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/nolds/datasets.html#load_qrandom"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#nolds.load_qrandom" title="Permalink to this definition">¶</a></dt>
<dd><p>Loads a set of 10000 random numbers generated by qrandom.</p>
<p>This dataset can be used when you want to do some limited tests with “true”
random data without an internet connection.</p>
<dl class="docutils">
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>int array</dt>
<dd>the dataset</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#"><code class="docutils literal"><span class="pre">nolds</span></code> module</a><ul>
<li><a class="reference internal" href="#algorithms">Algorithms</a><ul>
<li><a class="reference internal" href="#lyapunov-exponent-rosenstein-et-al">Lyapunov exponent (Rosenstein et al.)</a></li>
<li><a class="reference internal" href="#lyapunov-exponent-eckmann-et-al">Lyapunov exponent (Eckmann et al.)</a></li>
<li><a class="reference internal" href="#sample-entropy">Sample entropy</a></li>
<li><a class="reference internal" href="#hurst-exponent">Hurst exponent</a></li>
<li><a class="reference internal" href="#correlation-dimension">Correlation dimension</a></li>
<li><a class="reference internal" href="#detrended-fluctuation-analysis">Detrended fluctuation analysis</a></li>
</ul>
</li>
<li><a class="reference internal" href="#helper-functions">Helper functions</a></li>
<li><a class="reference internal" href="#datasets">Datasets</a><ul>
<li><a class="reference internal" href="#benchmark-dataset-for-hurst-exponent">Benchmark dataset for hurst exponent</a></li>
<li><a class="reference internal" href="#tent-map">Tent map</a></li>
<li><a class="reference internal" href="#logistic-map">Logistic map</a></li>
<li><a class="reference internal" href="#fractional-brownian-motion">Fractional brownian motion</a></li>
<li><a class="reference internal" href="#fractional-gaussian-noise">Fractional gaussian noise</a></li>
<li><a class="reference internal" href="#quantum-random-numbers">Quantum random numbers</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
      <li>Previous: <a href="index.html" title="previous chapter">Welcome to Nolds’ documentation!</a></li>
      <li>Next: <a href="examples.html" title="next chapter">Nolds examples</a></li>
  </ul></li>
</ul>
</div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/nolds.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2016-2018, Christopher Schölzel.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.6.6</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.10</a>
      
      |
      <a href="_sources/nolds.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>